<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="小六子的鱼的个人博客" type="application/atom+xml">






<meta name="description" content="某211大学研究生">
<meta property="og:type" content="website">
<meta property="og:title" content="小六子的鱼的个人博客">
<meta property="og:url" content="https://xiaodupi-zyq.github.io/page/2/index.html">
<meta property="og:site_name" content="小六子的鱼的个人博客">
<meta property="og:description" content="某211大学研究生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小六子的鱼的个人博客">
<meta name="twitter:description" content="某211大学研究生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaodupi-zyq.github.io/page/2/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
  <title>小六子的鱼的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/xiaodupi-zyq/xiaodupi-zyq.github.io"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_white_ffffff.png?resize=149%2C149" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小六子的鱼的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">无穷的伟大,也是从“一”开始的</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/二叉树/" itemprop="url">二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:41:49+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二叉树基础上：什么样的二叉树适合用数组来存储？"><a href="#二叉树基础上：什么样的二叉树适合用数组来存储？" class="headerlink" title="二叉树基础上：什么样的二叉树适合用数组来存储？"></a>二叉树基础上：什么样的二叉树适合用数组来存储？</h1><p>非线性数据结构，树。树这种数据结构比线性表的数据结构复杂的多，内容也比较多，所以我分四节来讲解。</p>
<p><strong>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储</strong></p>
<h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>什么是树？直接上图：<br><img src="/2020/06/16/二叉树/什么是树.jpg" alt="什么是树"></p>
<p>树中每个元素叫做“节点”；用来连接相邻节点之间的关系，叫做“父子关系”;</p>
<p><img src="/2020/06/16/二叉树/节点关系.jpg" alt="节点关系"></p>
<p>其中A节点是B节点的<strong>父节点</strong>，B节点是A节点的<strong>子节点</strong>。B,C,D这三个节点的父节点是同一个节点，所以他们之间互称<strong>兄弟节点</strong>。没有父节点的节点是<strong>根结点</strong>，E节点就是根节点。没有子节点的节点叫做<strong>叶子节点</strong>或者叶节点，比如图中的G,H,I,J,K,L都是叶子结点。</p>
<p><strong>树的高度，树的深度，树的层</strong></p>
<pre><code>节点的高度 = 节点到叶子节点的最长路径（边数）
节点的深度 = 根节点到这个节点所经历的边的个数
节点的层数 = 节点深度 + 1
树的高度   = 根节点的高度
</code></pre><p>具体如下图：<br><img src="/2020/06/16/二叉树/高度_深度_层.jpg" alt="高度_深度_层"></p>
<p>高度这个概念要从下往上看，从最底层开始计数，并且计数的起点是0 。</p>
<p>深度这个概念从上往下看，从根节点开始往下度量，并且计数起点也是0 。</p>
<p>层数跟深度计数类似，不过计数起点是1，也就是根节点位于第一层。</p>
<h2 id="二叉树（Binary-Tree"><a href="#二叉树（Binary-Tree" class="headerlink" title="二叉树（Binary Tree)"></a>二叉树（Binary Tree)</h2><p>二叉树，顾名思义，每个节点最多两个叉，也就是两个子节点，分别是左子节点和右子节点。不过二叉树并不要求每个节点都有两个子节点，有的节点自由左子节点，有的只有右子节点。<br><img src="/2020/06/16/二叉树/二叉树.jpg" alt="二叉树"></p>
<p>图中，编号2的二叉树，叶子节点全都在最底层，除了叶子结点，每个节点都有左右两个子节点，这种二叉树就叫做<strong>满二叉树</strong>。</p>
<p>编号3的二叉树，所有的叶子结点都在最下面两层，最后一层的叶子节点，都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大，这种二叉树叫做<strong>完全二叉树</strong>。<br><img src="/2020/06/16/二叉树/完全二叉树.jpg" alt="完全二叉树"></p>
<h2 id="如何表示或者存储一颗二叉树？"><a href="#如何表示或者存储一颗二叉树？" class="headerlink" title="如何表示或者存储一颗二叉树？"></a>如何表示或者存储一颗二叉树？</h2><p>想要存储一颗二叉树，我们有两种方法，一种基于指针引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>
<h3 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h3><p><img src="/2020/06/16/二叉树/链式存储法.jpg" alt="链式存储法"></p>
<h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h3><p>我们把根节点存储在下标为1的位置，左子节点存储在下标为 2 <em> i = 2 的位置，右子节点存储在 2 </em> i + 1 = 3的位置。<br><img src="/2020/06/16/二叉树/顺序存储法.jpg" alt="顺序存储法"></p>
<p>总结：如果节点X存储在数组中下标为i的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 位置存储的就是右子节点。反过来，下标为i/2的位置存储的就是他的父节点。</p>
<p>一颗完全二叉树，所以仅仅浪费了一个下标为0的存储位置。如果是非完全二叉树，会浪费比较多的数组存储空间。<br><img src="/2020/06/16/二叉树/非完全二叉树顺序存储.jpg" alt="非完全二叉树顺序存储"></p>
<p>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>三种经典方法，<strong>前序遍历、中序遍历和后序遍历</strong></p>
<p>前序遍历：树中任意结点来说，先打印这个节点，然后打印它的左子树，最后打印他的右子树。</p>
<p>中序遍历：树中任意结点来说，先打印左子树，然后打印它本身，最后打印它的右子树。</p>
<p>后序遍历：树中任意结点来说，先打印左子树，然后打印它的右子树，最后打印它本身。</p>
<p><img src="/2020/06/16/二叉树/前序_中序_后序.jpg" alt="前序_中序_后序"></p>
<p><strong>二叉树的前中后序遍历就是一个递归的过程</strong><br>递推公式如下：</p>
<pre><code>前序遍历的递推公式：
preOrder(r) = print(r) -&gt; preOrder(r -&gt; left) -&gt; preOrder(r -&gt; right)
中序遍历的递推公式：
inOrder(r) = inOrder(r-&gt;left) -&gt; print r -&gt; inOrder(r -&gt; right)
后序遍历的递推公式：
postOrder(r) = postOrder(r -&gt; left) -&gt; postOrder(r -&gt; right) -&gt; print r
</code></pre><p>相应的伪代码如下：</p>
<pre><code>void preOrder(Node* root) {
    if(root == null){
        return;
    }
    preOrder(root -&gt; left);
    preOrder(root -&gt; right);
}

void inOrder(Node* root){
    if(root == null){
        return;
    }
    inOrder(root -&gt; left);
    print root;
    inOrder(root -&gt; right);
}

void postOrder(Node* root){
    if(root == null) {
        return;
    }
    postOrder(root -&gt; left);
    postOrder(root -&gt; right);
    print root;
}
</code></pre><p>代码实现：中序遍历</p>
<pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List list = new ArrayList&lt;&gt;();
    if(root == null){
        return list;
    }
    if(root.left != null){
        list.addAll(inorderTraversal(root.left));
    }
    list.add(root.val);
    if(root.right != null){
        list.addAll(inorderTraversal(root.right));
    }
    return list;
}
</code></pre><p><strong>二叉树遍历的时间复杂度是多少呢？</strong><br>遍历操作的时间复杂度，跟结点的个数n成正比，也就是说，二叉树的时间复杂度是O(n).</p>
<h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇&amp;内容小结"></a>解答开篇&amp;内容小结</h2><p>根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p>
<p>二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p>
<p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)，你需要理解并能用递归代码来实现。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol>
<li>给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？</li>
</ol>
<p>n！个组合。</p>
<ol start="2">
<li><p>我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？</p>
<pre><code>public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {
    Deque&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    ArrayList list = new ArrayList();
    if(root == null){
        return list;
    }
    //将根节点加入到队列中
    queue.add(root);
    //队列为空就结束循环
    while(!queue.isEmpty()){
        //取头节点
        TreeNode node = queue.peek();
        //将头节点弹出
        queue.poll();
        //将头节点的元素值加入到列表中
        list.add(node.val);
        //如果头节点有左右子节点就将子节点加入到队列中
        if(node.left != null){
            queue.add(node.left);
        }
        if(node.right != null){
            queue.add(node.right);
        }
    }
    return list;
}
</code></pre></li>
</ol>
<h1 id="二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？"><a href="#二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？" class="headerlink" title="二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？"></a>二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？</h1><p>二叉查找树，支持动态数据集合的快速插入、删除、查找操作。</p>
<p>之前说散列表也支持这样的操作，并且时间复杂度是O(1)。<strong>既然有了这么高效的散列表，使用二叉树的这些地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</strong></p>
<h2 id="二叉查找树-（Binary-Search-Tree）"><a href="#二叉查找树-（Binary-Search-Tree）" class="headerlink" title="二叉查找树 （Binary Search Tree）"></a>二叉查找树 （Binary Search Tree）</h2><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每一个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p><img src="/2020/06/16/二叉树/二叉查找树.jpg" alt="二叉查找树"></p>
<h3 id="1、二叉查找树的查找操作"><a href="#1、二叉查找树的查找操作" class="headerlink" title="1、二叉查找树的查找操作"></a>1、二叉查找树的查找操作</h3><p>如何在二叉查找树中查找一个节点。我们先取根节点，如果他等于我们要查找的数据就返回。如果查找数据比根节点小，那就在其左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<p><img src="/2020/06/16/二叉树/二叉查找树查找操作.jpg" alt="二叉查找树查找操作"></p>
<p>代码实现：</p>
<pre><code>public class BinarySearchTree {
    public static class Node{
        private int data;
        private Node left;
        private Node right;

        public Node(int data){
            this.data = data;
        }
    }
    private Node tree;

    public Node find(int data){
        Node p = tree;
        while (p != null){
            if(data &lt; p.data){
                p = p.left;
            }else if(data &gt; p.data){
                p = p.right;
            }else return p;
        }
        return null;
    }
}
</code></pre><h3 id="2、二叉查找树的插入操作"><a href="#2、二叉查找树的插入操作" class="headerlink" title="2、二叉查找树的插入操作"></a>2、二叉查找树的插入操作</h3><p>插入过程有点类似于插座操作。<br>如果插入数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<p><img src="/2020/06/16/二叉树/二叉查找树的插入操作.jpg" alt="二叉查找树的插入操作"></p>
<p>代码实现：</p>
<pre><code>public void insert(int data){
    if(tree == null){
        tree = new Node(data);
        return;
    }

    Node p = tree;
    while(p != null){
        if(data &gt; p.data){
            if(p.right == null){
                p.right = new Node(data);
                return;
            }
            p = p.right;
        } else { //data &lt; p.data
            if(p.left == null){
                p.left = new Node(data);
                return;
            }
            p = p.left;
        }
    }
}
</code></pre><h3 id="3、二叉查找树的删除操作"><a href="#3、二叉查找树的删除操作" class="headerlink" title="3、二叉查找树的删除操作"></a>3、二叉查找树的删除操作</h3><p>第一种情况是，如果删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置null，如图删除结点55；<br>第二种情况是，如果删除节点只有一个子节点（只有左子节点或者右子节点），我们需要更新父节点中，指向要删除节点的指针，让他指向删除节点的子节点就可以了。如图节点13；<br>第三种情况是，如果要删除节点中有两个子节点，这就比较麻烦了。我们需要找到这个节点的在右子树的最小节点，把它替换到要删除的节点上。然后再删除这个最小节点，因为最小节点肯定没有左子节点，所以我们可以用上面两条规则来删除这个最小节点。如图删除节点18；</p>
<p><img src="/2020/06/16/二叉树/二叉查找树的删除操作.jpg" alt="二叉查找树的删除操作"></p>
<p>代码实现：</p>
<pre><code>public void delete(int data){
    Node p = tree;
    Node pp = null;
    while(p != null &amp;&amp; p.data != data){
        pp = p;
        if(data &gt; p.data){
            p = p.right;
        }else{
            p = p.left;
        }
        if(p == null){
            return;
        }

        //要删除的节点有两个子节点
        if(p.left != null &amp;&amp; p.right != null){
            Node minP = p.right;
            Node minPP = p;
            while(minP.left != null){
                minPP = minP;
                minP = minP.left;
            }
            p.data = minP.data;
            p = minP;
            pp = minPP;
        }

        Node child ;
        if(p.left != null) child = p.left;
        else if(p.right != null) child = p.right;
        else child = null;

        if(pp == null) tree = child;
        else if(pp.left == p) pp.left = child;
        else pp.right = child;

    }
}
</code></pre><h3 id="4、二叉查找树的其他操作"><a href="#4、二叉查找树的其他操作" class="headerlink" title="4、二叉查找树的其他操作"></a>4、二叉查找树的其他操作</h3><p>快速的查找最大节点和最小节点、前驱节点和后继节点。</p>
<p>按照中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)非常高效。</p>
<h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>实际开发中，我们在二叉树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值来构建二叉查找树，对象的其他字段叫做卫星数据。</p>
<p>如果存储的两个对象的键值相同，这种情况如何处理呢？<br>第一种方法：二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
<p>第二种方法：在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到右子树，也就是把新插入的数据当做大于这个节点的值处理。</p>
<p><img src="/2020/06/16/二叉树/插入相同数据.jpg" alt="插入相同数据"></p>
<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，知道遇到叶子节点，才停止。</p>
<p><img src="/2020/06/16/二叉树/查找所有相同数据.jpg" alt="查找所有相同数据"></p>
<p>对于删除操作，我们也需要先查找每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除；</p>
<p><img src="/2020/06/16/二叉树/删除所有相同数据.jpg" alt="删除所有相同数据"></p>
<h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><p>图中第一种二叉查找树已经退化成链表，查找的时间复杂度变成了O(n);</p>
<p><img src="/2020/06/16/二叉树/时间复杂度.jpg" alt="时间复杂度"></p>
<p>理想情况下，二叉查找树是一颗完全二叉树或满二叉树，这时插入、删除、查找的时间复杂度是多少呢？</p>
<p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？</p>
<p>第 K 层包含的节点个数就是 2^(K-1)。</p>
<p>对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L</p>
<p>如果节点个数是n，那么n满足这样一个关系：</p>
<pre><code>n &gt;= 1+2+4+8+...+2^(L-2)+1
n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)
</code></pre><p>借助等比数列的求和公式，我们可以计算出，L 的范围是 [log2(n+1), log2n +1]。完全二叉树的层数小于等于 log2n +1，也就是说，完全二叉树的高度小于等于 log2n。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>散列表的插入，删除，查找复杂度可以做到常量级O(1),二叉查找树的，插入，删除，查找操作时间复杂度才是O(logn)，因此为啥还要使用二叉查找树？</p>
<p>第一：散列表的数据是无序存储的，如果要输出有序数据，要先排序，而对于二叉查找树只需要中序遍历，就可以在O(n)的时间复杂度中，输出有序数据序列。</p>
<p>第二：散列表扩容耗时很多，而且遇到散列冲突，性能不稳定，尽管二叉查找树的性能不稳定，但在工程中我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p>
<p>第三：笼统的来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际查找速度可能不一定比O(logn)快，加上哈希函数的耗时，也不一定就比平航查找树的效率高。</p>
<p>第四：散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p>
<p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p>
<h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>今天我讲了二叉树高度的理论分析方法，给出了粗略的数量级。如何通过编程，求出一棵给定二叉树的确切高度呢？</p>
<pre><code>//递归求二叉树的深度
public int TreeDepth(TreeNode root) {
    int depth = 0;
    //如果root为null，返回depth = 0；
    if(root == null){
        return depth;
    }
    //否则进行递归，如果左子树深度比右子树深度大，最大深度就在左子树上加1;否则反之
    if(TreeDepth(root.left) &gt; TreeDepth(root.right)){
        depth = TreeDepth(root.left) + 1;
    }else{
        depth = TreeDepth(root.right) + 1;
    }
    return depth;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/链表/" itemprop="url">链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:28:53+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>缓存大小一定，当缓存满了之后，如何清理呢，三种策略：先进先出策略FIFO，最少使用策略LFU，最近最少使用策略LRU</p>
<p>如何使用链表实现LRU缓存淘汰策略呢？</p>
<p>首先数组是一块连续的内存空间来存储，对内存要求很高。而链表不需要一块连续的内存空间，通过指针将一堆零散的内存块连起来使用。<br>链表分为单链表，双链表和循环链表<br><img src="/2020/06/16/链表/单链表.jpg" alt="单链表"><br>插入和删除<br><img src="/2020/06/16/链表/插入和删除.jpg" alt="插入和删除"><br>链表的随机访问没有数组好，需要O(n)的时间复杂度</p>
<p>循环链表和双向链表，循环链表是一种特殊的单链表，即尾指针指向了链表的头节点。<br><img src="/2020/06/16/链表/循环链表.jpg" alt="循环链表"><br>双向链表不光只有后向指针还有前向指针<br><img src="/2020/06/16/链表/双向链表.jpg" alt="双向链表"><br>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点</p>
<p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p>
<p>如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度</p>
<p>对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）</p>
<p>LRU算法的实现：<br>维护一个有序单链表，越靠近尾部的节点是越早之前访问的，当有一个新的数据比访问时，我们从链表头开始遍历链表</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；<br>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ol>
<h3 id="几个写链表代码的技巧"><a href="#几个写链表代码的技巧" class="headerlink" title="几个写链表代码的技巧"></a>几个写链表代码的技巧</h3><h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。<br>经常会有这样的代码：p-&gt;next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p>
<h3 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h3><p><img src="/2020/06/16/链表/指针丢失.jpg" alt="指针丢失"><br>使用以下代码就将指针丢失了</p>
<pre><code>p-&gt;next = x;
x-&gt;next = p-&gt;next;
</code></pre><p>这样的结果最后是x的指针指向x<br>插入结点时，一定要注意操作的顺序，如果上述代码，交换位置就是正确的了，x-&gt;next指向b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。</p>
<h3 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h3><p>如果在结点P后插入新结点，正确的代码为：</p>
<pre><code>new_node-&gt;next = p-&gt;next;
p-&gt;next = new_node;
</code></pre><p>但如果要向空链表中插入第一个结点，刚刚逻辑不能用，而应该是这样的</p>
<pre><code>if(head == null){
    head = new_node;
}
</code></pre><p>删除结点</p>
<pre><code>p-&gt;next = p-&gt;next-&gt;next;
</code></pre><p>最后一个结点删除</p>
<pre><code>if(head-&gt;next == null){
    head = null;
}
</code></pre><p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</p>
<p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。</p>
<h3 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h3><p>代码在一些边界或者异常情况下，最容易产生Bug。</p>
<p><strong>检查边界条件：（也是其他编程时考虑的方法）</strong></p>
<ol>
<li>如果链表为空时，代码是否正常工作；</li>
<li>如果链表只含一个结点时，代码是否正常工作；</li>
<li>如果链表只含两个结点时，代码是否正常工作；</li>
<li>代码逻辑在处理头节点和尾节点的时候，代码是否正常工作；</li>
</ol>
<h3 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h3><p>举例法和画图法<br><img src="/2020/06/16/链表/举例画图.jpg" alt="举例画图"><br>将要做的操作进行基本的画图操作。</p>
<h3 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h3><p>几个常用链表操作，多写多练</p>
<ol>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个结点</li>
<li><p>求链表中间结点</p>
<pre><code>public class MyLinked {
private Node1 head;
private Node1 last;
MyLinked() throws Exception{
    this(5);
}
MyLinked(int capacity) throws Exception{
    this(&apos;a&apos;,capacity,false);
}
MyLinked(char c,int capacity,boolean random) throws Exception{
    if(capacity &lt;= 0){
        throw new Exception(&quot;链表容量不能为空或负&quot;);
    }
    char ch = c;
    for(int i = 0; i &lt; capacity; i++){
        Node1 node = new Node1();
        node.c = ch;
        if(!random){
            ch++;
        }else{
            Random rand = new Random();
            ch+=rand.nextInt(5);
        }

        if(i == 0){
            head = node;
            last = node;
        }else{
            last.node = node;
            last = node;
        }

    }
    last.node = null;
}

public void out(){
    Node1 p = new Node1();
    p = head;
    while (p != null){
        System.out.print(p.c + &quot; &quot;);
        p = p.node;
    }
    System.out.println();
}

public void reverse(){
    Node1 newLast = head;
    Node1 newHead = head;

    Node1 t = head.node;
    while (t != null){
        Node1 node = new Node1();
        node = t;
        t = t.node;
        node.node = newHead;
        newHead = node;
    }
    newLast.node = null; //记得最后链表节点为null
    last = newLast;
    head = newHead;
}

//环的检测，快慢指针
public boolean isCircle(){
    if(head == last){
        return false;
    }
    Node1 p = head;
    Node1 q = head;

    while(q.node != null &amp;&amp; q.node.node != null &amp;&amp; q != null){
        q = q.node.node;
        p = p.node;
        if(q == p){
            return true;
        }
    }
    return false;
}

//有序链表合并
public MyLinked merge(MyLinked myLinked1,MyLinked myLinked2) throws Exception {
    MyLinked mergeLinked = new MyLinked(1);
    Node1 head1 = myLinked1.head;
    Node1 head2 = myLinked2.head;
    Node1 mergehead = mergeLinked.head;

    while(head1 != null &amp;&amp; head2 != null){
        if(head1.c &lt;= head2.c){
            mergehead.node = head1;
            head1 = head1.node;
        }else{
            mergehead.node = head2;
            head2 = head2.node;
        }
        mergehead = mergehead.node;
    }
    if(head1 != null){
        mergehead.node = head1;
        mergeLinked.head = mergeLinked.head.node;
        mergeLinked.last = myLinked1.last;
    }else{
        mergehead.node = head2;
        mergeLinked.head = mergeLinked.head.node;
        mergeLinked.last = myLinked1.last;
    }
    return mergeLinked;
}

public void deleteLastNNode(int n){
    Node1 p = new Node1();
    Node1 q = new Node1();
    p.node = q.node = head;
    for(int i = 0; i &lt; n;i++){
        if(p == null){
            System.out.println(&quot;链表总长不足： &quot; + n);
            return;
        }
        p = p.node;
    }
    while (p != last){
        p = p.node;
        q = q.node;
    }
    if(q.node == head){
        head = head.node;
        return;
    }
    q.node = q.node.node;

}

public Node1 middle(){
    Node1 p = head;
    Node1 q = head;
    while(p.node != null &amp;&amp; p.node.node != null){
        p = p.node.node;
        q = q.node;
    }
    return q;
}
</code></pre></li>
</ol>
<pre><code>public static void main(String[] args) throws Exception{
    MyLinked myLinked = new MyLinked(10);
    myLinked.out();

    System.out.println(&quot;是否有环：&quot;);
    System.out.println(myLinked.isCircle());
    myLinked.last.node = myLinked.head;
    System.out.println(myLinked.isCircle());
    myLinked.last.node = null;

    System.out.println(&quot;求链表中间结点：&quot;);
    Node1 middle = myLinked.middle();
    System.out.println(middle.c);

    System.out.println(&quot;反转链表：&quot;);
    myLinked.reverse();
    myLinked.out();

    System.out.println(&quot;链表合并：&quot;);
    MyLinked myLinked1 = new MyLinked(&apos;a&apos;,4,true);
    myLinked1.out();
    MyLinked myLinked2 = new MyLinked(&apos;c&apos;,2,true);
    myLinked2.out();
    MyLinked mergeLinked = new MyLinked(1);
    mergeLinked = myLinked.merge(myLinked1,myLinked2);
    mergeLinked.out();

    System.out.println(&quot;删除倒数第n个结点：&quot;);
    myLinked.deleteLastNNode(5);
    myLinked.out();

}
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2019/11/12/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/12/HashMap/" itemprop="url">HashMap自我详细理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-12T17:19:33+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>简介：<br>Java为了数据结构中的映射定义了一个接口，java.util.Map，此接口主要用四个实现，主要是HashMap，Hashtable，LinkedHashMap，TreeMap。具体的继承关系如下：<br><img src="/2019/11/12/HashMap/继承关系.png" alt="继承关系"><br>具体四种实现类的特点如下：<br>（1)HashMap:根据键的hashcode值存储数据，大多数情况下可以直接定位到它的值，访问速度很快，但是遍历顺序是不确定的。在键值对中只允许一条记录的键为null。且HashMap非线程安全，可以用ConcurrentHashMap具有线程安全的能力。</p>
<hr>
<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。<br> JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.<br> JDK1.8 之后解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组长度小于64，那么会选择进行数组扩容，而不是转换成红黑树），以减少搜索时间。</p>
<h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8之前HashMap底层是数组和链表结合在一起使用的链表散列。HashMap通过key的hashCode经过扰动函数处理之后得到hash值，然后通过（n-1） &amp; hash判断当前元素存放的位置（这里的n指的是数组的长度），如果当前位置村子元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同的话就通过拉链法解决冲突。<br>扰动函数就是hash方法，使用hash方法主要是防止性能较差的hashcode方法，从而减少碰撞。<br>1.8的hash方法</p>
<pre><code>static final int hash(Object key) {
    int h;
    //key.hashCode() : 返回散列值也就是hashcod
    //^ ： 按位异或
    //&gt;&gt;&gt;：无符号右移，忽略符号位，空位都以0补齐
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>1.7的hash方法</p>
<pre><code>static int hash(int h){
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
</code></pre><p>1.8的hash函数性能更高，因为1.7的hash函数扰动了四次</p>
<p>拉链法： 数组与链表结合，如图<br><img src="/2019/11/12/HashMap/拉链法.png" alt="拉链法"><br>JDK1.8之后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。<br><img src="/2019/11/12/HashMap/拉链法红黑树.png" alt="1.8的拉链法"></p>
<h3 id="类的属性："><a href="#类的属性：" class="headerlink" title="类的属性："></a>类的属性：</h3><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMAp&lt;K,V&gt; implements Map&lt;K,V&gt;,Cloneable,Serializable{
    // 序列号
    private static final long serialVersionUID = 362498820763181265L;    
    // 默认的初始容量是16
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;   
    // 最大容量
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 
    // 默认的填充因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // 当桶(bucket)上的结点数大于这个值时会转成红黑树
    static final int TREEIFY_THRESHOLD = 8; 
    // 当桶(bucket)上的结点数小于这个值时树转链表
    static final int UNTREEIFY_THRESHOLD = 6;
    // 桶中结构转化为红黑树对应的table的最小大小
    static final int MIN_TREEIFY_CAPACITY = 64;
    // 存储元素的数组，总是2的幂次倍
    transient Node&lt;k,v&gt;[] table; 
    // 存放具体元素的集
    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;
    // 存放元素的个数，注意这个不等于数组的长度。
    transient int size;
    // 每次扩容和更改map结构的计数器
    transient int modCount;   
    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容
    int threshold;
    // 加载因子
    final float loadFactor;
}
</code></pre><p>loadFactory加载因子：加载因子控制数据的疏密程度，默认0.75比较好的临界值。<br>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能</p>
<p>threshold<br>threshold = capacity*loadFactor,当Size&gt;=threshold的时候，考虑扩增</p>
<h3 id="节点类源码"><a href="#节点类源码" class="headerlink" title="节点类源码"></a>节点类源码</h3><pre><code>//继承自Map.Entry&lt;K,V&gt; 
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较
    final K key;//键
    V value; //值
    //指向下一个节点
    Node&lt;K,V&gt; next;
    Node(int hash, K key,V value,Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
    public final K getKey() {return key;}
    public final V getValue() {return value;}
    public final String toString() {return key + &quot;=&quot; + value;}
    //重写hashCode方法
    public final int hashCode(){
        return Objects.hashCode(Key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    //重写equals方法
    public final boolean equals(Object o) {
        if(o == this){
            return true;
        }
        if(o instanceof Map.Entry){
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
            //任何属于Map.Entry的对象都可以进行比较，比较过程中，key要相等，value也要相等
            if(Objects.equals(key,e.getKey()) &amp;&amp; Objects.equals(value,e.getValue())){
                return true;
            }
        }
    }
}
</code></pre><h3 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h3><pre><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {
    TreeNode&lt;K,V&gt; parent; //父
    TreeNode&lt;K,V&gt; left; //左
    TreeNode&lt;K,V&gt; right; //右
    TreeNode&lt;K,V&gt; prev; //needed to unlink next upon deletion
    boolean red; //判断颜色
    TreeNode(int hash,K key,V val,Node&lt;K,V&gt; next) {
        super(hash,key,val,next);
    }
    //返回根节点
    final TreeNode&lt;K,V&gt; root() {
        final (TreeNode&lt;K,V&gt; r = this,p;;) {
            if((p = r.parent) == null) {
                return r;
            }
            r = p;
        }
    }
}
</code></pre><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>//默认构造函数
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; //all other fields defaulted
}

//包含另一个“Map”的构造函数
public HashMap(Map&lt;? extends K,? extends V&gt; m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m,false);//下面分析
}

//指定“容量大小”的构造函数
public HashMap(int initialCapacity) {
    this(initialCapacity,DEFAULT_LOAD_FACTOR);
}

//指定容量大小和加载因子的构造函数
public HashMap(int initialCapacity, final loadFactor) {
    //初始容量小于零和大于最大的情况
    if(initialCapacity &lt; 0){
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
    }
    if(initialCapacity &gt; MAXIMUM_CAPACITY){
        initialCapacity = MAXIMUM_CAPACITY;
    }
    //加载因子的限制条件
    if(loadFactor &lt;= 0 || Float.isNaN(loadFactor)){
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);
    }
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(inintialCapacity); 
}
</code></pre><p>putMapEntries方法：</p>
<pre><code>//就是将已有构造函数的m放进新的hashMap
final void putMapEntries(Map&lt;? extends K,? extends V&gt; m , boolean evict) {
    int s = m.size();
    if(s &gt; 0) {
        //判断table是否初始化
        if(table == null) {
            //未初始化，s为m的实际个数
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int) ft : MAXIMUM_CAPACITY);
            //计算得到的t大于阈值，则初始化阈值
            if(t &gt; threshold){
                threshold = tableSizeFor(t);
            }
            //已初始化，并且m元素个数大于阈值，进行扩容处理
            else if (s &gt; threshold){
                resize();
            }
            //将m中所有的元素添加到HashMap中
            for(Map.Entry&lt;? extends K,? extends V&gt; e : m.EntrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key),key,value,false,evict)
            }
        }
    }
}
</code></pre><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p>
<h4 id="对putVal方法添加元素的分析如下："><a href="#对putVal方法添加元素的分析如下：" class="headerlink" title="对putVal方法添加元素的分析如下："></a>对putVal方法添加元素的分析如下：</h4><p>1、如果定位到的数组位置没有元素就直接插入<br>2、如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this,tab,hash,key,value)将元素添加进入，如果不是就遍历链表插入（插入的是链表尾部）</p>
<p><img src="/2019/11/12/HashMap/put流程图.png" alt="put流程图"></p>
<pre><code>//put源码
public V put(K key , V value){
    return putVal(hash(key),key,value,false,true);
}

final V putVal(int hash,K key, V value,boolean onlyIfAbsent,boolean evict) {
    Node&lt;K,V&gt;[] tab;
    Node&lt;K,V&gt; p; 
    int n,i;
    //table未初始化或者长度为0，进行扩容
    if((tab = table) == null || (n = tab.length) == 0){
        n = (tab = resize()).length; 
    }
    //(n - 1) &amp; hash确定元素存放在哪个桶内，桶为空，新生成的节点放入桶内，此时的节点是放在数组内的
    if((p = tab[i = (n - 1) &amp; hash]) == null){
        tab[i] = newNode(hash, key, value, null);
    }
    //桶内已有存在的元素
    else{
        Node&lt;K,V&gt; e; K k;
        //比较桶中第一个元素（数组中的节点）的hash值是否相等，key相等
        if(p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))){
            //将第一个元素赋给e，用e来记录
            e = p;
        }
        //hash值不相等，即key不相等，为红黑树节点
        else if(p instanceof TreeNode) {
            //放入树中
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        }
        //为链表节点
        else {
            //在链表最末插入结点
            for((e = p.next()) == null) {
                //在尾部插入新节点
                p.next = newNode(hash,key,value,null);
                // 结点数量达到阈值，转化为红黑树
                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                    treeifyBin(tab, hash);
                // 跳出循环
                break;
            }
            // 判断链表中结点的key值与插入的元素的key值是否相等
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                // 相等，跳出循环
                break;
            // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
            p = e;
        }
    }

    // 表示在桶中找到key值、hash值与插入元素相等的结点
    if (e != null) { 
        // 记录e的value
        V oldValue = e.value;
        // onlyIfAbsent为false或者旧值为null
        if (!onlyIfAbsent || oldValue == null)
            //用新值替换旧值
            e.value = value;
        // 访问后回调
        afterNodeAccess(e);
        // 返回旧值
        return oldValue;
    }
}
// 结构性修改
++modCount;
// 实际大小大于阈值则扩容
if (++size &gt; threshold)
    resize();
// 插入后回调
afterNodeInsertion(evict);
return null;
}
</code></pre><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><pre><code>public V get(Object key) {
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {
        // 数组元素相等
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 桶中不止一个节点
        if ((e = first.next) != null) {
            // 在树中get
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 在链表中get
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
<pre><code>final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table; //旧数组
    int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧数组的大小
    int oldThr = threshold; //旧数组的阈值
    int newCap, newThr = 0; //初始化新数组的容量和阈值为0
    if (oldCap &gt; 0) {
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE; //将阈值也调整到最大，任由碰撞吧
            return oldTab;
        }
        // 没超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // 阈值也调整为两倍
    }
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else { 
        // signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 计算新的resize上限
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else { 
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        // 原索引
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 原索引+oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
</code></pre><p><strong><strong><strong><strong>***</strong></strong></strong></strong>未完待续</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2019/11/12/LinkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/12/LinkedList/" itemprop="url">LinkedList</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-12T13:56:33+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList实现了List接口和Deque接口的双端链表。<br>链表结构支持高效的插入和删除操作，<br>Deque接口使得LinkedList类具有队列的特性。</p>
<p><img src="/2019/11/12/LinkedList/内部结构.png" alt="内部结构"><br><img src="/2019/11/12/LinkedList/节点.png" alt="节点"></p>
<h2 id="LinkedList类中的内部私有类Node"><a href="#LinkedList类中的内部私有类Node" class="headerlink" title="LinkedList类中的内部私有类Node"></a>LinkedList类中的内部私有类Node</h2><pre><code>private static class Node&lt;E&gt; {
    E item; //结点值
    Node&lt;E&gt; next; //后继节点
    Node&lt;E&gt; prev; //前驱节点
    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next){
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre><h2 id="LinkedList源码分析："><a href="#LinkedList源码分析：" class="headerlink" title="LinkedList源码分析："></a>LinkedList源码分析：</h2><h3 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h3><pre><code>public LinkedList(){
}

public LinkedList(Collection&lt;? extends E&gt; c) {
    this();
    addAll(c);
}
</code></pre><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p>add(E e)方法：将元素添加到链表的尾部</p>
<pre><code>public boolean add(E e){
    linkLast(e);//调用方法
    return true;
}

/**
  *链接使e作为最后一个元素
  */
void linkLast(E e){
    final Node&lt;E&gt; l = last; //l指向链表尾部
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l,e,null); //新建结点将结点放在链表尾部
    last = newNode;//新建结点
    if(l == null){ //说明原链表为空，新建结点既是第一个也是最后一个
        first = newNode;
    }else{
        l.next = newNode;//指向下一个元素
    }
    size++;
    modCount++;
}
</code></pre><p>add(int index,E e) 在指定位置添加元素</p>
<pre><code>public void add(int index, E element) {
    checkPositionIndex(index);//检查索引是否处于【0~size】之间
    if(index == size) {
        linkLast(element);
    }else{
        linkBefore(element,node(index));
    }
}
</code></pre><p>linkBefore方法需要给定两个参数，一个插入结点的值，一个指定的node，所以我们调用了node(index)查找index对应的node<br>addAll(Collection c) : 将集合插入到链表尾部</p>
<pre><code>public boolean addAll(Collection&lt;? extends E&gt; c) {
    return addAll(size,c)
}
</code></pre><p>addAll(int index, Collection c)： 将集合从指定位置开始插入</p>
<pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    //1:检查index范围是否在size之内
    checkPositionIndex(index);

    //2:toArray()方法把集合的数据存到对象数组中
    Object[] a = c.toArray();
    int numNew = a.length;
    if (numNew == 0)
        return false;

    //3：得到插入位置的前驱节点和后继节点
    Node&lt;E&gt; pred, succ;
    //如果插入位置为尾部，前驱节点为last，后继节点为null
    if (index == size) {
        succ = null;
        pred = last;
    }
    //否则，调用node()方法得到后继节点，再得到前驱节点
    else {
        succ = node(index);
        pred = succ.prev;
    }

    // 4：遍历数据将数据插入
    for (Object o : a) {
        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
        //创建新节点
        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);
        //如果插入位置在链表头部
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        pred = newNode;
    }

    //如果插入位置在尾部，重置last节点
    if (succ == null) {
        last = pred;
    }
    //否则，将插入的链表与先前链表连接起来
    else {
        pred.next = succ;
        succ.prev = pred;
    }

    size += numNew;
    modCount++;
    return true;
}
</code></pre><h3 id="addAll方法通常包括四个步骤："><a href="#addAll方法通常包括四个步骤：" class="headerlink" title="addAll方法通常包括四个步骤："></a>addAll方法通常包括四个步骤：</h3><pre><code>1、检查index范围是否在size之内
2、toArray()方法把集合中的数据存到对象数组中
3、得到插入位置的前驱和后继节点
4、遍历数据将数据插入到指定位置
</code></pre><p>addFirst(E e):将元素添加到链表头部</p>
<pre><code>public void addFirst(E e) {
    linkFirst(e);
}

private void linkFirst(E e) {
    final Node&lt;E&gt; f = first;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//新建节点，以头节点为后继节点
    first = newNode;
    //如果链表为空，last节点也指向该节点
    if (f == null)
        last = newNode;
    //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素
    else
        f.prev = newNode;
    size++;
    modCount++;
}
</code></pre><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a>根据位置取数据的方法</h3><p>get(int index) : 根据指定索引返回数据</p>
<pre><code>public E get(int index) {
    //检查index范围是否在size之内
    checkElementIndex(index);
    //调用Node(index)去找到index对应的node然后返回它的值
    return node(index).item;
}
</code></pre><h3 id="获取头节点的数据方法："><a href="#获取头节点的数据方法：" class="headerlink" title="获取头节点的数据方法："></a>获取头节点的数据方法：</h3><pre><code>public E getFirst() {
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return f.item;
}
public E element() {
    return getFirst();
}
public E peek() {
    final Node&lt;E&gt; f = first;
    return (f == null) ? null : f.item; //跟getFirst唯一的区别在于头为空不报错
}
public E peekFirst() {
    final Node&lt;E&gt; f = first;
    return (f == null) ? null : f.item;
}
</code></pre><h3 id="区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常"><a href="#区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常" class="headerlink" title="区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常"></a>区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常</h3><p>获取尾节点（index = -1）数据方法：</p>
<pre><code>public E getLast() {
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return l.item;
}
public E peekLast() {
    final Node&lt;E&gt; l = last;
    return (l == null) ? null : l.item;
}
</code></pre><p>根据对象得到索引的方法<br>int indexOf(Object o) : 从头遍历找</p>
<pre><code>public int indexOf(Object o) {
    int index = 0;
    if(o == null) {
        for(Node&lt;E&gt; x = first; x != null; x = x.next) {
            if(x.item == null) {
                return index;
            }
            index++;
        }
    } else {
        for(Node&lt;E&gt; x = first; x != null; x = x.next) {
            if(o.equals(x.item)){
                return index;
            }
            index++;
        }
    }
    return -1;
}
</code></pre><h3 id="检查链表是否包含对象的方法："><a href="#检查链表是否包含对象的方法：" class="headerlink" title="检查链表是否包含对象的方法："></a>检查链表是否包含对象的方法：</h3><p>contains(Object o) : 检查对象o是否存在于链表中</p>
<pre><code>public boolean contains(Object o) {
    return indexOf(o) != -1;
}
</code></pre><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><p>remove(),removeFirst,pop() : 删除头节点<br>    public E pop() {<br>        return removeFirst();<br>    }<br>    public E remove() {<br>        return removeFirst();<br>    }<br>    public E removeFirst() {<br>        final Node<e> f = first;<br>        if (f == null)<br>            throw new NoSuchElementException();<br>        return unlinkFirst(f);<br>    }</e></p>
<p>removeLast(), pollLast(): 删除尾节点</p>
<pre><code>public E removeLast() {
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return unlinkLast(l);
}
public E pollLast() {
    final Node&lt;E&gt; l = last;
    return (l == null) ? null : unlinkLast(l);
}
</code></pre><p>remove(Object o) : 删除指定元素</p>
<pre><code>public boolean remove(Object o) {
    //如果删除对象为null
    if (o == null) {
        //从头开始遍历
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            //找到元素
            if (x.item == null) {
               //从链表中移除找到的元素
                unlink(x);
                return true;
            }
        }
    } else {
        //从头开始遍历
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            //找到元素
            if (o.equals(x.item)) {
                //从链表中移除找到的元素
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
</code></pre><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p>
<p>unlink(Node x)方法：</p>
<pre><code>E unlink(Node&lt;E&gt; x) {
    // assert x != null;
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;//得到后继节点
    final Node&lt;E&gt; prev = x.prev;//得到前驱节点

    //删除前驱指针
    if (prev == null) {
        first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点
    } else {
        prev.next = next;//将前驱节点的后继节点指向后继节点
        x.prev = null;
    }

    //删除后继指针
    if (next == null) {
        last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
</code></pre><p>remove(int index)：删除指定位置的元素</p>
<pre><code>public E remove(int index) {
    //检查index范围
    checkElementIndex(index);
    //将节点删除
    return unlink(node(index));
}
</code></pre><h3 id="LinkList类常用方法测试"><a href="#LinkList类常用方法测试" class="headerlink" title="LinkList类常用方法测试"></a>LinkList类常用方法测试</h3><pre><code>package list;

import java.util.Iterator;
import java.util.LinkedList;

public class LinkedListDemo {
    public static void main(String[] srgs) {
        //创建存放int类型的linkedList
        LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();
        /************************** linkedList的基本操作 ************************/
        linkedList.addFirst(0); // 添加元素到列表开头
        linkedList.add(1); // 在列表结尾添加元素
        linkedList.add(2, 2); // 在指定位置添加元素
        linkedList.addLast(3); // 添加元素到列表结尾

        System.out.println(&quot;LinkedList（直接输出的）: &quot; + linkedList);

        System.out.println(&quot;getFirst()获得第一个元素: &quot; + linkedList.getFirst()); // 返回此列表的第一个元素
        System.out.println(&quot;getLast()获得第最后一个元素: &quot; + linkedList.getLast()); // 返回此列表的最后一个元素
        System.out.println(&quot;removeFirst()删除第一个元素并返回: &quot; + linkedList.removeFirst()); // 移除并返回此列表的第一个元素
        System.out.println(&quot;removeLast()删除最后一个元素并返回: &quot; + linkedList.removeLast()); // 移除并返回此列表的最后一个元素
        System.out.println(&quot;After remove:&quot; + linkedList);
        System.out.println(&quot;contains()方法判断列表是否包含1这个元素:&quot; + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true
        System.out.println(&quot;该linkedList的大小 : &quot; + linkedList.size()); // 返回此列表的元素个数

        /************************** 位置访问操作 ************************/
        System.out.println(&quot;-----------------------------------------&quot;);
        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素
        System.out.println(&quot;After set(1, 3):&quot; + linkedList);
        System.out.println(&quot;get(1)获得指定位置（这里为1）的元素: &quot; + linkedList.get(1)); // 返回此列表中指定位置处的元素

        /************************** Search操作 ************************/
        System.out.println(&quot;-----------------------------------------&quot;);
        linkedList.add(3);
        System.out.println(&quot;indexOf(3): &quot; + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引
        System.out.println(&quot;lastIndexOf(3): &quot; + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引

        /************************** Queue操作 ************************/
        System.out.println(&quot;-----------------------------------------&quot;);
        System.out.println(&quot;peek(): &quot; + linkedList.peek()); // 获取但不移除此列表的头
        System.out.println(&quot;element(): &quot; + linkedList.element()); // 获取但不移除此列表的头
        linkedList.poll(); // 获取并移除此列表的头
        System.out.println(&quot;After poll():&quot; + linkedList);
        linkedList.remove();
        System.out.println(&quot;After remove():&quot; + linkedList); // 获取并移除此列表的头
        linkedList.offer(4);
        System.out.println(&quot;After offer(4):&quot; + linkedList); // 将指定元素添加到此列表的末尾

        /************************** Deque操作 ************************/
        System.out.println(&quot;-----------------------------------------&quot;);
        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素
        System.out.println(&quot;After offerFirst(2):&quot; + linkedList);
        linkedList.offerLast(5); // 在此列表末尾插入指定的元素
        System.out.println(&quot;After offerLast(5):&quot; + linkedList);
        System.out.println(&quot;peekFirst(): &quot; + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素
        System.out.println(&quot;peekLast(): &quot; + linkedList.peekLast()); // 获取但不移除此列表的第一个元素
        linkedList.pollFirst(); // 获取并移除此列表的第一个元素
        System.out.println(&quot;After pollFirst():&quot; + linkedList);
        linkedList.pollLast(); // 获取并移除此列表的最后一个元素
        System.out.println(&quot;After pollLast():&quot; + linkedList);
        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）
        System.out.println(&quot;After push(2):&quot; + linkedList);
        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）
        System.out.println(&quot;After pop():&quot; + linkedList);
        linkedList.add(3);
        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）
        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);
        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）
        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);

        /************************** 遍历操作 ************************/
        System.out.println(&quot;-----------------------------------------&quot;);
        linkedList.clear();
        for (int i = 0; i &lt; 100000; i++) {
            linkedList.add(i);
        }
        // 迭代器遍历
        long start = System.currentTimeMillis();
        Iterator&lt;Integer&gt; iterator = linkedList.iterator();
        while (iterator.hasNext()) {
            iterator.next();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Iterator：&quot; + (end - start) + &quot; ms&quot;);

        // 顺序遍历(随机遍历)
        start = System.currentTimeMillis();
        for (int i = 0; i &lt; linkedList.size(); i++) {
            linkedList.get(i);
        }
        end = System.currentTimeMillis();
        System.out.println(&quot;for：&quot; + (end - start) + &quot; ms&quot;);

        // 另一种for循环遍历
        start = System.currentTimeMillis();
        for (Integer i : linkedList)
            ;
        end = System.currentTimeMillis();
        System.out.println(&quot;for2：&quot; + (end - start) + &quot; ms&quot;);

        // 通过pollFirst()或pollLast()来遍历LinkedList
        LinkedList&lt;Integer&gt; temp1 = new LinkedList&lt;&gt;();
        temp1.addAll(linkedList);
        start = System.currentTimeMillis();
        while (temp1.size() != 0) {
            temp1.pollFirst();
        }
        end = System.currentTimeMillis();
        System.out.println(&quot;pollFirst()或pollLast()：&quot; + (end - start) + &quot; ms&quot;);

        // 通过removeFirst()或removeLast()来遍历LinkedList
        LinkedList&lt;Integer&gt; temp2 = new LinkedList&lt;&gt;();
        temp2.addAll(linkedList);
        start = System.currentTimeMillis();
        while (temp2.size() != 0) {
            temp2.removeFirst();
        }
        end = System.currentTimeMillis();
        System.out.println(&quot;removeFirst()或removeLast()：&quot; + (end - start) + &quot; ms&quot;);
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2019/04/19/django数据库空值（admin字段空值保存）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/django数据库空值（admin字段空值保存）/" itemprop="url">django数据库空值（admin字段空值保存）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T16:18:58+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>admin后台设置字段为空，很多时候我们的数据库数据在建立之初不会有值，但又不能没有这个字段，比如学生管理系统中的选课表，在这个表中至少有以下几个字段，即：学生学号，课程号，成绩。直接上代码：</p>
<pre><code>例如：
    class Stu_cou(models.Model):
        student_number = models.ForeignKey(Student,on_delete=models.CASCADE,verbose_name=&apos;选课学生&apos;)
        course_number = models.ForeignKey(Course,on_delete=models.CASCADE,verbose_name=&apos;课程号&apos;)
        score = models.FloatField(&apos;成绩&apos;)
在表中定义了一个学生选课表。
但是在后台admin添加或者前端创建一条实例的时候，成绩不可能有值的，这个时候数据库是不会存储成绩的数据的，这个时候我们应该设置字段可空。则最后一个成绩字段应该设置为：
        score = models.FloatField(&apos;成绩&apos;,blank=True,null=True)
    其中：
        null = True
        数据库字段可为空值
        blank = True
        django的Admin中添加数据允许空值。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2019/04/18/django数据库OnetoOnefield的一些错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/django数据库OnetoOnefield的一些错误/" itemprop="url">django数据库OnetoOnefield的一些错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T20:52:13+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>django数据库操作过程中出现django.db.utils.IntegrityError: NOT NULL constraint failed: …… 检查级联新建的数据，是否保存，如果有OneToOneField出现，检查上一级的数据表是否已经保存。</p>
<pre><code>例如：
            new_user = User.objects.create_user(username = work_number, password = password2,email=email)
            new_allusers = models.Allusers()
            new_student = models.Student()
            new_allusers.user = new_user
            new_allusers.realname = realname
            new_allusers.sex = sex
            new_allusers.is_teacher = is_teacher
            ####################################################################
            student_class = models.Class.objects.get(classname=class_name)
            new_student.student_user = new_allusers
            new_student.student_class = student_class
            ####################################################################
            new_user.save()
            new_allusers.save()
            new_student.save()
在这个例子中new_allusers并未保存的情况下，直接将其赋值给new_student.student_user，将会出现文中开头的错误。
正确的代码应该是：
            new_user = User.objects.create_user(username = work_number, password = password2,email=email)
            new_allusers = models.Allusers()
            new_allusers.user = new_user
            new_allusers.realname = realname
            new_allusers.sex = sex
            new_allusers.is_teacher = is_teacher
            new_user.save()
            new_allusers.save()

            #####将上级的表格进行保存之后，也就是在数据库中存在了new_allusers，之后再讲new_allusers赋值给new_student.student_user➷➷➷

            new_student = models.Student()
            student_class = models.Class.objects.get(classname=class_name)
            new_student.student_user = new_allusers
            new_student.student_class = student_class

            new_student.save()
有人会说了，在代码的前面new_allusers.user = new_user并没有提前保存，就直接赋值了，但是new_user是使用create_user创建的，在数据库中已经有这么一个数据对象了，所以下面就可以直接赋值了。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2019/04/13/小六子的鱼的个人博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/小六子的鱼的个人博客/" itemprop="url">小六子的鱼的个人博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-13T19:10:09+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近搭建了这个博客，我想着可以把自己学习生活过程中的点点滴滴，记录下来，分享出去如果可以的话可以给大家一些帮助最好了。主要是记录自己的学习生活和新路历程。还有的是，在这里我要特别提到我的一个益友良师Neo，一个在我开始编程的领路人，一个编程牛人。以后自己就要在这里记录自己的学习了！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="小六子的鱼">
            
              <p class="site-author-name" itemprop="name">小六子的鱼</p>
              <p class="site-description motion-element" itemprop="description">某211大学研究生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://xiaodupi-zyq.github.io/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xiaoliuzizyq@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xiao-ya-ma-xiao-liu-zi/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neowyj.github.io/" title="Neowyj" target="_blank">Neowyj</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.arflow.cn/t/4" title="ARFlow" target="_blank">ARFlow</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://snailclimb.top/JavaGuide/#/?id=java" title="JavaGuide" target="_blank">JavaGuide</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小六子的鱼</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>

-->



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    








  





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
