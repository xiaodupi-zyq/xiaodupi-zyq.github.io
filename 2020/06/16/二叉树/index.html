<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="小六子的鱼的个人博客" type="application/atom+xml">






<meta name="description" content="二叉树基础上：什么样的二叉树适合用数组来存储？非线性数据结构，树。树这种数据结构比线性表的数据结构复杂的多，内容也比较多，所以我分四节来讲解。 二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储 树（Tree）什么是树？直接上图： 树中每个元素叫做“节点”；用来连接相邻节点之间的关系，叫做“父子关系”;  其中A节点是B节点的父节点，B节点是A节点的子节点。B,C,D这三个节点的父节点是同一个">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/index.html">
<meta property="og:site_name" content="小六子的鱼的个人博客">
<meta property="og:description" content="二叉树基础上：什么样的二叉树适合用数组来存储？非线性数据结构，树。树这种数据结构比线性表的数据结构复杂的多，内容也比较多，所以我分四节来讲解。 二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储 树（Tree）什么是树？直接上图： 树中每个元素叫做“节点”；用来连接相邻节点之间的关系，叫做“父子关系”;  其中A节点是B节点的父节点，B节点是A节点的子节点。B,C,D这三个节点的父节点是同一个">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/什么是树.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/节点关系.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/高度_深度_层.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/二叉树.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/完全二叉树.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/链式存储法.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/顺序存储法.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/非完全二叉树顺序存储.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/前序_中序_后序.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/二叉查找树.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/二叉查找树查找操作.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/二叉查找树的插入操作.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/二叉查找树的删除操作.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/插入相同数据.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/查找所有相同数据.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/删除所有相同数据.jpg">
<meta property="og:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/时间复杂度.jpg">
<meta property="og:updated_time" content="2020-06-16T13:46:09.359Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="二叉树">
<meta name="twitter:description" content="二叉树基础上：什么样的二叉树适合用数组来存储？非线性数据结构，树。树这种数据结构比线性表的数据结构复杂的多，内容也比较多，所以我分四节来讲解。 二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储 树（Tree）什么是树？直接上图： 树中每个元素叫做“节点”；用来连接相邻节点之间的关系，叫做“父子关系”;  其中A节点是B节点的父节点，B节点是A节点的子节点。B,C,D这三个节点的父节点是同一个">
<meta name="twitter:image" content="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/什么是树.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
  <title>二叉树 | 小六子的鱼的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/xiaodupi-zyq/xiaodupi-zyq.github.io"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_white_ffffff.png?resize=149%2C149" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小六子的鱼的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">无穷的伟大,也是从“一”开始的</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">二叉树</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:41:49+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/16/二叉树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2020/06/16/二叉树/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="二叉树基础上：什么样的二叉树适合用数组来存储？"><a href="#二叉树基础上：什么样的二叉树适合用数组来存储？" class="headerlink" title="二叉树基础上：什么样的二叉树适合用数组来存储？"></a>二叉树基础上：什么样的二叉树适合用数组来存储？</h1><p>非线性数据结构，树。树这种数据结构比线性表的数据结构复杂的多，内容也比较多，所以我分四节来讲解。</p>
<p><strong>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储</strong></p>
<h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>什么是树？直接上图：<br><img src="/2020/06/16/二叉树/什么是树.jpg" alt="什么是树"></p>
<p>树中每个元素叫做“节点”；用来连接相邻节点之间的关系，叫做“父子关系”;</p>
<p><img src="/2020/06/16/二叉树/节点关系.jpg" alt="节点关系"></p>
<p>其中A节点是B节点的<strong>父节点</strong>，B节点是A节点的<strong>子节点</strong>。B,C,D这三个节点的父节点是同一个节点，所以他们之间互称<strong>兄弟节点</strong>。没有父节点的节点是<strong>根结点</strong>，E节点就是根节点。没有子节点的节点叫做<strong>叶子节点</strong>或者叶节点，比如图中的G,H,I,J,K,L都是叶子结点。</p>
<p><strong>树的高度，树的深度，树的层</strong></p>
<pre><code>节点的高度 = 节点到叶子节点的最长路径（边数）
节点的深度 = 根节点到这个节点所经历的边的个数
节点的层数 = 节点深度 + 1
树的高度   = 根节点的高度
</code></pre><p>具体如下图：<br><img src="/2020/06/16/二叉树/高度_深度_层.jpg" alt="高度_深度_层"></p>
<p>高度这个概念要从下往上看，从最底层开始计数，并且计数的起点是0 。</p>
<p>深度这个概念从上往下看，从根节点开始往下度量，并且计数起点也是0 。</p>
<p>层数跟深度计数类似，不过计数起点是1，也就是根节点位于第一层。</p>
<h2 id="二叉树（Binary-Tree"><a href="#二叉树（Binary-Tree" class="headerlink" title="二叉树（Binary Tree)"></a>二叉树（Binary Tree)</h2><p>二叉树，顾名思义，每个节点最多两个叉，也就是两个子节点，分别是左子节点和右子节点。不过二叉树并不要求每个节点都有两个子节点，有的节点自由左子节点，有的只有右子节点。<br><img src="/2020/06/16/二叉树/二叉树.jpg" alt="二叉树"></p>
<p>图中，编号2的二叉树，叶子节点全都在最底层，除了叶子结点，每个节点都有左右两个子节点，这种二叉树就叫做<strong>满二叉树</strong>。</p>
<p>编号3的二叉树，所有的叶子结点都在最下面两层，最后一层的叶子节点，都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大，这种二叉树叫做<strong>完全二叉树</strong>。<br><img src="/2020/06/16/二叉树/完全二叉树.jpg" alt="完全二叉树"></p>
<h2 id="如何表示或者存储一颗二叉树？"><a href="#如何表示或者存储一颗二叉树？" class="headerlink" title="如何表示或者存储一颗二叉树？"></a>如何表示或者存储一颗二叉树？</h2><p>想要存储一颗二叉树，我们有两种方法，一种基于指针引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>
<h3 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h3><p><img src="/2020/06/16/二叉树/链式存储法.jpg" alt="链式存储法"></p>
<h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h3><p>我们把根节点存储在下标为1的位置，左子节点存储在下标为 2 <em> i = 2 的位置，右子节点存储在 2 </em> i + 1 = 3的位置。<br><img src="/2020/06/16/二叉树/顺序存储法.jpg" alt="顺序存储法"></p>
<p>总结：如果节点X存储在数组中下标为i的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 位置存储的就是右子节点。反过来，下标为i/2的位置存储的就是他的父节点。</p>
<p>一颗完全二叉树，所以仅仅浪费了一个下标为0的存储位置。如果是非完全二叉树，会浪费比较多的数组存储空间。<br><img src="/2020/06/16/二叉树/非完全二叉树顺序存储.jpg" alt="非完全二叉树顺序存储"></p>
<p>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>三种经典方法，<strong>前序遍历、中序遍历和后序遍历</strong></p>
<p>前序遍历：树中任意结点来说，先打印这个节点，然后打印它的左子树，最后打印他的右子树。</p>
<p>中序遍历：树中任意结点来说，先打印左子树，然后打印它本身，最后打印它的右子树。</p>
<p>后序遍历：树中任意结点来说，先打印左子树，然后打印它的右子树，最后打印它本身。</p>
<p><img src="/2020/06/16/二叉树/前序_中序_后序.jpg" alt="前序_中序_后序"></p>
<p><strong>二叉树的前中后序遍历就是一个递归的过程</strong><br>递推公式如下：</p>
<pre><code>前序遍历的递推公式：
preOrder(r) = print(r) -&gt; preOrder(r -&gt; left) -&gt; preOrder(r -&gt; right)
中序遍历的递推公式：
inOrder(r) = inOrder(r-&gt;left) -&gt; print r -&gt; inOrder(r -&gt; right)
后序遍历的递推公式：
postOrder(r) = postOrder(r -&gt; left) -&gt; postOrder(r -&gt; right) -&gt; print r
</code></pre><p>相应的伪代码如下：</p>
<pre><code>void preOrder(Node* root) {
    if(root == null){
        return;
    }
    preOrder(root -&gt; left);
    preOrder(root -&gt; right);
}

void inOrder(Node* root){
    if(root == null){
        return;
    }
    inOrder(root -&gt; left);
    print root;
    inOrder(root -&gt; right);
}

void postOrder(Node* root){
    if(root == null) {
        return;
    }
    postOrder(root -&gt; left);
    postOrder(root -&gt; right);
    print root;
}
</code></pre><p>代码实现：中序遍历</p>
<pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List list = new ArrayList&lt;&gt;();
    if(root == null){
        return list;
    }
    if(root.left != null){
        list.addAll(inorderTraversal(root.left));
    }
    list.add(root.val);
    if(root.right != null){
        list.addAll(inorderTraversal(root.right));
    }
    return list;
}
</code></pre><p><strong>二叉树遍历的时间复杂度是多少呢？</strong><br>遍历操作的时间复杂度，跟结点的个数n成正比，也就是说，二叉树的时间复杂度是O(n).</p>
<h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇&amp;内容小结"></a>解答开篇&amp;内容小结</h2><p>根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p>
<p>二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p>
<p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)，你需要理解并能用递归代码来实现。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol>
<li>给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？</li>
</ol>
<p>n！个组合。</p>
<ol start="2">
<li><p>我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？</p>
<pre><code>public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {
    Deque&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
    ArrayList list = new ArrayList();
    if(root == null){
        return list;
    }
    //将根节点加入到队列中
    queue.add(root);
    //队列为空就结束循环
    while(!queue.isEmpty()){
        //取头节点
        TreeNode node = queue.peek();
        //将头节点弹出
        queue.poll();
        //将头节点的元素值加入到列表中
        list.add(node.val);
        //如果头节点有左右子节点就将子节点加入到队列中
        if(node.left != null){
            queue.add(node.left);
        }
        if(node.right != null){
            queue.add(node.right);
        }
    }
    return list;
}
</code></pre></li>
</ol>
<h1 id="二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？"><a href="#二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？" class="headerlink" title="二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？"></a>二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？</h1><p>二叉查找树，支持动态数据集合的快速插入、删除、查找操作。</p>
<p>之前说散列表也支持这样的操作，并且时间复杂度是O(1)。<strong>既然有了这么高效的散列表，使用二叉树的这些地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</strong></p>
<h2 id="二叉查找树-（Binary-Search-Tree）"><a href="#二叉查找树-（Binary-Search-Tree）" class="headerlink" title="二叉查找树 （Binary Search Tree）"></a>二叉查找树 （Binary Search Tree）</h2><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每一个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p><img src="/2020/06/16/二叉树/二叉查找树.jpg" alt="二叉查找树"></p>
<h3 id="1、二叉查找树的查找操作"><a href="#1、二叉查找树的查找操作" class="headerlink" title="1、二叉查找树的查找操作"></a>1、二叉查找树的查找操作</h3><p>如何在二叉查找树中查找一个节点。我们先取根节点，如果他等于我们要查找的数据就返回。如果查找数据比根节点小，那就在其左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<p><img src="/2020/06/16/二叉树/二叉查找树查找操作.jpg" alt="二叉查找树查找操作"></p>
<p>代码实现：</p>
<pre><code>public class BinarySearchTree {
    public static class Node{
        private int data;
        private Node left;
        private Node right;

        public Node(int data){
            this.data = data;
        }
    }
    private Node tree;

    public Node find(int data){
        Node p = tree;
        while (p != null){
            if(data &lt; p.data){
                p = p.left;
            }else if(data &gt; p.data){
                p = p.right;
            }else return p;
        }
        return null;
    }
}
</code></pre><h3 id="2、二叉查找树的插入操作"><a href="#2、二叉查找树的插入操作" class="headerlink" title="2、二叉查找树的插入操作"></a>2、二叉查找树的插入操作</h3><p>插入过程有点类似于插座操作。<br>如果插入数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<p><img src="/2020/06/16/二叉树/二叉查找树的插入操作.jpg" alt="二叉查找树的插入操作"></p>
<p>代码实现：</p>
<pre><code>public void insert(int data){
    if(tree == null){
        tree = new Node(data);
        return;
    }

    Node p = tree;
    while(p != null){
        if(data &gt; p.data){
            if(p.right == null){
                p.right = new Node(data);
                return;
            }
            p = p.right;
        } else { //data &lt; p.data
            if(p.left == null){
                p.left = new Node(data);
                return;
            }
            p = p.left;
        }
    }
}
</code></pre><h3 id="3、二叉查找树的删除操作"><a href="#3、二叉查找树的删除操作" class="headerlink" title="3、二叉查找树的删除操作"></a>3、二叉查找树的删除操作</h3><p>第一种情况是，如果删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置null，如图删除结点55；<br>第二种情况是，如果删除节点只有一个子节点（只有左子节点或者右子节点），我们需要更新父节点中，指向要删除节点的指针，让他指向删除节点的子节点就可以了。如图节点13；<br>第三种情况是，如果要删除节点中有两个子节点，这就比较麻烦了。我们需要找到这个节点的在右子树的最小节点，把它替换到要删除的节点上。然后再删除这个最小节点，因为最小节点肯定没有左子节点，所以我们可以用上面两条规则来删除这个最小节点。如图删除节点18；</p>
<p><img src="/2020/06/16/二叉树/二叉查找树的删除操作.jpg" alt="二叉查找树的删除操作"></p>
<p>代码实现：</p>
<pre><code>public void delete(int data){
    Node p = tree;
    Node pp = null;
    while(p != null &amp;&amp; p.data != data){
        pp = p;
        if(data &gt; p.data){
            p = p.right;
        }else{
            p = p.left;
        }
        if(p == null){
            return;
        }

        //要删除的节点有两个子节点
        if(p.left != null &amp;&amp; p.right != null){
            Node minP = p.right;
            Node minPP = p;
            while(minP.left != null){
                minPP = minP;
                minP = minP.left;
            }
            p.data = minP.data;
            p = minP;
            pp = minPP;
        }

        Node child ;
        if(p.left != null) child = p.left;
        else if(p.right != null) child = p.right;
        else child = null;

        if(pp == null) tree = child;
        else if(pp.left == p) pp.left = child;
        else pp.right = child;

    }
}
</code></pre><h3 id="4、二叉查找树的其他操作"><a href="#4、二叉查找树的其他操作" class="headerlink" title="4、二叉查找树的其他操作"></a>4、二叉查找树的其他操作</h3><p>快速的查找最大节点和最小节点、前驱节点和后继节点。</p>
<p>按照中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)非常高效。</p>
<h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>实际开发中，我们在二叉树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值来构建二叉查找树，对象的其他字段叫做卫星数据。</p>
<p>如果存储的两个对象的键值相同，这种情况如何处理呢？<br>第一种方法：二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
<p>第二种方法：在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到右子树，也就是把新插入的数据当做大于这个节点的值处理。</p>
<p><img src="/2020/06/16/二叉树/插入相同数据.jpg" alt="插入相同数据"></p>
<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，知道遇到叶子节点，才停止。</p>
<p><img src="/2020/06/16/二叉树/查找所有相同数据.jpg" alt="查找所有相同数据"></p>
<p>对于删除操作，我们也需要先查找每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除；</p>
<p><img src="/2020/06/16/二叉树/删除所有相同数据.jpg" alt="删除所有相同数据"></p>
<h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><p>图中第一种二叉查找树已经退化成链表，查找的时间复杂度变成了O(n);</p>
<p><img src="/2020/06/16/二叉树/时间复杂度.jpg" alt="时间复杂度"></p>
<p>理想情况下，二叉查找树是一颗完全二叉树或满二叉树，这时插入、删除、查找的时间复杂度是多少呢？</p>
<p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？</p>
<p>第 K 层包含的节点个数就是 2^(K-1)。</p>
<p>对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L</p>
<p>如果节点个数是n，那么n满足这样一个关系：</p>
<pre><code>n &gt;= 1+2+4+8+...+2^(L-2)+1
n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)
</code></pre><p>借助等比数列的求和公式，我们可以计算出，L 的范围是 [log2(n+1), log2n +1]。完全二叉树的层数小于等于 log2n +1，也就是说，完全二叉树的高度小于等于 log2n。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>散列表的插入，删除，查找复杂度可以做到常量级O(1),二叉查找树的，插入，删除，查找操作时间复杂度才是O(logn)，因此为啥还要使用二叉查找树？</p>
<p>第一：散列表的数据是无序存储的，如果要输出有序数据，要先排序，而对于二叉查找树只需要中序遍历，就可以在O(n)的时间复杂度中，输出有序数据序列。</p>
<p>第二：散列表扩容耗时很多，而且遇到散列冲突，性能不稳定，尽管二叉查找树的性能不稳定，但在工程中我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p>
<p>第三：笼统的来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际查找速度可能不一定比O(logn)快，加上哈希函数的耗时，也不一定就比平航查找树的效率高。</p>
<p>第四：散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p>
<p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p>
<h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>今天我讲了二叉树高度的理论分析方法，给出了粗略的数量级。如何通过编程，求出一棵给定二叉树的确切高度呢？</p>
<pre><code>//递归求二叉树的深度
public int TreeDepth(TreeNode root) {
    int depth = 0;
    //如果root为null，返回depth = 0；
    if(root == null){
        return depth;
    }
    //否则进行递归，如果左子树深度比右子树深度大，最大深度就在左子树上加1;否则反之
    if(TreeDepth(root.left) &gt; TreeDepth(root.right)){
        depth = TreeDepth(root.left) + 1;
    }else{
        depth = TreeDepth(root.right) + 1;
    }
    return depth;
}
</code></pre>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="小六子的鱼 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="小六子的鱼 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/16/链表/" rel="next" title="链表">
                <i class="fa fa-chevron-left"></i> 链表
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/16/二分查找下/" rel="prev" title="二分查找">
                二分查找 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="小六子的鱼">
            
              <p class="site-author-name" itemprop="name">小六子的鱼</p>
              <p class="site-description motion-element" itemprop="description">某211大学研究生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://xiaodupi-zyq.github.io/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xiaoliuzizyq@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xiao-ya-ma-xiao-liu-zi/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neowyj.github.io/" title="Neowyj" target="_blank">Neowyj</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.arflow.cn/t/4" title="ARFlow" target="_blank">ARFlow</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://snailclimb.top/JavaGuide/#/?id=java" title="JavaGuide" target="_blank">JavaGuide</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树基础上：什么样的二叉树适合用数组来存储？"><span class="nav-number">1.</span> <span class="nav-text">二叉树基础上：什么样的二叉树适合用数组来存储？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#树（Tree）"><span class="nav-number">1.1.</span> <span class="nav-text">树（Tree）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树（Binary-Tree"><span class="nav-number">1.2.</span> <span class="nav-text">二叉树（Binary Tree)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何表示或者存储一颗二叉树？"><span class="nav-number">1.3.</span> <span class="nav-text">如何表示或者存储一颗二叉树？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#链式存储法"><span class="nav-number">1.3.1.</span> <span class="nav-text">链式存储法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序存储法"><span class="nav-number">1.3.2.</span> <span class="nav-text">顺序存储法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的遍历"><span class="nav-number">1.4.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇-amp-内容小结"><span class="nav-number">1.5.</span> <span class="nav-text">解答开篇&amp;内容小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课后思考"><span class="nav-number">1.6.</span> <span class="nav-text">课后思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？"><span class="nav-number">2.</span> <span class="nav-text">二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉查找树-（Binary-Search-Tree）"><span class="nav-number">2.1.</span> <span class="nav-text">二叉查找树 （Binary Search Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、二叉查找树的查找操作"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、二叉查找树的查找操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、二叉查找树的插入操作"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、二叉查找树的插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、二叉查找树的删除操作"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、二叉查找树的删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、二叉查找树的其他操作"><span class="nav-number">2.1.4.</span> <span class="nav-text">4、二叉查找树的其他操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#支持重复数据的二叉查找树"><span class="nav-number">2.2.</span> <span class="nav-text">支持重复数据的二叉查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉查找树的时间复杂度分析"><span class="nav-number">2.3.</span> <span class="nav-text">二叉查找树的时间复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答开篇"><span class="nav-number">2.4.</span> <span class="nav-text">解答开篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课后思考-1"><span class="nav-number">2.5.</span> <span class="nav-text">课后思考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小六子的鱼</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>

-->



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'xiaodupi-zyq',
            repo: 'xiaodupi-zyq.github.io',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: 'e1a77ed9b132282a57f403268aaa78d5f51a9be0',
            
                client_id: 'b54fdaa7dadc52682b4b'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    








  





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
