<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="小六子的鱼的个人博客" type="application/atom+xml">






<meta name="description" content="某211大学研究生">
<meta property="og:type" content="website">
<meta property="og:title" content="小六子的鱼的个人博客">
<meta property="og:url" content="https://xiaodupi-zyq.github.io/index.html">
<meta property="og:site_name" content="小六子的鱼的个人博客">
<meta property="og:description" content="某211大学研究生">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小六子的鱼的个人博客">
<meta name="twitter:description" content="某211大学研究生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaodupi-zyq.github.io/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
  <title>小六子的鱼的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/xiaodupi-zyq/xiaodupi-zyq.github.io"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_white_ffffff.png?resize=149%2C149" alt="Fork me on GitHub"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小六子的鱼的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">无穷的伟大,也是从“一”开始的</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/08/12/股票问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/12/股票问题/" itemprop="url">股票问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-12T09:56:21+08:00">
                2020-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>状态转移图：</p>
<p><img src="/2020/08/12/股票问题/状态转移图.png" alt="状态转移图"></p>
<pre><code>/**
* @Author: zyq-xiaoliuzi
* @Description:
* @Date: Created in 21:16 2020/8/11
* @Modified By:
*/

/**
* 首先定义状态:
*      dp[i][k][0] =&gt; 第i天在交易第k次时没有持有股票
*      dp[i][k][1] =&gt; 第i天在交易第k次时持有股票
* 理解状态转移方程
*      “更准确的说 k 的次数可以是买了k次，下面的交易k次用买了k次去理解就会好理解了，买才是一次交易，卖只是完成这次交易”
*
*      dp[i][k][0] 该状态只能由 《前一天 已经交易k次 没有持有股票在今天保存不变（dp[i - 1][k][0]）》
*      和 《 前一天 已经交易k次 持有股票在今天出售（dp[i - 1][k][1] + prices[i]） 得来;
*      ====&gt; dp[i][k][0] = Max(dp[i - 1][k][0],dp[i - 1][k][1] + prices[i]);
*
*      dp[i][k][1] 该状态只能由 《前一天 已经交易k次 持有股票在今天保存不变（dp[i - 1][k][1]）》
*      和 《 前一天 已经交易k - 1次 没有持有股票在今天买入（dp[i - 1][k - 1][0] - prices[i]） 得来;
*      ====&gt; dp[i][k][1] = Max(dp[i - 1][k][1],dp[i - 1][k - 1][0] - prices[i]);
*
* 初始值；
*      dp[-1][k][0] = 0
*      解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
*      dp[-1][k][1] = -infinity
*      解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
*      dp[i][0][0] = 0
*      解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
*      dp[i][0][1] = -infinity
*      解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
*
*      如果无法理解-1，可以直接定义
*          dp[0][k][0] = 0，在 i = 0时，也就是第一天，可以做交易的情况下，没有持股，所以收益为 0；
*          dp[0][k][1] = -prices[0], 在 i = 0时，也就是第一天，可以做交易的情况下，持股，所以收益为 -prices[0]；
*      再来理解 k = 0，此时说明无法做交易，最大交易为 0 次，所有不管是到第几天，此时收益都是0；
*          dp[i][0][0] = 0;
*          dp[i][0][1] = -infinity
*
*/
</code></pre><p><strong>多种股票问题；</strong></p>
<p><strong>1. 买卖一次</strong><br><strong>2. 买卖无限次</strong><br><strong>3. 买卖两次</strong><br><strong>4. 买卖k次</strong><br><strong>5. 买卖无限次，含一天冷冻期</strong><br><strong>6. 买卖无限次，含费率</strong></p>
<pre><code>/**
 * 只能买卖一次，获取最大值，更新最小值，以及更新获利的最大值，最后返回
 * @param prices
 * @return
 */
public int maxProfit1(int[] prices) {
    /**
     *
     int min = Integer.MAX_VALUE;
     int money = 0;
     int len = prices.length;
     for(int i = 0; i &lt; len; i++){
     if(prices[i] &lt; min){
     min = prices[i];
     }
     if(prices[i] - min &gt; money){
     money = prices[i] - min;
     }
     }
     return money;
     **/

    -------------------------------------------------------------------------------------

    //dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i])
    //dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0] - prices[i])
    //k = 1;
    //初始化
    int len = prices.length;
    if(len &lt; 2){
        return 0;
    }
    int[][] dp = new int[len][2];
    dp[0][0] = 0;
    dp[0][1] =  -prices[0];
    for(int i = 1; i &lt; len; i++){
        dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i]);
        //  k - 1 = 0,所以dp[i-1][k-1][0] - prices[i] = dp[i-1][0][0] = 0;
        dp[i][1] = Math.max(dp[i - 1][1],-prices[i]);
    }
    return dp[len - 1][0];
}
</code></pre><hr>
<pre><code>/**
 * 可以买卖多次，但是买卖之前必须售出，获取最大值，找到峰值和峰谷，两个值相减即可
 * @param prices
 * @return
 */
public int maxProfit2(int[] prices) {
    /**
     int max = 0;
     int start = 0;
     int len = prices.length;
     int end = len - 1;
     int i = 0;
     while(i &lt; len - 1){
     //注意逻辑表达式的截断效应
     while(i &lt; len - 1 &amp;&amp; prices[i] &gt;= prices[i + 1]){
     i++;
     }
     start = i;
     while(i &lt; len - 1 &amp;&amp; prices[i] &lt; prices[i + 1]){
     i++;
     }
     end = i;
     max += (prices[end] - prices[start]);
     }
     return max;
     **/

    -------------------------------------------------------------------------------------

    int len = prices.length;
    if (len &lt; 2){
        return 0;
    }
    int[][] dp = new int[len][2];
    /**
     dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i])
     dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0] - prices[i])
     k = inf，所以k == k-1，原始公式简化为
     dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i])
     dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k][0] - prices[i])
     同样都是k，k就没有用途了，可以直接省略了
     dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
     dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
     **/
    //初始化
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for(int i = 1; i &lt; len; i++){
        dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);
    }
    return dp[len - 1][0];

}
</code></pre><hr>
<pre><code>/**
 * 可以交易两次，最后得到最大收益
 * @param prices
 * @return
 */
public int maxProfit3(int[] prices) {
    /**
     int len = prices.length;
     if(len &lt; 2){
     return 0;
     }

     int[][] dp = new int[len][5];
     /**根据状态转移图来看一共有五种状态，什么都不操作，买第一次，卖第一次，买第二次，卖第二次，且最大值出现在第一，三，五状态中；
     * 初始化，对于第一天来说，什么都不操作，获益是0，买第一次获益是 -prices[0]，在第一天中，后面三者状态不会出现所以后面三者都是MIN_VALUE
     * 初始化可以写成如下
     *
     dp[0][0] = 0;
     dp[0][1] = -prices[0];
     dp[0][2] = Integer.MIN_VALUE;
     dp[0][3] = Integer.MIN_VALUE;
     dp[0][4] = Integer.MIN_VALUE;
     for(int i = 1; i &lt; len; i++){
     //每种状态都只有当前状态不操作，和昨天前一种状态在今天发生了操作得来的
     dp[i][0] = 0;
     dp[i][1] = Math.max(dp[i - 1][1],dp[i][0] - prices[i]);
     dp[i][2] = Math.max(dp[i - 1][2],dp[i][1] + prices[i]);
     dp[i][3] = Math.max(dp[i - 1][3],dp[i][2] - prices[i]);
     dp[i][4] = Math.max(dp[i - 1][4],dp[i][3] + prices[i]);
     }
     return Math.max(Math.max(dp[len - 1][0],dp[len - 1][2]),dp[len - 1][4]);
     **/

    -------------------------------------------------------------------------------------

    int len = prices.length;
    if(len &lt; 2){
        return 0;
    }
    /**
     * dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + price[i])
     * dp[i][k][0] = max(dp[i-1][k][1],dp[i-1][k-1][0] - price[i])
     * k = 2;
     */
    //初始化
    int[][][] dp = new int[len][2 + 1][2];

    for(int i = 0; i &lt; len; i++){
        for(int j = 0; j &lt;= 2; j++){
            if(i == 0){
                dp[i][j][0] = 0;
                dp[i][j][1] = -prices[i];
                continue;
            }
            if(j == 0){
                dp[i][j][0] = 0;
                dp[i][j][1] = Integer.MIN_VALUE;
                continue;
            }
            dp[i][j][0] = Math.max(dp[i - 1][j][0],dp[i - 1][j][1] + prices[i]);
            dp[i][j][1] = Math.max(dp[i - 1][j][1],dp[i - 1][j - 1][0] - prices[i]);
        }
    }
    return dp[len - 1][2][0];
}
</code></pre><hr>
<pre><code>/**
 * 最多交易k次，每天只能买卖一次，所以如果交易次数k &gt; n/2则最后等于是无限制的买卖
 * @param k
 * @param prices
 * @return
 */
public int maxProfit4(int k, int[] prices) {
    int len = prices.length;
    if(len &lt; 2){
        return 0;
    }

    if(k &gt; len / 2){
        /**
         * 无限制买卖，
         */
        int[][] dp = new int[len][2];
        for(int i = 0; i &lt; len; i++){
            if(i == 0){
                dp[i][0] = 0;
                dp[i][1] = 0 - prices[0];
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);
        }
        return dp[len-1][0];
    }else{
        int[][][] dp = new int[len][k + 1][2];

        /**
         * 初始化
         * 第一天，无法交易，没有持有股票 dp[0][0][0] = 0;
         * 第一天，无法交易，不允许持有股票，dp[0][0][1] = -inf;//不可能出现这种情况
         * 第一天，可以交易(k &gt; 0),没有持有股票，dp[0][k][0] = 0;//没有股票收益为0；
         * 第一天，可以交易(k &gt; 0),持有股票，dp[0][k][1] = -price[0];//没有股票收益为0；
         */
        for(int i = 0; i &lt; len;i++){
            for(int j = 0; j &lt;= k; j++){
                if(i == 0){
                    dp[i][j][0] = 0;
                    dp[i][j][1] = -prices[0];
                    continue;
                }
                if(j == 0){
                    dp[i][j][0] = 0;
                    dp[i][j][1] = Integer.MIN_VALUE;
                    continue;
                }
                dp[i][j][0] = Math.max(dp[i - 1][j][0],dp[i - 1][j][1] + prices[i]);
                dp[i][j][1] = Math.max(dp[i - 1][j][1],dp[i - 1][j - 1][0] - prices[i]);
            }
        }
        return dp[len-1][k][0];
    }
}
</code></pre><hr>
<pre><code>/**
 * 无限次卖出，加一天冷冻期
 * @param prices
 * @return
 */
public int maxProfit(int[] prices) {
    int len = prices.length;
    if(len &lt; 2){
        return 0;
    }
    /**
     * dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i])
     * dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0] - prices[i])
     * k = inf,所以 k-1 == k
     * dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
     * dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
     * 冷冻期，所以
     * dp[i][1] = max(dp[i-1][1],dp[i-2][0] - prices[i])
     */
    //初始化
    int[][] dp = new int[len][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    int dp_pre = 0;
    for(int i = 1; i &lt; len; i++){
        dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1],dp_pre - prices[i]);
        dp_pre = dp[i - 1][0];
    }
    return dp[len - 1][0];
}
</code></pre><hr>
<pre><code>/**
 * 无限次买，有费率
 * @param prices
 * @param fee
 * @return
 */
public int maxProfit(int[] prices, int fee) {
    int len = prices.length;
    if(len &lt; 2){
        return 0;
    }
    /**
     * dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i])
     * dp[i][k][1] = max(dp[i-1][k][1],dp[i-1][k-1][0] - prices[i])
     * k = inf,所以 k-1 == k
     * dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
     * dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
     * 有费率，所以
     * dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i] - fee)
     */
    //初始化
    int[][] dp = new int[len][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for(int i = 1; i &lt; len; i++){
        dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i] - fee);
        dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]);
    }
    return dp[len - 1][0];
}
</code></pre><p>}</p>
<p>参考文章：<br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/索引与数据库相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/索引与数据库相关/" itemprop="url">索引与数据库相关：B+树，索引，Redis实战相关总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T22:07:51+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="B-树，索引，Redis实战相关总结"><a href="#B-树，索引，Redis实战相关总结" class="headerlink" title="B+树，索引，Redis实战相关总结"></a>B+树，索引，Redis实战相关总结</h1><h2 id="B-树，MySQL数据库索引的相关实现"><a href="#B-树，MySQL数据库索引的相关实现" class="headerlink" title="B+树，MySQL数据库索引的相关实现"></a>B+树，MySQL数据库索引的相关实现</h2><p>数据库索引是如何实现的呢？底层使用的是怎样的数据结构和算法呢？</p>
<h3 id="1、解决问题的前提是定义清楚问题"><a href="#1、解决问题的前提是定义清楚问题" class="headerlink" title="1、解决问题的前提是定义清楚问题"></a>1、解决问题的前提是定义清楚问题</h3><p>需求：简单来说就是两点：<br>根据某个值来查找数据，比如select <em> from user where id = 1234;<br>根据区间值来查找某些数据，比如select </em> from user where id &gt; 1234 and id &lt; 2345;</p>
<p>除了这些功能性的需求，再者就是要兼顾效率和空间；</p>
<h3 id="2、尝试用学过的数据结构来解决这个问题"><a href="#2、尝试用学过的数据结构来解决这个问题" class="headerlink" title="2、尝试用学过的数据结构来解决这个问题"></a>2、尝试用学过的数据结构来解决这个问题</h3><p>支持快速查询插入操作的动态结构，有散列表，跳表，红黑树；</p>
<p>散列表：插入查询时间复杂度都是O(1),但是散列表不支持按区间快速查找；</p>
<p>平衡二叉查找树：尽管性能很高，时间复杂度是O(logn)，对树进行中序排列之后也可以得到一个从小到大的数据序列，但是这仍然不能按照区间快速查找；</p>
<p>跳表：跳表是在链表基础上加了很多层索引构成的，他支持快速查找，插入删除数据，时间复杂度是O(logn),并且跳表是支持快速按照区间查找的，只需要找到起点，然后往后遍历即可；</p>
<p><img src="/2020/06/16/索引与数据库相关/跳表.jpg" alt="跳表"></p>
<p>数据库索引所用到的数据结构跟跳表非常相似，叫做B+树；</p>
<h3 id="3、改造二叉树解决问题"><a href="#3、改造二叉树解决问题" class="headerlink" title="3、改造二叉树解决问题"></a>3、改造二叉树解决问题</h3><p>对二叉树进行改造，树中的节点并不只是数据本身，而是作为索引，除此之外我们把每个叶子节点串在一起，形成一个链表；<br>（所谓跳表就是一层一层的链表，通俗讲链表+链表；所谓B+树就是树+链表，上面是树(二叉查找树），下面是链表）</p>
<p><img src="/2020/06/16/索引与数据库相关/改造二叉树.jpg" alt="改造二叉树"></p>
<p>改造之后的按区间查找：</p>
<p><img src="/2020/06/16/索引与数据库相关/区间查找.jpg" alt="区间查找"></p>
<p>如果成千万上亿的数据构建索引，如果索引都存储在内存中，尽管内存访问的速度恒快但是占用内存很大；比如一亿数据构建二叉树索引，就要包含大约一亿个节点，每个节点16字节，就需要1GB的内存空间；如果更大的表呢？</p>
<p>借助时间换空间的思路，将索引存储在磁盘中的话，尽管减少了内存的消耗，但是在数据查找的过程中需要读取磁盘的索引，因此数据查询效率就会相应的降低很多；</p>
<p>因此每个节点的读取或者访问，都对应一次磁盘操作，树的高度就等于磁盘操作次数；<br>所以我们继续改造，如果我们不使用二叉树索引，改成m叉树，高度就会变小，效率就会变高；</p>
<p><img src="/2020/06/16/索引与数据库相关/二叉树.jpg" alt="二叉树"><br><img src="/2020/06/16/索引与数据库相关/五叉树.jpg" alt="五叉树"></p>
<p>m叉树实现的B+树索引，代码实现出来就是：假设数据库存储的int类型的数据；</p>
<p>对于相同个数的数据构建m叉树索引，m越大，树的高度就越小，那么m是不是越大越好呢？</p>
<p>不管是内存还是磁盘，操作系统都是按页进行读取的，我们选择m的大小时候，要尽量让每一个节点的大小等于一个页的大小，读取一个节点只需要一次IO操作；</p>
<p><img src="/2020/06/16/索引与数据库相关/Bplus.jpg" alt="Bplus"></p>
<p>对于一个B+树来说，m值是根据页的大小事先计算好的，也就是说，每个节点最多只能有m个子节点。在数据库的写入数据过程中，这样就有可能使索引中某些节点的子节点个数超过m，这个节点的大小就超过了一个页的大小，读取这样的节点就会导致多次IO操作，如何解决这个问题呢？</p>
<p>实际上处理思路不复杂，我只需将这个节点分裂为两个节点，但是节点分裂之后，其上层的父节点的子节点个数就可能超过m个，不过这个没关系，我们用同样的方法，将父节点也分裂为两个节点，这种级联的反应会从下往上，一直影响到根节点。这个分裂过程如下图所示</p>
<p><img src="/2020/06/16/索引与数据库相关/节点分裂.jpg" alt="节点分裂"></p>
<p>因为要时刻保持B+树索引是一个m叉树，所以索引的存在会导致数据库写入数据降低，实际上，不光下入数据会变慢，删除数据也会变慢；</p>
<p>我们再删除过程中，也要更新索引节点，这个处理思路类似于跳表中删除数据的处理思路。频繁的数据删除必然会导致某些节点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率；</p>
<p>我们可以设置一个阈值，在B+树中，这个阈值是m/2。如果某个节点的子节点的个数小于m/2，我们就把他和相邻的兄弟节点合并，不过合并之后的节点个数可能会超过m，我们可以借助插入数据的处理方法，在分裂节点；</p>
<p><img src="/2020/06/16/索引与数据库相关/节点删除.jpg" alt="节点删除"></p>
<h3 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h3><p>B+树的特点：</p>
<ol>
<li>每个节点中子节点的个数不能超过m，也不能小于m/2;</li>
<li>根节点的子节点个数可以不超过m/2，这是一个例外；</li>
<li>m叉树只存储索引，并不真正的存储数据，这个有点类似跳表；</li>
<li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li>
<li>一般情况下，根节点会被存储在内存中，其他节点存储在磁盘中；</li>
</ol>
<p>B树实际上就是B-树；</p>
<ol>
<li>B+树中的节点不存储数据，只是索引，而B树中的节点存储数据；</li>
<li>B树中的叶子节点并不需要链表来串联；</li>
</ol>
<p>其实 B树只是一个节点的子节点不能小于m/2的m叉树；</p>
<h2 id="索引：如何在海量数据中快速查找到某个数据"><a href="#索引：如何在海量数据中快速查找到某个数据" class="headerlink" title="索引：如何在海量数据中快速查找到某个数据"></a>索引：如何在海量数据中快速查找到某个数据</h2><p>MySQL底层依赖的是一个B+树这种数据结构，类似Redis这样的k-v数据库中索引，又是什么呢？</p>
<h3 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h3><p>如何节省存储空间，如何提高数据增删改查的执行效率，这样的问题就成了设计的重点；这些系统的实现都离不开索引；</p>
<p>索引换句话来说就好像是书记的目录；</p>
<h3 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h3><h4 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h4><ol>
<li>数据是格式化数据还是非格式化数据：格式化数据就是MySQL的数据，非格式化的数据就是类似于网页这样的数据，需要先做预处理，提取查询关键词；</li>
<li>数据是静态的还是动态的：静态数据不会有数据的增加，删除，更新操作，只需要考虑查询效率就可以；动态数据就要考虑查询效率，还要考虑支持动态的数据集合的索引；</li>
<li>索引存储在内存还是硬盘：主要是存储的位置不同访问的效率不同；</li>
<li>单值查找还是区间查找：</li>
<li>单关键词查找还是多关键词组合查找：</li>
</ol>
<h3 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h3><ol>
<li>不管是存储在内存中还是磁盘中，索引堆空间的消耗不能过大。</li>
<li>在考虑索引查询效率的同时，我们还要考虑索引维护成本；</li>
</ol>
<h3 id="构建索引的常见数据结构有哪些"><a href="#构建索引的常见数据结构有哪些" class="headerlink" title="构建索引的常见数据结构有哪些"></a>构建索引的常见数据结构有哪些</h3><p>散列表：增删查改性能都比较好，时间复杂度是O(1),用在一些键值数据库中，比如Redis，Memcache,这类索引一般存在于内存中；</p>
<p>红黑树：一种常用的平衡查找二叉树，数据插入，删除，查找的时间复杂度是O(logn)，也非常适合构建内存索引，Ext文件系统中，对磁盘块的索引就是红黑树；</p>
<p>B+树，比起红黑树来讲，更适合构建存储在磁盘中的索引，B+树是一个多叉树，所以对相同个数的数据构建索引，B+树的高度要低于红黑树，借助索引来查询数据的时候，读取B+树索引，需要的磁盘IO次数会更少。大部分关系型数据库的索引，比如MySQL，都是用B+树来实现的；</p>
<p>跳表：也支持快速的添加，删除，查找数据，我们通过灵活调整索引节点的个数和数据个数之间的比例，可以很好的平衡索引对内存的消耗及其查询效率，Redis中的有序集合，就是用跳表来构建的；</p>
<p>布隆过滤器，有一定的判错率，但是我们要规避他的短处，发挥长处，如果布隆过滤器判断不存在的数据就一定不存在，因此查询数据之前进行布隆过滤器，如果不存在就不用访问磁盘了；</p>
<h2 id="剖析Redis常用数据类型对应的数据结构"><a href="#剖析Redis常用数据类型对应的数据结构" class="headerlink" title="剖析Redis常用数据类型对应的数据结构"></a>剖析Redis常用数据类型对应的数据结构</h2><p>经典数据库Redis中常用的数据类型，底层都是用那些数据结构实现的呢？</p>
<h3 id="Redis数据库介绍："><a href="#Redis数据库介绍：" class="headerlink" title="Redis数据库介绍："></a>Redis数据库介绍：</h3><p>一种键值对数据库，非关系型数据库；<br>redis主要是是作为内存数据库使用，也就是说，数据是存储在内存中的，尽管他经常被用作内存数据库，但是他也支持数据存在在硬盘上；</p>
<p>Redis中键的数据类型是字符串，值的数据类型就很多，主要有，字符串，列表，字典，集合有序集合；</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表支持存储一组数据，这种类型的两种实现方法，一种是压缩列表，一种是双向循环列表；</p>
<p>采用压缩列表的条件是：</p>
<ol>
<li>列表中保存的单个数据（也有可能是字符串）小于64字节；</li>
<li>列表中数据个数少于512个；</li>
</ol>
<p>而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。具体的存储结构也非常简单：</p>
<p><img src="/2020/06/16/索引与数据库相关/压缩列表.jpg" alt="压缩列表"></p>
<p>压缩列表将不再像数组一样使用统一的大小来存储数据，而是需要多少是多少，相互连接起来；<br>这样比较节省内存，另一方面可以支持不同类型数据的存储，而且因为数据存储在一片连续的内存空间中，通过键来获取值我列表类型的数据，读取效率也非常高。</p>
<p>当列表中存储的数据量非常大的时候，也就是不能同时满足刚刚讲的两个条件时候，列表就要通过双向循环链表来实现了；</p>
<pre><code>typedef struct listnode {
    struct listnode *prev;
    struct listnode *next;
    void *value;
} listNode;

typedef struct list{
    listNode *head;
    listNode *tail;
    unsigned long len;
} list;
</code></pre><h3 id="字典（hash"><a href="#字典（hash" class="headerlink" title="字典（hash)"></a>字典（hash)</h3><p>字典类型用来存储一组数据对，每个数据对又包含键值两部分。字典类型也有两种实现方式，一种是我们刚刚讲到的压缩列表，一种是散列表；</p>
<p>同样当存储的数据量比较小的情况下，Redis才使用压缩列表来实现字典类型；</p>
<ol>
<li>字典中保存的键值大小都要小于64字节；</li>
<li>字典中键值的个数要小于512。</li>
</ol>
<p>当不能满足上述条件的时候，Redis使用散列表来实现字典类型。Redis使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容；</p>
<p>当装载因子大于1的时候，Redis会触发扩容，将散列表扩大到2倍；<br>当装载因子小于0.1的时候，Redis会触发缩容，缩小到字典数据个数的大约2倍；</p>
<p>扩容缩容需要大量的数据搬移和哈希值的重新计算，比较耗时，针对这个问题，Redis使用的是渐进式扩容缩容机制，避免一次性的数据搬移导致的服务停顿；</p>
<h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>集合中数据类型用来存储一组不重复的数据，两种实现方法一种基于有序数组，一种基于散列表；</p>
<p>如果满足下面两个条件Redis使用有序数组，实现集合中数据类型；</p>
<ol>
<li>存储的数据都是整数；</li>
<li>存储的数据元素个数不超过512个；</li>
</ol>
<p>否则Redis使用散列表来存储集合中数据；</p>
<h3 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h3><p>有序集合，它用来存储一组数据，并且每个数据会附带一个得分，通过得分的大小，我们将数据组织成跳表这样数据结构，以支持，快速的按照的得分值，得分区间获取数据；</p>
<p>有序集合不仅仅只有跳表这一种实现方式，当数据量比较小的时候Redis会用压缩列表来实现有序集合，具体点说就是，使用压缩列表来实现有序集合的前提：</p>
<ol>
<li>所有数据的大小都要小于64字节；</li>
<li>元素要小于128个；</li>
</ol>
<h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Redis 遇到的这个问题并不特殊，很多场景中都会遇到。我们把它叫作数据结构的持久化问题，或者对象的持久化问题。这里的“持久化”，你可以笼统地可以理解为“存储到磁盘”。</p>
<p>第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。</p>
<p>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/动态规划理论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/动态规划理论/" itemprop="url">动态规划中：理论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:59:01+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"><a href="#动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题" class="headerlink" title="动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"></a>动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</h1><p>什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是怎样的？贪心、分治、回溯、动态规划这四种算法思想的区别和联系？</p>
<h2 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h2><p>什么样的问题适合用动态规划来解决呢？<br>什么是<strong>一个模型</strong>？它指的是动态规划适合解决的问题的模型，这个模型可以称之为“<strong>多阶段决策最优解模型</strong>”；</p>
<p>一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
<p>什么是<strong>三个特征</strong>，分别是<strong>最优子结构、无后效性和重复子问题</strong></p>
<h3 id="1、最优子问题"><a href="#1、最优子问题" class="headerlink" title="1、最优子问题"></a>1、最优子问题</h3><p>最优子结构是指，问题的最优解包含子问题的最优解。反过来我们可以通过子问题的最优解，推导出来问题的最优解。通俗的理解就是后面阶段的状态可以通过前面阶段的状态推导出来；</p>
<h3 id="2、无后效性"><a href="#2、无后效性" class="headerlink" title="2、无后效性"></a>2、无后效性</h3><p>无后效性两层含义，第一层含义是，在推导后面阶段的问题时，我们只关心前面阶段的状态值，不关系这个状态是怎么一步一步推导出来的，第二层含义就是，某个阶段状态一旦确定，就不受之后阶段的决策影响；</p>
<h3 id="3、重复子问题"><a href="#3、重复子问题" class="headerlink" title="3、重复子问题"></a>3、重复子问题</h3><p>简单来说就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态；</p>
<h2 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h2><p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p>
<p><img src="/2020/06/16/动态规划理论/棋盘最短路径.jpg" alt="棋盘最短路径"></p>
<p>从(0,0)走到(n-1, n-1)，总共要走 2<em>(n-1) 步，也就对应着 2</em>(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p>
<p>我们把状态定义为min_dist(i,j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。（多阶段决策最优解，符合动态模型的问题）；</p>
<p><img src="/2020/06/16/动态规划理论/棋盘最短路径阶段分析.jpg" alt="棋盘最短路径阶段分析"></p>
<p>这时候再看问题是否符合三个特征：</p>
<p>使用回溯法，画出递归图之后，会发现有重复节点，这说明到达节点对应的位置，有多种路线，说明这个问题存在重复子问题；</p>
<p><img src="/2020/06/16/动态规划理论/棋盘最短路径重复子问题.jpg" alt="棋盘最短路径重复子问题"></p>
<p>走到(i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态；这就是所谓的前面阶段的状态确定下来之后，不会被后面阶段的决策所改变，这就是无后效性；</p>
<p>上述的我们只能由两个位置到达(i,j)，所以min_dist(i,j)必定是从min_dist(i-1,j)和min_dist(i,j-1)推导过来，这就说明这个问题符合最优子结构；</p>
<pre><code>min_dist(i,j) = w[i][j] + min(min_dist(i-1,j),min_dist(i,j-1));
</code></pre><h2 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h2><p>状态转移表法 和 状态转移方程法；</p>
<h3 id="1、状态转移表法"><a href="#1、状态转移表法" class="headerlink" title="1、状态转移表法"></a>1、状态转移表法</h3><p>我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决；</p>
<p>找到重复子问题之后，两种思路，第一种是：<strong>回溯算法加备忘录的方法</strong>，避免重复子问题，从执行效率上这种方法和动态规划思路已经没有差别了，第二种是<strong>状态转移表法；</strong></p>
<p>状态转移表法，先画出一个状态表，状态表一般都是二维的，可以想象成二维数组，其中每个状态表示三个量，行列值以及数组值；决策的过程就是填充状态表的过程；</p>
<pre><code>private int minDist = Integer.MIN_VALUE;

/**
 * 回溯算法求最短距离
 * @param i 第i行
 * @param j 第j列
 * @param dist 到此的最短距离
 * @param w 棋盘
 * @param n 最后目的
 */
public void minDistBT(int i,int j,int dist,int[][] w,int n){
    if(i == n &amp;&amp; j == n){
        if(dist &lt; minDist){
            minDist = dist;
            return;
        }
    }
    if(i &lt; n){//往下走
        minDistBT(i + 1,j,dist+w[i][j],w,n);
    }
    if(j &lt; n){//往右走
        minDistBT(i,j+1,dist+w[i][j],w,n);
    }
}
</code></pre><p>上述代码画成递归树之后，一个状态包括三个量(i,j,dist),其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。</p>
<p>图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了。</p>
<p><img src="/2020/06/16/动态规划理论/棋盘最短路径递归树.jpg" alt="棋盘最短路径递归树"></p>
<p>使用动态规划，我们先画一个二维状态，图表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。</p>
<p><img src="/2020/06/16/动态规划理论/棋盘最短路径状态转移图1.jpg" alt="棋盘最短路径状态转移图1"></p>
<p><img src="/2020/06/16/动态规划理论/棋盘最短路径状态转移图2.jpg" alt="棋盘最短路径状态转移图2"></p>
<p>将上述过程中的填表过程翻译成代码就是：</p>
<pre><code>/**
 * 动态规划求距离
 * @param matrix 棋盘
 * @param n 要求位置
 * @return
 */
public int minDistDP(int[][] matrix,int n){
    int[][] states = new int[n][n];
    int sum = 0;
    for(int j = 0; j &lt; n; j++){
        sum += matrix[0][j];
        states[0][j] = sum;
    }
    sum = 0;
    for(int i = 0; i &lt; n; i++){
        sum += matrix[i][0];
        states[i][0] = sum;
    }
    for(int i = 1; i &lt; n; i++){
        for(int j = 1; j &lt; n; j++){
            states[i][j] = matrix[i][j] + Math.min(states[i][j - 1],states[i - 1][j]);
        }
    }
    return states[n-1][n-1];
}
</code></pre><h3 id="2、状态转移方程法"><a href="#2、状态转移方程法" class="headerlink" title="2、状态转移方程法"></a>2、状态转移方程法</h3><p>上述转移方程法有点类似递归的方法，个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。</p>
<pre><code>min_dist(i,j) = w[i][j] + min(min_dist(i-1,j),min_dist(i,j-1));
</code></pre><p>状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单</p>
<pre><code>private int[][] matrix = {{1,3,5,9},{2,1,3,4},{5,2,6,7},{6,8,4,3}};
private int n = 4;
private int[][] mem = new int[n][n];

public int minDistDP1(int i,int j){
    if(i == 0 &amp;&amp; j == 0){
        return matrix[0][0];
    }
    if(mem[i][j] &gt; 0) return mem[i][j];
    int minLeft = Integer.MAX_VALUE; //便于比较,使用最大值
    if(j - 1 &gt;= 0){
        minLeft = minDistDP1(i,j-1);
    }
    int minUp = Integer.MAX_VALUE;
    if(i - 1 &gt;= 0){
        minUp = minDistDP1(i-1,j);
    }
    int currMinDist = matrix[i][j] + Math.min(minLeft,minUp);
    mem[i][j] = currMinDist;
    return currMinDist;
}
</code></pre><p>不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。</p>
<h2 id="四种算法思想比较"><a href="#四种算法思想比较" class="headerlink" title="四种算法思想比较"></a>四种算法思想比较</h2><p>贪心，回溯，动态规划可以归为一类，而分治单独一类。<br>前三个算法解决问题的模型可以抽象成今天所讲的多阶段决策最优解模型，而分治算法解决的问题尽管大部分是最优解问题，大部分都不能抽象层多阶段决策模型；</p>
<p>回溯算法是个万金油，基本上贪心算法和动态规划能解决的问题我们都可以回溯算法解决，回溯算法相当于穷举算法，穷举所有的情况，对比得到最优解，大规模数据量的时候，回溯算法解决的执行效率太低；</p>
<p>尽管动态规划比回溯算法高效，但是不是所有问题都可以用动态规划解决。能用动态规划的需要满足三个特征，最优子结构，无后效性和重复子问题，再重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p>
<p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。<br>贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择；</p>
<h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>一个模型”指的是，问题可以抽象成分阶段决策最优解模型。“三个特征”指的是最优子结构、无后效性和重复子问题。</p>
<p>状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。</strong></p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>硬币找零问题，我们在贪心算法那一节中讲过一次。我们今天来看一个新的硬币找零问题。假设我们有几种不同币值的硬币 v1，v2，……，vn（单位是元）。如果我们要支付 w 元，求最少需要多少个硬币。比如，我们有 3 种不同的硬币，1 元、3 元、5 元，我们要支付 9 元，最少需要 3 个硬币（3 个 3 元的硬币）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/动态规划实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/动态规划实战/" itemprop="url">动态规划下：实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:59:01+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态规划实战：如何实现搜索引擎中的拼写纠错功能？"><a href="#动态规划实战：如何实现搜索引擎中的拼写纠错功能？" class="headerlink" title="动态规划实战：如何实现搜索引擎中的拼写纠错功能？"></a>动态规划实战：如何实现搜索引擎中的拼写纠错功能？</h1><p>Trie树那一节讲述的是实现搜索引擎的关键词提示，但是很多时候搜索的时候，会输错单词，搜索引擎会非常智能的检测出你的拼写错误，并且用对应的正确单词来进行搜索；</p>
<h2 id="如何量化两个字符的相似度"><a href="#如何量化两个字符的相似度" class="headerlink" title="如何量化两个字符的相似度"></a>如何量化两个字符的相似度</h2><p>编辑距离（Edit distance）；</p>
<p>编辑距离就是将一个字符串转化成另一个字符串需要的最小编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p>
<p>两种计算方式：<strong>莱文斯坦距离和最长公共子串长度</strong>，莱文斯坦距离允许增加，删除，替换字符三个操作，最长子串长度只允许增加，删除字符这两个编辑操作；</p>
<p>莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小</p>
<p>两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。</p>
<p><img src="/2020/06/16/动态规划实战/编辑距离.jpg" alt="编辑距离"></p>
<h2 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h2><p>这个问题是把一个字符串变成另一字符串，需要的最少编辑次数，整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每一个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话如何处理，所以这个问题是符合多阶段决策最优模型的；</p>
<p>先用最简单的回溯算法，如何解决呢？</p>
<p>回溯是一个递归处理的过程，如果a[i]与b[j]匹配，我们考察a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：</p>
<ol>
<li>可以删除a[i],然后递归考察a[i+1]和b[j];</li>
<li>可以删除b[j],然后递归考察a[i]和b[j+1];</li>
<li>可以在a[i]之前添加一个与b[j]相同的字符，继续考察a[i]和b[j+1];</li>
<li>可以在b[j]之前添加一个与a[i]相同的字符，继续考察a[i+1]和b[j];</li>
<li>可以将a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。</li>
</ol>
<p>所以实现的代码是：</p>
<pre><code>/**
 * 回溯算法求编辑距离
 * @param i
 * @param j
 * @param edist
 */
public void lwstBT(int i,int j,int edist){
    if(i == n || j == m){
        if(i &lt; n) {
            edist += (n-i);
        }
        if(j &lt; m) {
            edist += (m - j);
        }
        if(edist &lt; minDist) {
            minDist = edist;
            return;
        }
    }
    if(a[i] == b[j]){
        lwstBT(i+1,j+i,edist);
    }else{
        lwstBT(i+1,j,edist+1);// 删除a[i]或者b[j]前添加一个字符
        lwstBT(i,j+1,edist+1);// 删除b[j]或者a[i]前添加一个字符
        lwstBT(i+1,j+1,edist+1);// 将a[i]和b[j]替换为相同字符
    }
}
</code></pre><p>然后画出相应的递归树为：</p>
<p><img src="/2020/06/16/动态规划实战/编辑距离递归树.jpg" alt="编辑距离递归树"></p>
<p>在节点中，每个节点代表一个状态，状态包含三个变量(i,j,edist)，其中edist表示处理到a[i]和b[j]时，已经执行的编辑操作的次数。</p>
<p>在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p>
<p><img src="/2020/06/16/动态规划实战/编辑距离状态转移方程.jpg" alt="编辑距离状态转移方程"></p>
<pre><code>如果a[i] != b[j],那么min_dist(i,j)等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)

如果：a[i] == b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))
</code></pre><p>按照上述转移方程画出相应的转移状态图：<br><img src="/2020/06/16/动态规划实战/编辑距离状态转移表.jpg" alt="编辑距离状态转移表"></p>
<pre><code>/**
 * 动态规划求编辑距离
 * @param a
 * @param n
 * @param b
 * @param m
 * @return
 */
public int lwstDP(char[] a,int n,char[] b,int m){
    int[][] minDist = new int[n][m];
    for(int j = 0; j &lt; m; j++){
        if(a[0] == b[j]){
            minDist[0][j] = j;
        }else if(j != 0){
            minDist[0][j] = minDist[0][j-1] + 1;
        }else {
            minDist[0][j] = 1;
        }
    }
    for(int i = 0; i &lt; n; i++){
        if(a[i] == b[0]){
            minDist[i][0] = i;
        }else if(i != 0) {
            minDist[i][0] = minDist[i-1][0] + 1;
        }else{
            minDist[i][0] = 1;
        }
    }
    for(int i = 1; i &lt; n; i++){
        for(int j = 1;j &lt; m; j++){
            if(a[i] == b[j]) {
                minDist[i][j] = min(minDist[i-1][j] + 1,minDist[i][j-1]+1, minDist[i-1][j-1]);
            }else {
                minDist[i][j] = min( minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);
            }
        }
    }
    return minDist[n-1][m-1];
}
private int min(int x, int y, int z) { 
    int minv = Integer.MAX_VALUE; 
    if (x &lt; minv) minv = x; 
    if (y &lt; minv) minv = y; 
    if (z &lt; minv) minv = z; 
    return minv;
}
</code></pre><p>当我们拿到一个问题的时候，<strong>我们可以先不思考，计算机会如何实现这个问题，而是单纯考虑“人脑”会如何去解决这个问题</strong>；<br>我们可以实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决。</p>
<h2 id="如何编辑计算最长公共子串长度呢？"><a href="#如何编辑计算最长公共子串长度呢？" class="headerlink" title="如何编辑计算最长公共子串长度呢？"></a>如何编辑计算最长公共子串长度呢？</h2><p>只允许增加、删除字符两种编辑操作。从名字上，你可能觉得它看起来跟编辑距离没什么关系。实际上，从本质上来说，它表征的也是两个字符串之间的相似程度。</p>
<p>每个状态还是包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。那 (i, j) 这个状态都是由哪些状态转移过来的呢？</p>
<ol>
<li>如果 a[i]与 b[j]互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</li>
<li>如果 a[i]与 b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</li>
<li>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</li>
<li>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</li>
</ol>
<p>如果我们要求 a[0…i]和 b[0…j]的最长公共长度 max_lcs(i, j)，我们只有可能通过下面三个状态转移过来</p>
<ol>
<li>(i-1, j-1, max_lcs)，其中 max_lcs 表示 a[0…i-1]和 b[0…j-1]的最长公共子串长度；</li>
<li>(i-1, j, max_lcs)，其中 max_lcs 表示 a[0…i-1]和 b[0…j]的最长公共子串长度；</li>
<li>(i, j-1, max_lcs)，其中 max_lcs 表示 a[0…i]和 b[0…j-1]的最长公共子串长度。</li>
</ol>
<p>状态转移方程是：</p>
<pre><code>如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：
max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；
如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：
max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；
</code></pre><p>代码实现是：</p>
<pre><code>public int lcs(char[] a, int n, char[] b, int m) {
int[][] maxlcs = new int[n][m];
for (int j = 0; j &lt; m; ++j) {//初始化第0行：a[0..0]与b[0..j]的maxlcs
    if (a[0] == b[j]) maxlcs[0][j] = 1;
    else if (j != 0) maxlcs[0][j] = maxlcs[0][j-1];
    else maxlcs[0][j] = 0;
}
for (int i = 0; i &lt; n; ++i) {//初始化第0列：a[0..i]与b[0..0]的maxlcs
    if (a[i] == b[0]) maxlcs[i][0] = 1;
    else if (i != 0) maxlcs[i][0] = maxlcs[i-1][0];
    else maxlcs[i][0] = 0;
}
for (int i = 1; i &lt; n; ++i) { // 填表
    for (int j = 1; j &lt; m; ++j) {
    if (a[i] == b[j]) maxlcs[i][j] = max(
        maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);
    else maxlcs[i][j] = max(
        maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]);
    }
}
return maxlcs[n-1][m-1];
}

private int max(int x, int y, int z) {
    int maxv = Integer.MIN_VALUE;
    if (x &gt; maxv) maxv = x;
    if (y &gt; maxv) maxv = y;
    if (z &gt; maxv) maxv = z;
    return maxv;
}
</code></pre><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p>
<p>针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种。</p>
<ol>
<li>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</li>
<li>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。</li>
<li>我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</li>
<li>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</li>
</ol>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/初识动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/初识动态规划/" itemprop="url">动态规划上：初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:59:01+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识动态规划：如何解决双十一购物时的凑单问题"><a href="#初识动态规划：如何解决双十一购物时的凑单问题" class="headerlink" title="初识动态规划：如何解决双十一购物时的凑单问题"></a>初识动态规划：如何解决双十一购物时的凑单问题</h1><p>双十一，总有很多比如满200减50的活动，假设女朋友购物车中有n个（n&gt;100)商品，在凑够满减条件的前提下，让选出的商品价格总和最大程度上接近满减条件200元，如何使用程序搞定呢？</p>
<h2 id="动态规划学习路线"><a href="#动态规划学习路线" class="headerlink" title="动态规划学习路线"></a>动态规划学习路线</h2><p>动态规划适合求解最优问题，比如最大值，最小值等等；</p>
<p>三部分学习：<br>第一节通过两个经典问题展示为什么要使用动态规划以及动态规划解题方法是如何演化过来的？</p>
<p>第二节总结动态规划适合解决问题的特征，以及动态规划解题思路；</p>
<p>第三节动态规划的实际应用；</p>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>贪心算法中的背包问题物品是可以分割的，回溯算法中物品不可以分割，只是回溯算法中我们要穷举所有可能的方法，时间复杂度是指数级的，回溯算法的实现方法如下：</p>
<pre><code>private int maxW = Integer.MIN_VALUE; //结果放在maxW中
private int[] weight = {2,2,4,6,3}; //物品重量
private int n = 5; //物品个数
private int w = 9; //背包容量
public void f(int i,int cw){ //调用方法f(0,0)
    if(cw == w || i == n){
        if(cw &gt; maxW) maxW = cw;
        return;
    }
    f(i+1,cw);//选择不装第i件物品
    if(cw + weight[i] &lt;= w){
        f(i+1,cw + weight[i]); //选择装下第i件物品
    }
}
</code></pre><p>将上述的过程画成递归树的形式就是：<br><img src="/2020/06/16/初识动态规划/0-1背包递归树.jpg" alt="0-1背包递归树"></p>
<p>其中每一个节点表示一种状态，(i,cw)表示，i表示第i件物品是否装入背包，cw表示当前背包中物品的总重量。</p>
<p>在上述图中发现有些子问题是重复的，可以借助递归那一节讲的备忘录，将计算好的f(i,cw)存储起来，下次直接取用，改造之后的代码是：</p>
<pre><code>private int maxW = Integer.MIN_VALUE;
private int[] weight = {2,2,4,6,3};
private int n = 5;
private int w = 9;
private boolean[][] mem = new boolean[5][10];//5个物品，10个重量

public void f(int i,int cw){
    if(cw == w || i == n){
        if(cw &gt; maxW){
            maxW = cw;
        }
    }
    if(mem[i][cw]) return; //判断是否是重复状态
    mem[i][cw] = true; //及时记录已经访问过的状态
    f(i+1,cw);//第i个物品不放入
    if(cw + weight[i] &lt;= w){
        f(i+1,cw + weight[i]);//第i个物品放入
    }
}
</code></pre><p>这种解决方法已经和动态规划执行效率差不多了。</p>
<p>我们把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放入背包，每个物品的决策之后，背包中的物品重量会有很多情况，也就是说会达到多种不同的状态，对应到递归树中有很多不同的节点；</p>
<p>我们把每一层的重复状态进行合并，只记录不同的状态，然后基于上一层的状态集合，推导下一层的状态集合，通过合并每一层的状态，保证了每一层不同状态的个数不会超过w个；</p>
<p>我们使用一个二维数组states[n][w+1],来记录可以达到的不同状态；</p>
<p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。</p>
<p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态；</p>
<p>以此类推考察完所有的物品之后，整个states数组就计算好了，整个过程如图所示:</p>
<p><img src="/2020/06/16/初识动态规划/0-1背包状态转移表.jpg" alt="0-1背包状态转移表"></p>
<p>上述的过程比较翻译成代码就是：</p>
<pre><code>public int knapsack(int[] weight,int n,int w){
    boolean[][] states = new boolean[n][w+1]; //默认为false
    states[0][0] = true; //第一行数据特殊处理
    if(weight[0] &lt;= w){
        states[0][weight[0]] = true;
    }
    for(int i = 1; i &lt; n; i++){ //动态规划状态转移
        for(int j = 0; j &lt;= w;++j){ //不把第i件物品放入
            if(states[i-1][j]){
                states[i][j] = states[i-1][j];
            }
        }
        for(int j = 0;j &lt; w - weight[i];j++){//把第i件物品放入
            if(states[i-1][j]){
                states[i][j+weight[i]] = true;
            }
        }
    }
    for(int i = w; i &gt;= 0; i--){
        if(states[n-1][i]){
            return i;
        }
    }
    return 0;
}
</code></pre><p>实际上这是一种记录每一个阶段可达的状态集合，然后通过当前阶段的动态集合，来推导下一阶段的状态集合；</p>
<p>耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。</p>
<p>如果物品很多，怎么办？<br>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多;</p>
<p>改进方法使用一个一维数组就可以了：</p>
<pre><code>public int knapsack1(int[] weight,int n,int w){
    boolean[] states = new boolean[w+1]; //默认为false
    states[0] = true; //第一行数据特殊处理
    if(weight[0] &lt;= w){
        states[weight[0]] = true;
    }
    for(int i = 1; i &lt; n; i++){ //动态规划状态转移
        for(int j = w - weight[i]; j &gt;= 0;--j) { //把第i件物品放入
            if (states[j]) {
                states[j + weight[i]] = true;
            }
        }
    }
    for(int i = w; i &gt;= 0; i--){
        if(states[i]){
            return i;
        }
    }
    return 0;
}
</code></pre><h2 id="0-1背包问题升级版"><a href="#0-1背包问题升级版" class="headerlink" title="0-1背包问题升级版"></a>0-1背包问题升级版</h2><p>如果在上述问题的基础上引入物品价值这一变量，在满足最大重量的前提下，背包中可以装入的总价值最大是多少呢？</p>
<pre><code>private int maxV = Integer.MIN_VALUE;
private int[] items = {2,2,4,6,3};
private int[] value = {3,4,8,9,6};
private int n = 5;
private int w = 9;

/**
 * 回溯算法
 * @param i
 * @param cw
 * @param cv
 */
public void f(int i,int cw,int cv){
    if(cw == w || i == n){
        if(cv &gt; maxV){
            maxV = cv;
        }
    }
    f(i+1,cw,cv);
    if(cw + items[i] &lt;= w){
        f(i + 1,cw + items[i],cv + value[i]);
    }
}
</code></pre><p>画出相应的递归树为：<br><img src="/2020/06/16/初识动态规划/0-1背包最大价值递归树.jpg" alt="0-1背包最大价值递归树"></p>
<p>在上述的过程中存在很多的重复节点，我们每次都在记录相应的状态集；</p>
<p>我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p>
<pre><code>public static int knapsack3(int[] weight,int[] value,int n,int w){
    int[][] states = new int[n][w+1];
    //初始化
    for(int i = 0; i &lt; n; i++){
        for(int j = 0; j &lt; w + 1;j++){
            states[i][j] = -1; //此时记录的状态图应该是价格值，并且相同的情况取最大价格
        }
    }
    states[0][0] = 0;
    if(weight[0] &lt;= w){
        states[0][weight[0]] = value[0];
    }
    for(int i = 1; i &lt; n; i++){
        for(int j = 0; j &lt;= w; j++){
            if(states[i-1][j] &gt;= 0){
                states[i][j] = states[i-1][j];//不放入i物品
            }
        }
        for(int j = 0; j &lt; w-weight[i]; j++){
            if(states[i-1][j] &gt;= 0){
                int v = states[i-1][j] + value[i];
                if(v &gt; states[i][j+weight[i]]){
                    states[i][j+weight[i]] = v;
                }
            }
        }
    }
    //找出最大值
    int maxvalue = -1;
    for (int j = 0; j &lt;= w; ++j){
        if (states[n-1][j] &gt; maxvalue)
            maxvalue = states[n-1][j];
    }
    return maxvalue;
}
</code></pre><p>跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于 200 并且最接近 200 的组合是哪一个？但是，这样效率太低了点，时间复杂度非常高，是指数级的。</p>
<p>实际上是0-1背包的变形问题，我们要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。就这个实际问题而言，如果要买的东西比200多很多，就没有了意义；</p>
<p>其次就是还有找到相应的物品是那些；</p>
<pre><code>/**
 * 双十一凑单
 * @param items
 * @param n
 * @param w
 */
public static void double11advance(int[] items,int n,int w){
    boolean[][] states = new boolean[n][3*w+1];
    states[0][0] = true;
    if(items[0] &lt;= 3*w){
        states[0][items[0]] = true;
    }
    for(int i = 1; i &lt; n; i++){
        for(int j = 0; j &lt;= 3*w;j++){
            if(states[i-1][j]) {
                states[i][j] = states[i-1][j];
            }
        }
        for(int j = 0; j &lt; 3*w-items[i]; j++){
            if(states[i-1][j]){
                states[i][j+items[i]] = true;
            }
        }
    }

    int j;
    for(j = w; j &lt; 3*w+1;j++){ //从w开始，输出结果大于w的最小值
        if(states[n-1][j]){
            break;
        }
    }
    if(j == 3*w+1) return;//没有可行解
    for(int i = n-1;i &gt;= 1;--i){
        if(j-items[i] &gt;= 0 &amp;&amp; states[i-1][j-items[i]]){
            System.out.println(items[i] + &quot; &quot;);
            j = j-items[i];
        }
    }
    if(j != 0){
        System.out.println(items[0]);
    }
}
</code></pre><p>状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states[i-1][j]或者 states[i-1][j-value[i]]是否是 true。</p>
<p>如果 states[i-1][j]可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>杨辉三角；<br>我们现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。</p>
<p>假设你站在第一层，往下移动，我们把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。</p>
<p><img src="/2020/06/16/初识动态规划/杨辉三角.jpg" alt="杨辉三角"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/排序/" itemprop="url">排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:57:52+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？"><a href="#上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？" class="headerlink" title="上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？"></a>上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？</h2><p>最经典、最常用的排序：冒泡排序，插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。<br><img src="/2020/06/16/排序/常见排序算法复杂度.jpg" alt="常见排序算法复杂度"></p>
<h2 id="思考题：插入排序和冒泡排序的时间复杂度相同，都是-O-n2-，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？"><a href="#思考题：插入排序和冒泡排序的时间复杂度相同，都是-O-n2-，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？" class="headerlink" title="思考题：插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？"></a>思考题：插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</h2><h2 id="如何分析一个排序算法"><a href="#如何分析一个排序算法" class="headerlink" title="如何分析一个排序算法"></a>如何分析一个排序算法</h2><p><strong>算法的执行效率</strong><br><strong>1、最好情况、最坏情况。平均情况时间复杂度</strong><br>处理上述复杂度，还有说出具体什么情况的原始数据会导致这种情况<br>我们要知道排序算法在不同数据中的性能表现</p>
<p><strong>2、时间复杂度的系数、常阶、低阶</strong><br>对统一阶时间复杂度的排序算法性能对比的时候，我们吧系数、常数、低阶也要考虑进来</p>
<p><strong>3、比较次数和交换(或交换)次数</strong><br>基于比较的排序算法的执行过程，会设计两种操作，一种是元素比较大小，另一种是元素交换或移动，在分析算法的时候应该将比较和移动次数考虑进去</p>
<p><strong>排序算法的内存消耗</strong><br>算法的内存消耗可以使用空间复杂度来衡量。<br>原地排序，特指空间复杂度是O(1)的排序算法。</p>
<p><strong>排序算法的稳定性</strong><br>稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据。<br>每次对相邻两个元素进行比较，之后跟前判断进行交换。<br>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：<br><img src="/2020/06/16/排序/冒泡过程.jpg" alt="冒泡过程"><br>优化的冒泡排序，增加一个flag，判断是否存在数据交换，如果存在则没有排序完成，反之完成<br><img src="/2020/06/16/排序/是否有交换冒泡.jpg" alt="是否有交换冒泡"></p>
<p>具体的冒泡排序：</p>
<pre><code>/**
 * 冒泡排序，第一层控制冒泡次数，第二层控制相邻元素之间的交换。
 * @param a
 */
public static void bubbleSort(int[] a){
    if(a.length &lt;= 1){
        return;
    }
    for(int i = 0; i &lt; a.length;i++){ //控制冒泡次数
        boolean flag = false; //增加判断条件，如果已经排序好了及时停止。
        for(int j = 0; j &lt; a.length - i -1; j++){
            if(a[j] &gt; a[j+1]){ //只有a[j] &gt; a[j+1]才会交换位置，等于是不加交换的，保证稳定性
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
                flag = true;
            }
        }
        if(!flag) break;
    }
}
</code></pre><p>三个问题：<br><strong>冒泡排序是否是原地排序算法？</strong><br>只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<p><strong>冒泡排序是稳定的排序算法吗？</strong><br>当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<p><strong>冒泡排序的时间复杂度是多少？</strong><br>最好情况是O(n),此时数据已经有序，只需做一次冒泡操作；<br>最坏情况是O(n^2),此时数据刚好事倒序，需要做n次冒泡操作；</p>
<p>平均时间复杂度，通过“有序度”和“逆序度”两个概念来进行分析：<br><strong>有序度</strong>是数组中具有有序关系的元素对的个数。</p>
<pre><code>有序元素对：a[i] &lt;= a[j], 如果i &lt; j。
</code></pre><p><img src="/2020/06/16/排序/有序度.jpg" alt="有序度"></p>
<p>对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。</p>
<p>逆序度的定义正好跟有序度相反（默认从小到大为有序）</p>
<pre><code>逆序元素对：a[i] &gt; a[j], 如果i &lt; j。
</code></pre><p><strong>逆序度 = 满有序度 - 有序度</strong></p>
<p>如果那一开始那个冒泡例子来看<br><img src="/2020/06/16/排序/冒泡过程有序度.jpg" alt="冒泡过程有序度"></p>
<p>冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1<br>交换次数总是确定的，即为逆序度，也就是n<em>(n-1)/2–初始有序度。<br>最坏情况下，初始状态的有序度是 0，所以要进行 n</em>(n-1)/2 次交换。最好情况下，初始状态的有序度是 n<em>(n-1)/2，就不需要进行交换。我们可以取个中间值 n</em>(n-1)/4。</p>
<p>换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<p><img src="/2020/06/16/排序/插入排序.jpg" alt="插入排序"></p>
<p>一种是元素的比较，一种是元素的移动；<br>移动操作的次数总是固定的等于逆序度；<br><img src="/2020/06/16/排序/移动元素个数.jpg" alt="移动元素个数"></p>
<p>具体代码：</p>
<pre><code>/**
 * 插入排序
 * @param a
 */
public static void insertionSort(int[] a){
    for(int i = 1; i &lt; a.length; i++){
        int value = a[i]; //记录数据，防止在数据移动过程中被覆盖
        int j = i - 1; //记录空位，即插入位置，在最后可以直接插入
        for(; j &gt;= 0; j--){
            if(a[j] &gt; value){
                a[j+1] = a[j];
            }else {
                break;
            }
        }
        a[j+1] = value;
    }
}
</code></pre><p>三个问题：<br><strong>冒泡排序是否是原地排序算法？</strong><br>不需要额外的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<p><strong>冒泡排序是稳定的排序算法吗？</strong><br>我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
<p><strong>冒泡排序的时间复杂度是多少？</strong><br>最好情况是O(n),此时数据已经有序<br>最坏情况是O(n^2),此时数据刚好是倒序，每次插入都相当于在数组的第一个位置插入新的数据；<br>平均复杂度：数组插入的复杂度是O(n),但是插入排序相等于执行了n次插入操作，平均复杂度是O(n^2)</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。<br><img src="/2020/06/16/排序/选择排序原理.jpg" alt="选择排序原理"></p>
<p>选择排序空间复杂度为 O(1)，是一种原地排序算法。<br>选择排序是一种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
<p>代码：</p>
<pre><code>/**
 * 选择排序
 * @param a
 */
public static void selectionSort(int [] a){
    for(int i = 0; i &lt; a.length; i++){//遍历数组中所有的位置
        int min = i;//默认该位置上的现有的数就是未排序区最小的
        for(int j = i + 1; j &lt; a.length;j++){//向后遍历
            if(a[j] &lt; a[min]){ //找出更小的数
                min = j; //记录下标
            }
        }
        int temp = a[i];  //交换位置
        a[i] = a[min];
        a[min] = temp;
    }
}
</code></pre><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。<br>插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p>
<p>从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：</p>
<pre><code>冒泡排序中数据的交换操作：
if (a[j] &gt; a[j+1]) { // 交换
    int tmp = a[j];
    a[j] = a[j+1];
    a[j+1] = tmp;
    flag = true;
}

插入排序中数据的移动操作：
    if (a[j] &gt; value) {
    a[j+1] = a[j];  // 数据移动
    } else {
    break;
}
</code></pre><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p>
<h2 id="冒泡，插入，选择排序小结"><a href="#冒泡，插入，选择排序小结" class="headerlink" title="冒泡，插入，选择排序小结"></a>冒泡，插入，选择排序小结</h2><p><img src="/2020/06/16/排序/冒泡_插入_选择小结.jpg" alt="冒泡_插入_选择小结"> </p>
<h1 id="排序下篇：如何使用快排思想在O-n-内查找第K大元素"><a href="#排序下篇：如何使用快排思想在O-n-内查找第K大元素" class="headerlink" title="排序下篇：如何使用快排思想在O(n)内查找第K大元素"></a>排序下篇：如何使用快排思想在O(n)内查找第K大元素</h1><p>今天讲述两种时间复杂度是O(nlogn)的排序算法，归并排序和快速排序。两者都用到了分治思想<br><strong>开篇题目：如何在O(n)的时间复杂度中查找一个无序数组中的第K大的元素？</strong></p>
<h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>具体的原理图如下：<br><img src="/2020/06/16/排序/归并排序原理图.jpg" alt="归并排序原理图"></p>
<p>分治思想，分而治之，将大问题化解为小问题来解决</p>
<p>分治算法一般都是用递归来实现的，分治是一种思想，递归时编程技巧。</p>
<p>如何使用递归代码来实现归并排序</p>
<pre><code>//归并排序算法，A是数组，n表示数组大小
merge_sort(A,n){
    merge_sort_c(A,0,n-1)
}

//递归调用函数
merge_sort_c(A,p,r){
    //递归终止条件
    if p &gt;= r then return

    //取p到r之间中间位置q
    q = (p+r)/2
    //分治递归
    merge_sort_c(A,p,q)
    merge_sort_c(A,q+1,r)
    //将A[p...q]和A[q+1...r]合并为A[p...r]
    merge(A[p...r],A[p...q],A[q+1...r])
}  
</code></pre><p>merge(A[p…r],A[p…q],A[q+1…r])函数的作用是，将已经有序的A[p…q]和A[q+1…r]合并成一个有序的数组，并且放入A[p…r]</p>
<p>我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。<br>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r] 中。</p>
<p><img src="/2020/06/16/排序/merge.jpg" alt="merge"></p>
<p>代码实现：</p>
<pre><code>/**
 * 归并排序
 * @param a
 */
public static void mergeSort(int[] a){
    //调用
    mergeSortC(a,0,a.length-1);
}

/**
 * 递归函数实现分而治之这个过程
 * @param a
 * @param start
 * @param end
 */
public static void mergeSortC(int[] a,int start,int end){
    //判断是否此时只有一个元素，递归终止条件
    if(start &gt;= end){
        return;
    }
    //找到数组中间元素下标
    int mid = (start + end)/2;
    //递归左分
    mergeSortC(a,start,mid);
    //递归右分
    mergeSortC(a,mid+1,end);
    //两者合并
    merge(a,start,mid,end);
}

/**
 * 将两个分开的数组合并成一个数组，放回原数组位置
 * @param a
 * @param left
 * @param mid
 * @param right
 */
public static void merge(int[] a,int left,int mid,int right){
    int[] tmp = new int[a.length];
    int p1 = left;
    int p2 = mid + 1;
    int k = left;
    //数据比较，放入新的暂存空间
    while(p1 &lt;= mid &amp;&amp; p2 &lt;= right){
        if(a[p1] &lt;= a[p2]){
            tmp[k++] = a[p1++];
        }else{
            tmp[k++] = a[p2++];
        }
    }
    //将有剩余的数组全部放到暂存数组最后
    while (p1 &lt;= mid){
        tmp[k++] = a[p1++];
    }
    while (p2 &lt;= right){
        tmp[k++] = a[p2++];
    }
    //数组拷贝回原来数组
    for(int i = left;i &lt;= right; i++){
        a[i] = tmp[i];
    }
}
</code></pre><h2 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h2><p>第一、归并排序是稳定的排序算法，只要在merge函数中保证稳定就可以实现稳定<br>第二、归并排序的时间复杂度是多少？<br>    问题a可以分解为问题b，c求解a就变成了求解b,c,最后得出这样的递推关系<br>    T(a) = T(b) + T(c) + K<br>    K等于问题b，c的结果合并成问题a的结果所消耗的时间<br>    不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</p>
<pre><code>T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n&gt;1

T(n) = 2*T(n/2) + n 
     = 2*(2*T(n/4) + n/2) + n 
     = 4*T(n/4) + 2*n 
     = 4*(2*T(n/8) + n/4) + 2*n 
     = 8*T(n/8) + 3*n 
     = 8*(2*T(n/16) + n/8) + 3*n 
     = 16*T(n/16) + 4*n 
     ...... 
     = 2^k * T(n/2^k) + k * n
</code></pre><p>我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。<br>我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。</p>
<p>第三、归并排序的空间复杂度是多少<br>    一个致命的“弱点”，那就是归并排序不是原地排序算法。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p>
<h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p>快排的思想是这样的：如果在排序数组中下标从p到r之间的一组数据，我们选择p到r之间任意一个数据作为pivot（分区点）</p>
<p>我们遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放在右边，将pivot放到中间。<br>经过这个步骤之后，数组p到r之间的数据就被分成三个部分。<br><img src="/2020/06/16/排序/快排分区.jpg" alt="快排分区"><br>根据分治、递归的处理思想，我们将递归小标从p到q-1之间的数据和下标从q+1到r之间的数据，直至区间缩小到1，就说明所有的数据都有序了</p>
<pre><code>递推公式：
quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1...r)

终止条件：
p &gt;= r
</code></pre><p>递归伪代码：</p>
<pre><code>//快速排序，A是数组，n是数组大小
quick_sort(A,n){
    quick_sort_c(A，0，n-1)
}
//快速排序递归函数，p，r为下标
quick_sort_c(A,p,r) {
    if p &gt;= r then return

    q = partition(A,p,r)
    quick_sort_c(A,p,q-1)
    quick_sort_c(A,q+1,r)
}
</code></pre><p>partition() 分区函数。随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r] 分区，函数返回 pivot 的下标。</p>
<pre><code>partition(A, p, r) {
    pivot := A[r]
    i := p
    for j := p to r-1 do {
        if A[j] &lt; pivot {
        swap A[i] with A[j]
        i := i+1
        }
    }
    swap A[i] with A[r]
return i
</code></pre><p>实现代码：</p>
<pre><code>/**
 * 快速排序
 * @param a
 */
public static void quickSort(int[] a){
    //调用递归函数
    quickSortC(a,0,a.length-1);
}

/**
 * 递归实现分区过程
 * @param a
 * @param start
 * @param end
 */
public static void quickSortC(int[] a,int start,int end){
    if(start &gt;= end){
        return;
    }
    int mid = partition(a,start,end);
    quickSortC(a,start,mid-1);
    quickSortC(a,mid+1,end);
}

/**
 * 将排序分区
 * @param a
 * @param start
 * @param end
 * @return
 */
public static int partition(int[] a,int start,int end){
    //默认最后一个元素是分界区元素
    int pivot = a[end];
    //i为开始的元素
    int i = start;
    //j从开始一直到倒数第二个元素
    for(int j = start; j &lt; end;j++){
        //如果a[j]小于分界点元素，将a[j]放到已处理区间末尾，也就是a[i]处，i往后挪
        if(a[j] &lt; pivot){
            int tmp = a[i];
            a[i] = a[j];
            a[j] = tmp;
            i = i+1;
        }
    }
    //循环完毕后，将默认的最后一个元素也就是分界点与a[i]交换
    int tmp = a[i];
    a[i] = a[end];
    a[end] = tmp;
    return i;
}
</code></pre><p>快排是原地排序算法，具体就是通过游标i将A[p…r-1]分为两部分。A[p…i-1]的元素都是pivot的，我们暂且叫已处理区间，A[i…r-1]是未处理区间。我们每次都从未处理区间中取一个元素A[j]，与pivot对比，如果小于pivot将其加入到已处理区间的尾部，也就是A[i]的位置。只需要将 A[i] 与 A[j] 交换，就可以在 O(1) 时间复杂度内将 A[j] 放到下标为 i 的位置。</p>
<p><img src="/2020/06/16/排序/分区.jpg" alt="分区"></p>
<p>分区过程中涉及到交换操作，所以快速排序并不是一个稳定的排序算法。<br><img src="/2020/06/16/排序/归并和快排区别.jpg" alt="归并和快排区别"></p>
<p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p>
<p>归并排序虽然是稳定的，非原地排序算法。<br>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<h2 id="快排的性能分析"><a href="#快排的性能分析" class="headerlink" title="快排的性能分析"></a>快排的性能分析</h2><p>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)</p>
<p>一个是分区极其均衡，一个是分区极其不均<br>T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。</p>
<h2 id="解答开篇-1"><a href="#解答开篇-1" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>求第K大元素<br>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p>
<p>如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K</p>
<p><img src="/2020/06/16/排序/K大.jpg" alt="K大"></p>
<p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</p>
<p>先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了。</p>
<h1 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h1><p>三种时间复杂度是O(n)的排序算法：桶排序、计数排序、基数排序，这些排序算法复杂度是线性的，所以称之为线性排序。之所以可以做到线性排序，主要原因是非基于比较的排序算法。</p>
<p>重点是掌握这些排序算法的适用场景；<br>如何根据年龄给100万用户排序？</p>
<h2 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h2><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据单独排序，桶内排完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><img src="/2020/06/16/排序/桶排序.jpg" alt="桶排序"></p>
<p>桶排序的时间复杂度是O(n)，如果排序的数据有n个，我们把它们均匀的划分到m个桶内，每个桶里就有k=n/m个元素。每个桶内使用快速排序，时间复杂度为O(k <em> logk) 。m个桶内时间表复杂度就是O(m </em> k <em> logk)，又因为k=n/m，所以整个桶排序的时间就变成了O(n</em>log(n/m)),当桶的个数m接近个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p>
<p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong><br>不可以，桶排序对要排序数据的要求是非常苛刻的<br>首先数据要很容易划分为m个桶，并且桶与桶之间有着天然的大小顺序，其次数据在各个桶之间分布式比较均匀的。<br>桶排序比较适合在外部排序中，所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>/**
 * 桶排序
 * @param a
 * @param bucketSize
 */
public static void bucketSort(int[] a, int bucketSize){
    if(a.length &lt;= 1){
        return;
    }
    //寻找最大最小值
    int min = a[0];
    int max = a[0];
    for (int i = 0; i &lt; a.length;i++){
        if(min &gt; a[i]){
            min = a[i];
        }else if(max &lt; a[i]){
            max = a[i];
        }
    }
    //计算桶间隔
    int bucketCount = (max - min) / bucketSize + 1;
    //创建二维数组做桶
    int[][] buckets = new int[bucketCount][bucketSize];
    //存储每个桶中元素个数
    int[] indexArr = new int[bucketCount];

    //遍历所有数据将数据放入不同的桶中
    for(int i = 0; i &lt; a.length;i++){
        int bucketIndex = (a[i] - min) / bucketSize;
        //扩容
        if(indexArr[bucketIndex] == buckets[bucketIndex].length){
            ensureCapacity(buckets,bucketIndex);
        }
        buckets[bucketIndex][indexArr[bucketIndex]++] = a[i];
    }

    int k = 0;
    for(int i = 0; i &lt; buckets.length;i++) {
        if (indexArr[i] == 0) {
            continue;
        }
        //桶内元素快排
        quickSortC(buckets[i], 0, indexArr[i] - 1);
        //元素复制到原数组中
        for (int j = 0; j &lt; indexArr[i]; j++) {
            a[k++] = buckets[i][j];
        }
    }
}

/**
 * 数组扩容
 * @param buckets
 * @param bucketIndex
 */
public static void ensureCapacity(int[][] buckets,int bucketIndex){
    int[] tempArr = buckets[bucketIndex];
    int[] newArr = new int[tempArr.length * 2];
    for (int j = 0; j &lt; tempArr.length; j++) {
        newArr[j] = tempArr[j];
    }
    buckets[bucketIndex] = newArr;
}
</code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>其实计数排序应该是桶排序的一种特殊情况。<br>当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p>
<h2 id="为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？"><a href="#为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？" class="headerlink" title="为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？"></a>为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</h2><p>假设8个考生，分数在0到5之间，这8个考生成绩放在一个数组A[8]中，分别是：2,5,3,0,2,3,0,3。<br>我们使用C[6]来表示桶，其中下标表示对应分数，C[6]内存储的并不是考生，而是对应的考生个数。<br>则C[6]的值为：<br><img src="/2020/06/16/排序/C6.jpg" alt="C6"><br>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8] 中，会保存下标 4，5，6 的位置。</p>
<p>如何快速计算出，每个分数考生对应的存储位置呢？<br>我们对C[6]顺序求和，C[6] 存储的数据就变成了下面这样子。C[k] 里存储小于等于分数 k 的考生个数。</p>
<p><img src="/2020/06/16/排序/C6求和.jpg" alt="C6求和"></p>
<p>我们从后往前（可以保证稳定性）扫描数组A，当扫描到3的时候，我们可以从数组C中去除下标是3 的值7，到目前为止，分数小于等于3的考生有7个，也就是说3是数组R中第7个元素，当3放入数组R中，小于等于3的元素就剩6个了，所以C[3]的值减一，变成6。以此类推。<br><img src="/2020/06/16/排序/计数排序过程.jpg" alt="计数排序过程"></p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><pre><code>/**
 * 计数排序
 * 可以对数据进行变换，数据只能是非负整数
 * @param a
 */
public static void countingSort(int[] a){
    if(a.length &lt;= 1){
        return;
    }
    //寻找数据范围
    int max = a[0];
    for(int i = 0; i &lt; a.length; i++){
        if(max &lt; a[i]){
            max = a[i];
        }
    }
    //申请一个数组c，小标是0~max
    int[] c = new int[max + 1];
    //计算每个元素的个数放入到c中
    for(int i = 0; i &lt; a.length;i++){
        c[a[i]]++;
    }
    //依次累加
    for(int i = 1; i &lt; c.length;i++){
        c[i] = c[i-1] + c[i];
    }
    //申请临时数组
    int[] r = new int[a.length];
    //计数排序，从后往前可以保证稳定性
    for(int i = a.length-1; i &gt;= 0;i--){
        r[c[a[i]]-1] = a[i];
        c[a[i]]--;
    }
    //结果拷贝给数组a
    for(int i = 0; i &lt; a.length; i++){
        a[i] = r[i];
    }
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合计数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的要将不改变其相对大小的情况下，转化为非负整数。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p>
<p>假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了</p>
<p>借助稳定排序算法，先按照最后一位来排序手机号码，然后再按照倒数第二位重新排序，以此类推最后按照第一位重新排序，经过11次排序之后，手机号码就都有序了。</p>
<p><img src="/2020/06/16/排序/基数排序示意图.jpg" alt="基数排序示意图"></p>
<p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p>
<p>单词不等长，就将所有的单词补齐到相同长度，位数不够补0。</p>
<p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</strong></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>/**
 * 基数排序
 * @param arr
 */
public static void radixSort(int[] arr) {
    int max = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr[i] &gt; max) {
            max = arr[i];
        }
    }

    // 从个位开始，对数组arr按&quot;指数&quot;进行排序
    for (int exp = 1; max / exp &gt; 0; exp *= 10) {
        countingSort(arr, exp);
    }
}
/**
 * 变化的计数排序
 * @param arr
 * @param exp
 */
public static void countingSort(int[] arr, int exp) {
    if (arr.length &lt;= 1) {
        return;
    }

    // 计算每个元素的个数
    int[] c = new int[10];
    for (int i = 0; i &lt; arr.length; i++) {
        c[(arr[i] / exp) % 10]++;
    }

    // 计算排序后的位置
    for (int i = 1; i &lt; c.length; i++) {
        c[i] += c[i - 1];
    }

    // 临时数组r，存储排序之后的结果
    int[] r = new int[arr.length];
    for (int i = arr.length - 1; i &gt;= 0; i--) {
        r[c[(arr[i] / exp) % 10] - 1] = arr[i];
        c[(arr[i] / exp) % 10]--;
    }

    for (int i = 0; i &lt; arr.length; i++) {
        arr[i] = r[i];
    }
}
</code></pre><h2 id="解答开篇-2"><a href="#解答开篇-2" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>根据年龄给100万用户排序，类似50万考生排序，假设年龄范围是1到120岁。遍历120万用户，将年龄划分到这120个桶内，一次遍历120个桶内的元素，就得到了按照年龄排序的120万数据。</p>
<p>如果数据特征比较符合这些桶排序、计数排序、基数排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。</p>
<h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？</p>
<p>利用桶排序思想，弄小写，大写，数字三个桶，遍历一遍，都放进去，然后再从桶中取出来就行了。复杂度O(n)</p>
<h1 id="排序优化：如何实现一个通用的高性能的排序函数"><a href="#排序优化：如何实现一个通用的高性能的排序函数" class="headerlink" title="排序优化：如何实现一个通用的高性能的排序函数"></a>排序优化：如何实现一个通用的高性能的排序函数</h1><p>排序函数如何实现的，底层是什么排序算法？</p>
<p><strong>如何实现一个通用的、高性能的排序函数</strong></p>
<h2 id="如何选择合适的排序算法"><a href="#如何选择合适的排序算法" class="headerlink" title="如何选择合适的排序算法"></a>如何选择合适的排序算法</h2><p><img src="/2020/06/16/排序/排序算法总结.jpg" alt="排序算法总结"></p>
<p>线性排序算法时间复杂度低，但使用场景比较特殊，写一个通用的排序函数，不能选择线性排序算法。</p>
<p>小规模数据排序，可以选择时间复杂度是O(n^2)的算法，如果是大规模数据进行排序，时间复杂度是O(nlogn)的算法更有效。为了兼顾任意规模，一般都会首选时间复杂度是O(nlogn)的排序算法。</p>
<p>堆排序和快速排序都有比较多的应用，java语言采用堆排序实现排序函数，C语言使用快速排序实现排序函数。</p>
<h2 id="如何优化快速排序"><a href="#如何优化快速排序" class="headerlink" title="如何优化快速排序"></a>如何优化快速排序</h2><p>快速排序的糟糕主要是因为分区点的选择不合理造成的。</p>
<p>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p>
<p><strong>1、三数取中法</strong><br>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这三个数的中间值作为分区点。如果排序数组比较大，那就五数取中或者十数取中。</p>
<p><strong>2、随机法</strong><br>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。不能保证每次分区都是好的，但概率是不大可能每次都是很差的。</p>
<h2 id="举例说明排序函数"><a href="#举例说明排序函数" class="headerlink" title="举例说明排序函数"></a>举例说明排序函数</h2><p>拿 Glibc 中的 qsort() 函数举例说明一下；<br>qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。</p>
<p>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。</p>
<p>qsort() 选择分区点的方法就是“三数取中法”</p>
<p>递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的</p>
<p>在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</p>
<p>时间复杂度代表的是一个增长趋势，在小规模数据时候，低阶，系数，常数之间对时间的影响还是很大的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/分治算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/分治算法/" itemprop="url">分治算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:56:08+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分治算法：谈一谈大规模计算框架MapReduce中的分治思想"><a href="#分治算法：谈一谈大规模计算框架MapReduce中的分治思想" class="headerlink" title="分治算法：谈一谈大规模计算框架MapReduce中的分治思想"></a>分治算法：谈一谈大规模计算框架MapReduce中的分治思想</h1><p>MapReduce是Google大数据处理的三驾马车，另外两个是GFS和Bigtable。</p>
<h2 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h2><p>分治算法的本质其实只有四个字，分而治之，也就是将原问题划分成n个规模更小，并且结构与原问题相似的子问题，递归的解决这些子问题，然后在合并其结果，就能得到原问题的解；</p>
<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。</p>
<p>在每一层递归中都会涉及这样三个操作：</p>
<ol>
<li>分解：将原问题分解成一系列子问题；</li>
<li>解决：递归的求解各个子问题，若子问题足够小，则直接求解；</li>
<li>合并：将子问题的结果合并成原问题；</li>
</ol>
<p>分治算法能解决的问题一把满足一下这几个条件：</p>
<ol>
<li>原问题与分解成的小问题具有相同的模式；</li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划之间明显的区别，等到动态规划再具体对比两种算法；</li>
<li>具有分解终止条件，也就是在问题足够小的时候可以直接求解；</li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减少算法总体复杂度的效果了；</li>
</ol>
<h2 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h2><p>计算一组数据的逆序度；</p>
<p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2；</p>
<p><img src="/2020/06/16/分治算法/逆序度.jpg" alt="逆序度"></p>
<p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong>因为有序对个数和逆序对个数的求解方式是类似的，所以你可以只思考逆序对个数的求解方法。</p>
<p>最笨的方法就是进行遍历求出整个逆序度，这样的遍历需要两重循环，时间复杂度是O(n^2);</p>
<p>使用分治算法来试试，我们使用分治算法的思想来求数组A的逆序度个数。我们将数组A1和A2，分别计算A1和A2的逆序对个数K1和K2，然后在计算A1与A2之间的逆序对个数K3.那数组A的逆序对个数就等于K1+K2+K3。</p>
<p>使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？</p>
<p>这个问题我们要借用归并排序算法，每次合并过程操作的时候就要计算逆序对个数，把那些计算出来的逆序对个数求和，就是整个数组的逆序对个数了；</p>
<p><img src="/2020/06/16/分治算法/归并排序计算逆序度过程.jpg" alt="归并排序计算逆序度过程"></p>
<p>代码实现：</p>
<pre><code>private int num = 0;

/**
 * 逆序度计数
 * @param a
 * @param n
 * @return
 */
public int count(int[] a,int n){
    num = 0;
    mergeSortCounting(a,0,n-1);
    return num;
}

/**
 * 归并排序，分而治之
 * @param a
 * @param p
 * @param r
 */
private void mergeSortCounting(int[] a,int p,int r){
    if(p &gt;= r){
        return ;
    }
    int q = (p + r) / 2;
    mergeSortCounting(a,p,q);
    mergeSortCounting(a,q+1,r);
    merge(a,p,q,r);
}

/**
 * 合并过程，加逆序度计数
 * @param a
 * @param p
 * @param q
 * @param r
 */
private void merge(int[] a,int p,int q,int r){
    int i = p,j = q + 1,k = 0;
    int[] tmp = new int[r-q+1];
    while(i &lt;= q &amp;&amp; j &lt;= r){
        if(a[i] &lt;= a[j]){
            tmp[k++] = a[i++];
        }else{
            num += (q - i + 1);
            tmp[k++] = a[j++];
        }
    }
    while(i &lt;= q){
        tmp[k++] = a[i++];
    }
    while(j &lt;= r){
        tmp[k++] = a[j++];
    }
    for(i = 0; i &lt;= r - p;i++){
        a[p+i] = tmp[i];
    }
}
</code></pre><p>关于分治算法有两道比较经典的问题，可以自己练习一下。</p>
<ol>
<li>二维平面上有n个点，如何计算出两个距离最近的点；</li>
<li>有两个n <em> n的矩阵A,B，如何快速求解两个矩阵的成绩 C=A </em> B</li>
</ol>
<h2 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h2><p>比如给10GB订单文件进行排序的需求，一个简单的排序问题，但因为数据量大，有10GB，也就无法直接单纯的用快排，归并算法来解决了；</p>
<p>要解决这种数据量大到内存装不下的问题，我们就可以合理利用分治算法，将海量数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载解决；</p>
<p>比如在这个订单金额排序的问题中，我们先讲数据按照金额区间进行分类，在对每个区间内的数据进行排序；</p>
<p>还可以将每个小区间的数据加载到不同的机器上并行处理；</p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>为什么说 MapReduce 的本质就是分治思想？</p>
<p>那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p>
<p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p>
<h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>分治算法用四个字概括就是“分而治之”，将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解</p>
<p>两种分治算法的典型的应用场景，一个是用来指导编码，降低问题求解的时间复杂度，另一个是解决海量数据处理问题。比如 MapReduce 本质上就是利用了分治思想。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/回溯算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/回溯算法/" itemprop="url">回溯算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:54:59+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想"><a href="#回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想" class="headerlink" title="回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想"></a>回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想</h1><p>在前面的章节中，图的深度优先搜索算法利用的就是回溯算法想，这个算法思想非常简单，但是应用很广泛，但是很多软件开发场景中都使用到了，比如正则表达式算法、编译原理中的语法分析等；</p>
<p>除此之外还有数独，八皇后，0-1背包问题，图的着色旅行商问题，全排列问题等等；</p>
<h2 id="如何理解“回溯算法”"><a href="#如何理解“回溯算法”" class="headerlink" title="如何理解“回溯算法”"></a>如何理解“回溯算法”</h2><p>笼统的讲，回溯算法很多时候都应用在搜索这类问题上，不过这里说的搜索并不是狭义的图的搜索，而是在一组可能的解中搜索满足期望的解；</p>
<p>回溯的处理思想，优点类似于枚举搜索，我们枚举所有的解，找到满足期望的解，为了有规律的枚举可能的解，避免遗漏和重复，我们把问题的求解过程分为很多阶段。每个阶段我们都会面对一个岔路口，我们先任意选择一条路走，当发现这条路走不通的时候，就回退到上一个岔路口，另选一条走法继续走；</p>
<p>一个比较经典的问题：八皇后的问题；</p>
<p>我们有一个8*8的棋盘，希望往里面放8个棋子，每个棋子所在的行列对角线都不能有另一个棋子。你可以看到下面的画，第一幅画就是满足条件的一种方法，第二幅就不满足条件，八皇后问题就是期望找到所有满足这种要求的放棋子方法。</p>
<p><img src="/2020/06/16/回溯算法/八皇后.jpg" alt="八皇后"></p>
<p>我们把问题分成8个阶段，依次将8个棋子放到第一行，第二行到第八行，在放置的过程中，我们不断的检查当前放法，是否满足要求，如果满足就跳到下一行继续放棋子；不满足就再换一种放法；</p>
<p>翻译成代码如下：</p>
<pre><code>//全局变量，下标代表行，值表示queen存储在那一列
int[] result = new int[8];

/**
 *调用方式 cal8queens(0)
 * @param row
 */
public void cal8queens(int row){
    //8个棋子都放好了
    if(row == 8){
        printQueens(result);
        return ;
    }
    //每一行都有8个方法
    for(int col = 0; col &lt; 8;col++){
        if(isOk(row,col)){ //有些放法不满足要求
            result[row] = col; //第row行的棋子放在了col行
            cal8queens(row+1); //考察下一行
        }
    }
}

/**
 * 判断row行棋子放在col列是否合适
 * @param row
 * @param col
 * @return
 */
public boolean isOk(int row,int col){
    int leftup = col - 1;
    int rightup = col + 1;
    for(int i = row - 1; i &gt;= 0;i--){
        //考察正上方是否合适
        if(result[i] == col){
            return false;
        }
        //考察左上方是否合适
        if(leftup &gt;= 0){
            if(result[i] == leftup){
                return false;
            }
        }
        //考察右上方是否合适
        if(rightup &lt; 8){
            if(result[i] == rightup){
                return false;
            }
        }
        leftup--;
        rightup++;
    }
    return true;
}

/**
 * 打印
 * @param result
 */
private void printQueens(int[] result){
    for(int row = 0; row &lt; 8; row++){
        for(int col = 0; col &lt; 8; col++){
            if(result[row] == col){
                System.out.print(&quot;Q &quot;);
            }else{
                System.out.print(&quot;* &quot;);
            }
        }
        System.out.println();
    }
    System.out.println();
}
</code></pre><h2 id="两个回溯算法中的经典应用"><a href="#两个回溯算法中的经典应用" class="headerlink" title="两个回溯算法中的经典应用"></a>两个回溯算法中的经典应用</h2><h3 id="1、0-1背包"><a href="#1、0-1背包" class="headerlink" title="1、0-1背包"></a>1、0-1背包</h3><p>0-1背包问题有很多变体，介绍一种比较基础的，我们有一个背包，背包的总承重是Wkg，现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
<p>对于每个物品来说装进背包或者不装进背包，对于n个物品总的装法就有2^n种，去掉重量超过Wkg的，从剩下的装法中选择重量最接近Wkg的。不过我们如何才能不重复的穷举这2^n种方法呢？</p>
<p>回溯的方法，我们将物品一次放进排列，整个问题被分解成n阶段，每个阶段对应一个物品如何选择，先对第一个物品进行处理，选择装进去或者不装进去，然后在递归的处理下面的物品；</p>
<p>代码如下：</p>
<pre><code>/**
 * f(0,0,a,10,100)
 * @param i 表示考察到那个物品了
 * @param cw 表示当前已经装进去的物品总重量
 * @param items 表示每个物品的重量
 * @param n 表示物品个数
 * @param w 背包重量
 */
public void f(int i,int cw,int[] items,int n,int w){
    //cw == w表示装满了，i== n表示考察完所以的物品了
    if(cw == w || i == n){
        if(cw &gt; maxW) maxW = cw;
        return;
    }
    f(i+1,cw,items,n,w);
    // 已经超过可以背包承受的重量的时候，就不要再装了
    if(cw + items[i] &lt;= w){
        f(i+1,cw+items[i],items,n,w);
    }
}
</code></pre><h3 id="2、正则表达式"><a href="#2、正则表达式" class="headerlink" title="2、正则表达式"></a>2、正则表达式</h3><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。为了方便讲解，我假设正则表达式中只包含“<em>”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“</em>”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>
<p>我们依次考察正则表达式中的每个字符，当是非通配符的时候，就直接跟文本字符进行匹配，如果相同就继续往下处理，如果不相同就回溯；</p>
<p>如果遇到特殊字符的时候，我们就有多种处理方式，这就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就随意选择一种匹配方案，然后继续考察剩下的字符，如果中途发现无法匹配下去，我们就回到这个岔路口，重新选择一种方案，然后在继续匹配下去；</p>
<p>代码如下：</p>
<pre><code>public class Pattern {
    private boolean matched = false;
    private char[] pattern; //正则表达式
    private int plen; //正则表达式长度

    public Pattern(char[] pattern,int plen){
        this.pattern = pattern;
        this.plen = plen;
    }

    public boolean match(char[] text,int tlen){
        matched = false;
        rmatch(0,0,text,tlen);
        return matched;
    }

    private void rmatch(int ti,int pj,char[] text,int tlen){
        if(matched)return;
        if(pj == plen){ //正则表达式结尾了
            if(ti == tlen){ // 文本串也结尾了
                matched = true;
            }
            return;
        }
        if(pattern[pj] == &apos;*&apos;){ //匹配任意个字符
            for(int k = 0; k &lt; tlen - ti; k++){
                rmatch(ti + k,pj + 1,text,tlen);
            }
        }else if(pattern[pj] == &apos;?&apos;){ //匹配0个或者1个字符
            rmatch(ti,pj+1,text,tlen);
            rmatch(ti+1,pj+1,text,tlen);
        }else if(ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]){ //字符匹配才行
            rmatch(ti+1,pj+1,text,tlen);
        }
    }
}
</code></pre><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>现在我们对今天讲到的 0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/贪心算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/贪心算法/" itemprop="url">贪心算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:53:59+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="贪心算法：如何用贪心算法实现Huffman压缩编码"><a href="#贪心算法：如何用贪心算法实现Huffman压缩编码" class="headerlink" title="贪心算法：如何用贪心算法实现Huffman压缩编码"></a>贪心算法：如何用贪心算法实现Huffman压缩编码</h1><p>几种更加基本的算法，分别是贪心算法，分治算法，回溯算法，动态规划；</p>
<p>贪心算法比较经典的应用，比如霍夫曼编码，Prim和Kruskal最小生成树算法，还有Dijkstra单源最短路径算法。<br><strong>霍夫曼编码是如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的</strong></p>
<h2 id="如何理解贪心算法呢？"><a href="#如何理解贪心算法呢？" class="headerlink" title="如何理解贪心算法呢？"></a>如何理解贪心算法呢？</h2><p>先看一个例子，假设有一个可以容纳100kg的背包，有以下5种豆子，每种豆子的总量和总价值都各不相同，如何才能让背包中的物品价值最大呢？</p>
<p><img src="/2020/06/16/贪心算法/物品价值表.jpg" alt="物品价值表"></p>
<p>实际上这个问题很简单，我们只需要算一下每个物品的单价，按照从高到低来装就好了，所以最后的结果是包中装20kg黑豆，30kg绿豆，50kg红豆；</p>
<p>结合上面的例子，我们来总结一下贪心算法解决问题的步骤；<br><strong>第一步，当我们看到这类问题的时候，首先要联想到贪心算法</strong>：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p>
<p>上述例子中，背包重量不可以超过100kg就是限制值，物品的总价值就是期望值。</p>
<p><strong>第二步，我们尝试看下这个问题是否可以用贪心算法解决</strong>，每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据；</p>
<p><strong>第三步，我们举几个例子看下贪心算法产生的结果是否最优的</strong>，大部分情况下，举几个例子就可以了，严格证明贪心算法的正确性，是比较复杂度；</p>
<p>实际上，用贪心算法解决问题的思路，并不总能给出最优解。<br>我来举一个例子，比如在一个有权的无向图中寻找从顶点S到顶点T的最短路径；<br><img src="/2020/06/16/贪心算法/有权无向图.jpg" alt="有权无向图"><br>按照贪心算法解出的最短路径S，A，E，T，但是实际的最短路径是S，B，D，T；</p>
<p>在这个问题上，贪心算法不能工作的主要原因是因为前面的选择对后面的选择是产生影响的，所以即使是我们第一步的路径最小，但是导致了后面的每一步选择都很糟糕，最终没办法解出全局最优解；</p>
<h2 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h2><p>掌握贪心算法的关键在于多练习，具体问题具体分析；</p>
<h3 id="1、分糖果"><a href="#1、分糖果" class="headerlink" title="1、分糖果"></a>1、分糖果</h3><p>有m个糖果，n个孩子，我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多，（m &lt; n)，所以糖果只能分配给一部分孩子；</p>
<p>糖果大小不等，这m个糖果大小分别是s1，s2，s3，……，sm，除此之外每个孩子对糖果大小的需求也是不一样的，糖果大小必须大于孩子对糖果大小的需求。假设这n个孩子对糖果大小的需求分别是g1，g2，g3，……，gn。</p>
<p>问题是：如何分配糖果，能尽可能的满足最多数量的孩子？</p>
<p>从n个孩子中，抽取一部分孩子分配糖果，让满足的孩子数量最多，这个问题的限制值是糖果个数m。</p>
<p>对于一个孩子来说，如果小的糖果可以满足，我们没有必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子，另一方面，对糖果大小需求小的孩子更容易满足，所以我们可以从需求更大的孩子。开始分配糖果，因为满足一个大的孩子和满足一个需求小的孩子，对我的期望值贡献是一样的；</p>
<p>所以最后的做法就是，我们每次从剩下的孩子中，找出堆糖果需求最小的孩子，然后发给他剩下糖果中能满足她的最小的糖果，这样的分配方案也就是满足孩子个数最多的方案；</p>
<h3 id="2、钱币找零"><a href="#2、钱币找零" class="headerlink" title="2、钱币找零"></a>2、钱币找零</h3><p>假设我们有1元，2元，5元，10元，20元，50元，100元面额的纸币，他们的张数分别是c1，c2，c5，c10，c20，c50，c100；我们现在要用这些钱来支付K元，最少要用多少张纸币呢？</p>
<p>生活中我们肯定优先使用面值最大的来支付，如果不够继续使用面值更下一点的，以此类推，最后剩下的用1元补齐；</p>
<p>在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币树更少，这就是一种贪心算法的解决思路；</p>
<h3 id="3、区间覆盖"><a href="#3、区间覆盖" class="headerlink" title="3、区间覆盖"></a>3、区间覆盖</h3><p>假设我们有n个区间，区间起始端点和结束端点分别是[l1,r1],[l2,r2],……,[ln,rn];我们从这n个区间中选出一部分区间，这部分区间满足两两不相交（端点相交不算），最多能找出多少个区间呢？</p>
<p><img src="/2020/06/16/贪心算法/区间覆盖.jpg" alt="区间覆盖"></p>
<p>这道题思路涉及比如任务调度，教师排课等；</p>
<p>解决思路：我们假设这n个区间中最左边的端点是lmin，最右边的端点是rmax，这个问题就相当于选择几个不相交的区间，从左到右将[lmin,rmax]覆盖上，我们按照起始端点从小到大的顺序对这n个区间排序；</p>
<p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更大的区间；</p>
<p><img src="/2020/06/16/贪心算法/区间覆盖1.jpg" alt="区间覆盖1"></p>
<h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>假设我有一个包含1000个字符的文件，每个字符占1个byte，存储这个1000字符文件就需要8000bit，那么有没有更加节省空间的存储方式呢？</p>
<p>假设统计发现，这1000个字符中只包含6种不同的字符，分别是a,b,c,d,e,f。而3个二进制位就可以表示8个不同的字符，所以可以用3个二进制位表示，此时只需要3000bit就可以了，还有没有更加省空间的存储方式呢？</p>
<p>霍夫曼编码是一种十分有效的编码方式，广泛用于数据压缩中，其中压缩率通常在20%~90%，霍夫曼编码不仅会考察文本中有多少个不同的字符，霍夫曼编码不等长，出现概率越高的字符编码越短；</p>
<p>为了避免歧义，霍夫曼编码要求各个字符编码之间，不可以出现摸个编码是另一个编码前缀的情况；</p>
<p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p>
<p><img src="/2020/06/16/贪心算法/霍夫曼编码.jpg" alt="霍夫曼编码"></p>
<p>我们把每个字符看做一个节点，并且附带着把频率放到优先级队列中，我们从队列中取出频率最小的两个节点A，B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把这个新节点C作为节点A，B的父节点，最后再把C放入优先级队列中，重复上述过程，知道队列中没有数据；</p>
<p><img src="/2020/06/16/贪心算法/霍夫曼编码过程.jpg" alt="霍夫曼编码过程"></p>
<p>现在我们给每一条表加上一个权值，指向左节点的边我们统统记做1，那从根节点到叶子节点的路径就是叶子节点对应的字符的霍夫曼编码；</p>
<p><img src="/2020/06/16/贪心算法/霍夫曼编码结果.jpg" alt="霍夫曼编码结果"></p>
<h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。<br>不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol>
<li><p>在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？<br>1、从高位往下走，删掉高位比低位大的数，假如4596743只能删除一位，我们会删除第三位的9，删除一个数字剩下的数字位数一样，这个时候在越高位上删除数字最大的数字会使得剩下数字更小；<br>如果数字是递增的，直接删除最后k位就好了；</p>
</li>
<li><p>假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？<br>想让所有人的等待时间最短，那么我们得先处理服务时间短的，尽快把他们处理完了才能够处理后面的人；<br>先处理时间长的下面的人就要等待一个长的处理时间，先处理短的下面人员就需要等以短的时间；</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaodupi-zyq.github.io/2020/06/16/二分查找下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小六子的鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小六子的鱼的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/16/二分查找下/" itemprop="url">二分查找</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-16T21:47:59+08:00">
                2020-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二分查找（下）-如何快速定位IP对应的省份地址？"><a href="#二分查找（下）-如何快速定位IP对应的省份地址？" class="headerlink" title="二分查找（下）:如何快速定位IP对应的省份地址？"></a>二分查找（下）:如何快速定位IP对应的省份地址？</h1><p><strong>假设我们有12万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</strong></p>
<p>二分查找的变形问题</p>
<h2 id="四种常见的二分查找变形问题"><a href="#四种常见的二分查找变形问题" class="headerlink" title="四种常见的二分查找变形问题"></a>四种常见的二分查找变形问题</h2><ol>
<li>查找第一个值等于给定值的元素</li>
<li>查找最后一个值等于给定值的元素</li>
<li>查找第一个大于等于给定值的元素</li>
<li>查找最后一个小于等于给定值的元素</li>
</ol>
<p>（以数据是从小到大排列为前提）</p>
<h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p>上一节中的二分查找是最简单的一种，即有序数据集合中不存在重复的数据；<br>当有序数据集合中存在重复的数据，我们希望找到第一个值等于给定的数据。<br>找到第一个为8的元素。<br><img src="/2020/06/16/二分查找下/第一个.jpg" alt="第一个"></p>
<p>代码实现：</p>
<pre><code>/**
 * 寻找第一个等于给定值的元素
 * @param a
 * @param value
 * @return
 */
public int fristItem(int[] a,int value){
    int low = 0;
    int high = a.length - 1;
    while(low &lt;= high){
        int mid = low + ((high - low) &gt;&gt; 1);
        if(a[mid] &gt; value){
            high = mid - 1;
        }else if(a[mid] &lt; value){
            low = mid + 1;
        }else {
            if(mid == 0 || a[mid - 1] != value) return mid;
            else high = mid - 1;
        }
    }
    return -1;
}
</code></pre><p>a[mid] 跟要查找的 value 的大小关系有三种情况：大于、小于、等于。对于 a[mid]&gt;value 的情况，我们需要更新 high= mid-1；对于 a[mid] &lt; value的情况，我们需要更新 low=mid+1;当a[mid]=value的时候，如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是我们要找的第一个值等于给定值的元素。</p>
<h2 id="变形二：查找最后一个值等于给定值的元素"><a href="#变形二：查找最后一个值等于给定值的元素" class="headerlink" title="变形二：查找最后一个值等于给定值的元素"></a>变形二：查找最后一个值等于给定值的元素</h2><pre><code>/**
 * 查找最后一个等于给定值的函数
 * @param a
 * @param value
 * @return
 */
public int lastItem(int[] a, int value){
    int low = 0;
    int high = a.length - 1;
    while (low &lt;= high){
        int mid = low + ((high - low) &gt;&gt; 1);
        if(a[mid] &gt; value){
            high = mid - 1;
        }else if(a[mid] &lt; value){
            low = mid + 1;
        }else {
            if(mid == a.length - 1 || a[mid + 1] != value) {
                return mid;
            }else {
                low = mid + 1;
            }
        }
    }
    return  -1;
}
</code></pre><p>最后给定值的元素。</p>
<h2 id="变形三：查找第一个大于等于给定值的元素"><a href="#变形三：查找第一个大于等于给定值的元素" class="headerlink" title="变形三：查找第一个大于等于给定值的元素"></a>变形三：查找第一个大于等于给定值的元素</h2><p>实现代码：</p>
<pre><code>/**
 * 第一个大于等于给定值的元素
 * @param a
 * @param value
 * @return
 */
public int fristGEItem(int[] a,int value){
    int low = 0;
    int high = a.length - 1;
    while(low &lt;= high){
        int mid = low + ((high - low) &gt;&gt; 1);
        if(a[mid] &lt; value){
            low = mid + 1;
        }else {
            if(mid == 0 || a[mid - 1] &lt; value){
                return mid;
            }else {
                high = mid - 1;
            }
        }
    }
    return -1;
}
</code></pre><h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><pre><code>/**
 * 最后一个小于等于给定值的元素
 * @param a
 * @param value
 * @return
 */
public int lastLEItem(int[] a,int value){
    int low = 0;
    int high = a.length - 1;
    while(low &lt;= high){
        int mid = low + ((high - low) &gt;&gt; 1);
        if(a[mid] &gt; value){
            high = mid - 1;
        }else {
            if(mid == a.length - 1 || a[mid + 1] &gt; value){
                return mid;
            }else {
                low = mid + 1;
            }
        }
    }
    return -1;
}
</code></pre><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>IP地址可以转化为32位的整形数，所以我们可以将起始地址，按照对应的整形值的大小关系从小到大进行排序。</p>
<p>这样IP地址查找的问题就变成第四种变形问题，查找最后一个小于等于某个给定值的元素。</p>
<p>当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p>
<pre><code>public int search1(int[] nums, int target){
    return search1(nums,0,nums.length - 1, target);
}

public int search1(int[] nums,int low,int high,int target){
    if(low &gt; high){
        return -1;
    }
    int mid = low + ((high - low) &gt;&gt; 2);
    if(nums[mid] == target){
        return mid;
    }
    if(nums[mid] &lt; nums[high]){
        if(target &lt;= nums[high] &amp;&amp; target &gt; nums[mid]){
            return search1(nums,mid + 1,high,target);
        }else {
            return search1(nums,low,mid - 1,target);
        }
    }else {
        if(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid]){
            return search1(nums,low,mid - 1,target);
        }else {
            return search1(nums,mid + 1,high,target);
        }
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="小六子的鱼">
            
              <p class="site-author-name" itemprop="name">小六子的鱼</p>
              <p class="site-description motion-element" itemprop="description">某211大学研究生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://xiaodupi-zyq.github.io/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xiaoliuzizyq@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/xiao-ya-ma-xiao-liu-zi/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neowyj.github.io/" title="Neowyj" target="_blank">Neowyj</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.arflow.cn/t/4" title="ARFlow" target="_blank">ARFlow</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://snailclimb.top/JavaGuide/#/?id=java" title="JavaGuide" target="_blank">JavaGuide</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小六子的鱼</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>

-->



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    








  





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
