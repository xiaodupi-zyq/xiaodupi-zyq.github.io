<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小六子的鱼的个人博客</title>
  
  <subtitle>无穷的伟大,也是从“一”开始的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaodupi-zyq.github.io/"/>
  <updated>2020-06-16T14:08:36.968Z</updated>
  <id>https://xiaodupi-zyq.github.io/</id>
  
  <author>
    <name>小六子的鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>索引与数据库相关：B+树，索引，Redis实战相关总结</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/索引与数据库相关/</id>
    <published>2020-06-16T14:07:51.000Z</published>
    <updated>2020-06-16T14:08:36.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-树，索引，Redis实战相关总结"><a href="#B-树，索引，Redis实战相关总结" class="headerlink" title="B+树，索引，Redis实战相关总结"></a>B+树，索引，Redis实战相关总结</h1><h2 id="B-树，MySQL数据库索引的相关实现"><a href="#B-树，MySQL数据库索引的相关实现" class="headerlink" title="B+树，MySQL数据库索引的相关实现"></a>B+树，MySQL数据库索引的相关实现</h2><p>数据库索引是如何实现的呢？底层使用的是怎样的数据结构和算法呢？</p><h3 id="1、解决问题的前提是定义清楚问题"><a href="#1、解决问题的前提是定义清楚问题" class="headerlink" title="1、解决问题的前提是定义清楚问题"></a>1、解决问题的前提是定义清楚问题</h3><p>需求：简单来说就是两点：<br>根据某个值来查找数据，比如select <em> from user where id = 1234;<br>根据区间值来查找某些数据，比如select </em> from user where id &gt; 1234 and id &lt; 2345;</p><p>除了这些功能性的需求，再者就是要兼顾效率和空间；</p><h3 id="2、尝试用学过的数据结构来解决这个问题"><a href="#2、尝试用学过的数据结构来解决这个问题" class="headerlink" title="2、尝试用学过的数据结构来解决这个问题"></a>2、尝试用学过的数据结构来解决这个问题</h3><p>支持快速查询插入操作的动态结构，有散列表，跳表，红黑树；</p><p>散列表：插入查询时间复杂度都是O(1),但是散列表不支持按区间快速查找；</p><p>平衡二叉查找树：尽管性能很高，时间复杂度是O(logn)，对树进行中序排列之后也可以得到一个从小到大的数据序列，但是这仍然不能按照区间快速查找；</p><p>跳表：跳表是在链表基础上加了很多层索引构成的，他支持快速查找，插入删除数据，时间复杂度是O(logn),并且跳表是支持快速按照区间查找的，只需要找到起点，然后往后遍历即可；</p><p><img src="/2020/06/16/索引与数据库相关/跳表.jpg" alt="跳表"></p><p>数据库索引所用到的数据结构跟跳表非常相似，叫做B+树；</p><h3 id="3、改造二叉树解决问题"><a href="#3、改造二叉树解决问题" class="headerlink" title="3、改造二叉树解决问题"></a>3、改造二叉树解决问题</h3><p>对二叉树进行改造，树中的节点并不只是数据本身，而是作为索引，除此之外我们把每个叶子节点串在一起，形成一个链表；<br>（所谓跳表就是一层一层的链表，通俗讲链表+链表；所谓B+树就是树+链表，上面是树(二叉查找树），下面是链表）</p><p><img src="/2020/06/16/索引与数据库相关/改造二叉树.jpg" alt="改造二叉树"></p><p>改造之后的按区间查找：</p><p><img src="/2020/06/16/索引与数据库相关/区间查找.jpg" alt="区间查找"></p><p>如果成千万上亿的数据构建索引，如果索引都存储在内存中，尽管内存访问的速度恒快但是占用内存很大；比如一亿数据构建二叉树索引，就要包含大约一亿个节点，每个节点16字节，就需要1GB的内存空间；如果更大的表呢？</p><p>借助时间换空间的思路，将索引存储在磁盘中的话，尽管减少了内存的消耗，但是在数据查找的过程中需要读取磁盘的索引，因此数据查询效率就会相应的降低很多；</p><p>因此每个节点的读取或者访问，都对应一次磁盘操作，树的高度就等于磁盘操作次数；<br>所以我们继续改造，如果我们不使用二叉树索引，改成m叉树，高度就会变小，效率就会变高；</p><p><img src="/2020/06/16/索引与数据库相关/二叉树.jpg" alt="二叉树"><br><img src="/2020/06/16/索引与数据库相关/五叉树.jpg" alt="五叉树"></p><p>m叉树实现的B+树索引，代码实现出来就是：假设数据库存储的int类型的数据；</p><p>对于相同个数的数据构建m叉树索引，m越大，树的高度就越小，那么m是不是越大越好呢？</p><p>不管是内存还是磁盘，操作系统都是按页进行读取的，我们选择m的大小时候，要尽量让每一个节点的大小等于一个页的大小，读取一个节点只需要一次IO操作；</p><p><img src="/2020/06/16/索引与数据库相关/Bplus.jpg" alt="Bplus"></p><p>对于一个B+树来说，m值是根据页的大小事先计算好的，也就是说，每个节点最多只能有m个子节点。在数据库的写入数据过程中，这样就有可能使索引中某些节点的子节点个数超过m，这个节点的大小就超过了一个页的大小，读取这样的节点就会导致多次IO操作，如何解决这个问题呢？</p><p>实际上处理思路不复杂，我只需将这个节点分裂为两个节点，但是节点分裂之后，其上层的父节点的子节点个数就可能超过m个，不过这个没关系，我们用同样的方法，将父节点也分裂为两个节点，这种级联的反应会从下往上，一直影响到根节点。这个分裂过程如下图所示</p><p><img src="/2020/06/16/索引与数据库相关/节点分裂.jpg" alt="节点分裂"></p><p>因为要时刻保持B+树索引是一个m叉树，所以索引的存在会导致数据库写入数据降低，实际上，不光下入数据会变慢，删除数据也会变慢；</p><p>我们再删除过程中，也要更新索引节点，这个处理思路类似于跳表中删除数据的处理思路。频繁的数据删除必然会导致某些节点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率；</p><p>我们可以设置一个阈值，在B+树中，这个阈值是m/2。如果某个节点的子节点的个数小于m/2，我们就把他和相邻的兄弟节点合并，不过合并之后的节点个数可能会超过m，我们可以借助插入数据的处理方法，在分裂节点；</p><p><img src="/2020/06/16/索引与数据库相关/节点删除.jpg" alt="节点删除"></p><h3 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h3><p>B+树的特点：</p><ol><li>每个节点中子节点的个数不能超过m，也不能小于m/2;</li><li>根节点的子节点个数可以不超过m/2，这是一个例外；</li><li>m叉树只存储索引，并不真正的存储数据，这个有点类似跳表；</li><li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li><li>一般情况下，根节点会被存储在内存中，其他节点存储在磁盘中；</li></ol><p>B树实际上就是B-树；</p><ol><li>B+树中的节点不存储数据，只是索引，而B树中的节点存储数据；</li><li>B树中的叶子节点并不需要链表来串联；</li></ol><p>其实 B树只是一个节点的子节点不能小于m/2的m叉树；</p><h2 id="索引：如何在海量数据中快速查找到某个数据"><a href="#索引：如何在海量数据中快速查找到某个数据" class="headerlink" title="索引：如何在海量数据中快速查找到某个数据"></a>索引：如何在海量数据中快速查找到某个数据</h2><p>MySQL底层依赖的是一个B+树这种数据结构，类似Redis这样的k-v数据库中索引，又是什么呢？</p><h3 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引"></a>为什么需要索引</h3><p>如何节省存储空间，如何提高数据增删改查的执行效率，这样的问题就成了设计的重点；这些系统的实现都离不开索引；</p><p>索引换句话来说就好像是书记的目录；</p><h3 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h3><h4 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h4><ol><li>数据是格式化数据还是非格式化数据：格式化数据就是MySQL的数据，非格式化的数据就是类似于网页这样的数据，需要先做预处理，提取查询关键词；</li><li>数据是静态的还是动态的：静态数据不会有数据的增加，删除，更新操作，只需要考虑查询效率就可以；动态数据就要考虑查询效率，还要考虑支持动态的数据集合的索引；</li><li>索引存储在内存还是硬盘：主要是存储的位置不同访问的效率不同；</li><li>单值查找还是区间查找：</li><li>单关键词查找还是多关键词组合查找：</li></ol><h3 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h3><ol><li>不管是存储在内存中还是磁盘中，索引堆空间的消耗不能过大。</li><li>在考虑索引查询效率的同时，我们还要考虑索引维护成本；</li></ol><h3 id="构建索引的常见数据结构有哪些"><a href="#构建索引的常见数据结构有哪些" class="headerlink" title="构建索引的常见数据结构有哪些"></a>构建索引的常见数据结构有哪些</h3><p>散列表：增删查改性能都比较好，时间复杂度是O(1),用在一些键值数据库中，比如Redis，Memcache,这类索引一般存在于内存中；</p><p>红黑树：一种常用的平衡查找二叉树，数据插入，删除，查找的时间复杂度是O(logn)，也非常适合构建内存索引，Ext文件系统中，对磁盘块的索引就是红黑树；</p><p>B+树，比起红黑树来讲，更适合构建存储在磁盘中的索引，B+树是一个多叉树，所以对相同个数的数据构建索引，B+树的高度要低于红黑树，借助索引来查询数据的时候，读取B+树索引，需要的磁盘IO次数会更少。大部分关系型数据库的索引，比如MySQL，都是用B+树来实现的；</p><p>跳表：也支持快速的添加，删除，查找数据，我们通过灵活调整索引节点的个数和数据个数之间的比例，可以很好的平衡索引对内存的消耗及其查询效率，Redis中的有序集合，就是用跳表来构建的；</p><p>布隆过滤器，有一定的判错率，但是我们要规避他的短处，发挥长处，如果布隆过滤器判断不存在的数据就一定不存在，因此查询数据之前进行布隆过滤器，如果不存在就不用访问磁盘了；</p><h2 id="剖析Redis常用数据类型对应的数据结构"><a href="#剖析Redis常用数据类型对应的数据结构" class="headerlink" title="剖析Redis常用数据类型对应的数据结构"></a>剖析Redis常用数据类型对应的数据结构</h2><p>经典数据库Redis中常用的数据类型，底层都是用那些数据结构实现的呢？</p><h3 id="Redis数据库介绍："><a href="#Redis数据库介绍：" class="headerlink" title="Redis数据库介绍："></a>Redis数据库介绍：</h3><p>一种键值对数据库，非关系型数据库；<br>redis主要是是作为内存数据库使用，也就是说，数据是存储在内存中的，尽管他经常被用作内存数据库，但是他也支持数据存在在硬盘上；</p><p>Redis中键的数据类型是字符串，值的数据类型就很多，主要有，字符串，列表，字典，集合有序集合；</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表支持存储一组数据，这种类型的两种实现方法，一种是压缩列表，一种是双向循环列表；</p><p>采用压缩列表的条件是：</p><ol><li>列表中保存的单个数据（也有可能是字符串）小于64字节；</li><li>列表中数据个数少于512个；</li></ol><p>而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。具体的存储结构也非常简单：</p><p><img src="/2020/06/16/索引与数据库相关/压缩列表.jpg" alt="压缩列表"></p><p>压缩列表将不再像数组一样使用统一的大小来存储数据，而是需要多少是多少，相互连接起来；<br>这样比较节省内存，另一方面可以支持不同类型数据的存储，而且因为数据存储在一片连续的内存空间中，通过键来获取值我列表类型的数据，读取效率也非常高。</p><p>当列表中存储的数据量非常大的时候，也就是不能同时满足刚刚讲的两个条件时候，列表就要通过双向循环链表来实现了；</p><pre><code>typedef struct listnode {    struct listnode *prev;    struct listnode *next;    void *value;} listNode;typedef struct list{    listNode *head;    listNode *tail;    unsigned long len;} list;</code></pre><h3 id="字典（hash"><a href="#字典（hash" class="headerlink" title="字典（hash)"></a>字典（hash)</h3><p>字典类型用来存储一组数据对，每个数据对又包含键值两部分。字典类型也有两种实现方式，一种是我们刚刚讲到的压缩列表，一种是散列表；</p><p>同样当存储的数据量比较小的情况下，Redis才使用压缩列表来实现字典类型；</p><ol><li>字典中保存的键值大小都要小于64字节；</li><li>字典中键值的个数要小于512。</li></ol><p>当不能满足上述条件的时候，Redis使用散列表来实现字典类型。Redis使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容；</p><p>当装载因子大于1的时候，Redis会触发扩容，将散列表扩大到2倍；<br>当装载因子小于0.1的时候，Redis会触发缩容，缩小到字典数据个数的大约2倍；</p><p>扩容缩容需要大量的数据搬移和哈希值的重新计算，比较耗时，针对这个问题，Redis使用的是渐进式扩容缩容机制，避免一次性的数据搬移导致的服务停顿；</p><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>集合中数据类型用来存储一组不重复的数据，两种实现方法一种基于有序数组，一种基于散列表；</p><p>如果满足下面两个条件Redis使用有序数组，实现集合中数据类型；</p><ol><li>存储的数据都是整数；</li><li>存储的数据元素个数不超过512个；</li></ol><p>否则Redis使用散列表来存储集合中数据；</p><h3 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h3><p>有序集合，它用来存储一组数据，并且每个数据会附带一个得分，通过得分的大小，我们将数据组织成跳表这样数据结构，以支持，快速的按照的得分值，得分区间获取数据；</p><p>有序集合不仅仅只有跳表这一种实现方式，当数据量比较小的时候Redis会用压缩列表来实现有序集合，具体点说就是，使用压缩列表来实现有序集合的前提：</p><ol><li>所有数据的大小都要小于64字节；</li><li>元素要小于128个；</li></ol><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Redis 遇到的这个问题并不特殊，很多场景中都会遇到。我们把它叫作数据结构的持久化问题，或者对象的持久化问题。这里的“持久化”，你可以笼统地可以理解为“存储到磁盘”。</p><p>第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。</p><p>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B-树，索引，Redis实战相关总结&quot;&gt;&lt;a href=&quot;#B-树，索引，Redis实战相关总结&quot; class=&quot;headerlink&quot; title=&quot;B+树，索引，Redis实战相关总结&quot;&gt;&lt;/a&gt;B+树，索引，Redis实战相关总结&lt;/h1&gt;&lt;h2 id=&quot;B
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划上：初识</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/初识动态规划/</id>
    <published>2020-06-16T13:59:01.000Z</published>
    <updated>2020-06-16T14:01:29.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识动态规划：如何解决双十一购物时的凑单问题"><a href="#初识动态规划：如何解决双十一购物时的凑单问题" class="headerlink" title="初识动态规划：如何解决双十一购物时的凑单问题"></a>初识动态规划：如何解决双十一购物时的凑单问题</h1><p>双十一，总有很多比如满200减50的活动，假设女朋友购物车中有n个（n&gt;100)商品，在凑够满减条件的前提下，让选出的商品价格总和最大程度上接近满减条件200元，如何使用程序搞定呢？</p><h2 id="动态规划学习路线"><a href="#动态规划学习路线" class="headerlink" title="动态规划学习路线"></a>动态规划学习路线</h2><p>动态规划适合求解最优问题，比如最大值，最小值等等；</p><p>三部分学习：<br>第一节通过两个经典问题展示为什么要使用动态规划以及动态规划解题方法是如何演化过来的？</p><p>第二节总结动态规划适合解决问题的特征，以及动态规划解题思路；</p><p>第三节动态规划的实际应用；</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>贪心算法中的背包问题物品是可以分割的，回溯算法中物品不可以分割，只是回溯算法中我们要穷举所有可能的方法，时间复杂度是指数级的，回溯算法的实现方法如下：</p><pre><code>private int maxW = Integer.MIN_VALUE; //结果放在maxW中private int[] weight = {2,2,4,6,3}; //物品重量private int n = 5; //物品个数private int w = 9; //背包容量public void f(int i,int cw){ //调用方法f(0,0)    if(cw == w || i == n){        if(cw &gt; maxW) maxW = cw;        return;    }    f(i+1,cw);//选择不装第i件物品    if(cw + weight[i] &lt;= w){        f(i+1,cw + weight[i]); //选择装下第i件物品    }}</code></pre><p>将上述的过程画成递归树的形式就是：<br><img src="/2020/06/16/初识动态规划/0-1背包递归树.jpg" alt="0-1背包递归树"></p><p>其中每一个节点表示一种状态，(i,cw)表示，i表示第i件物品是否装入背包，cw表示当前背包中物品的总重量。</p><p>在上述图中发现有些子问题是重复的，可以借助递归那一节讲的备忘录，将计算好的f(i,cw)存储起来，下次直接取用，改造之后的代码是：</p><pre><code>private int maxW = Integer.MIN_VALUE;private int[] weight = {2,2,4,6,3};private int n = 5;private int w = 9;private boolean[][] mem = new boolean[5][10];//5个物品，10个重量public void f(int i,int cw){    if(cw == w || i == n){        if(cw &gt; maxW){            maxW = cw;        }    }    if(mem[i][cw]) return; //判断是否是重复状态    mem[i][cw] = true; //及时记录已经访问过的状态    f(i+1,cw);//第i个物品不放入    if(cw + weight[i] &lt;= w){        f(i+1,cw + weight[i]);//第i个物品放入    }}</code></pre><p>这种解决方法已经和动态规划执行效率差不多了。</p><p>我们把整个求解过程分为n个阶段，每个阶段会决策一个物品是否放入背包，每个物品的决策之后，背包中的物品重量会有很多情况，也就是说会达到多种不同的状态，对应到递归树中有很多不同的节点；</p><p>我们把每一层的重复状态进行合并，只记录不同的状态，然后基于上一层的状态集合，推导下一层的状态集合，通过合并每一层的状态，保证了每一层不同状态的个数不会超过w个；</p><p>我们使用一个二维数组states[n][w+1],来记录可以达到的不同状态；</p><p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。</p><p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态；</p><p>以此类推考察完所有的物品之后，整个states数组就计算好了，整个过程如图所示:</p><p><img src="/2020/06/16/初识动态规划/0-1背包状态转移表.jpg" alt="0-1背包状态转移表"></p><p>上述的过程比较翻译成代码就是：</p><pre><code>public int knapsack(int[] weight,int n,int w){    boolean[][] states = new boolean[n][w+1]; //默认为false    states[0][0] = true; //第一行数据特殊处理    if(weight[0] &lt;= w){        states[0][weight[0]] = true;    }    for(int i = 1; i &lt; n; i++){ //动态规划状态转移        for(int j = 0; j &lt;= w;++j){ //不把第i件物品放入            if(states[i-1][j]){                states[i][j] = states[i-1][j];            }        }        for(int j = 0;j &lt; w - weight[i];j++){//把第i件物品放入            if(states[i-1][j]){                states[i][j+weight[i]] = true;            }        }    }    for(int i = w; i &gt;= 0; i--){        if(states[n-1][i]){            return i;        }    }    return 0;}</code></pre><p>实际上这是一种记录每一个阶段可达的状态集合，然后通过当前阶段的动态集合，来推导下一阶段的状态集合；</p><p>耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。</p><p>如果物品很多，怎么办？<br>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多;</p><p>改进方法使用一个一维数组就可以了：</p><pre><code>public int knapsack1(int[] weight,int n,int w){    boolean[] states = new boolean[w+1]; //默认为false    states[0] = true; //第一行数据特殊处理    if(weight[0] &lt;= w){        states[weight[0]] = true;    }    for(int i = 1; i &lt; n; i++){ //动态规划状态转移        for(int j = w - weight[i]; j &gt;= 0;--j) { //把第i件物品放入            if (states[j]) {                states[j + weight[i]] = true;            }        }    }    for(int i = w; i &gt;= 0; i--){        if(states[i]){            return i;        }    }    return 0;}</code></pre><h2 id="0-1背包问题升级版"><a href="#0-1背包问题升级版" class="headerlink" title="0-1背包问题升级版"></a>0-1背包问题升级版</h2><p>如果在上述问题的基础上引入物品价值这一变量，在满足最大重量的前提下，背包中可以装入的总价值最大是多少呢？</p><pre><code>private int maxV = Integer.MIN_VALUE;private int[] items = {2,2,4,6,3};private int[] value = {3,4,8,9,6};private int n = 5;private int w = 9;/** * 回溯算法 * @param i * @param cw * @param cv */public void f(int i,int cw,int cv){    if(cw == w || i == n){        if(cv &gt; maxV){            maxV = cv;        }    }    f(i+1,cw,cv);    if(cw + items[i] &lt;= w){        f(i + 1,cw + items[i],cv + value[i]);    }}</code></pre><p>画出相应的递归树为：<br><img src="/2020/06/16/初识动态规划/0-1背包最大价值递归树.jpg" alt="0-1背包最大价值递归树"></p><p>在上述的过程中存在很多的重复节点，我们每次都在记录相应的状态集；</p><p>我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p><pre><code>public static int knapsack3(int[] weight,int[] value,int n,int w){    int[][] states = new int[n][w+1];    //初始化    for(int i = 0; i &lt; n; i++){        for(int j = 0; j &lt; w + 1;j++){            states[i][j] = -1; //此时记录的状态图应该是价格值，并且相同的情况取最大价格        }    }    states[0][0] = 0;    if(weight[0] &lt;= w){        states[0][weight[0]] = value[0];    }    for(int i = 1; i &lt; n; i++){        for(int j = 0; j &lt;= w; j++){            if(states[i-1][j] &gt;= 0){                states[i][j] = states[i-1][j];//不放入i物品            }        }        for(int j = 0; j &lt; w-weight[i]; j++){            if(states[i-1][j] &gt;= 0){                int v = states[i-1][j] + value[i];                if(v &gt; states[i][j+weight[i]]){                    states[i][j+weight[i]] = v;                }            }        }    }    //找出最大值    int maxvalue = -1;    for (int j = 0; j &lt;= w; ++j){        if (states[n-1][j] &gt; maxvalue)            maxvalue = states[n-1][j];    }    return maxvalue;}</code></pre><p>跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于 200 并且最接近 200 的组合是哪一个？但是，这样效率太低了点，时间复杂度非常高，是指数级的。</p><p>实际上是0-1背包的变形问题，我们要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。就这个实际问题而言，如果要买的东西比200多很多，就没有了意义；</p><p>其次就是还有找到相应的物品是那些；</p><pre><code>/** * 双十一凑单 * @param items * @param n * @param w */public static void double11advance(int[] items,int n,int w){    boolean[][] states = new boolean[n][3*w+1];    states[0][0] = true;    if(items[0] &lt;= 3*w){        states[0][items[0]] = true;    }    for(int i = 1; i &lt; n; i++){        for(int j = 0; j &lt;= 3*w;j++){            if(states[i-1][j]) {                states[i][j] = states[i-1][j];            }        }        for(int j = 0; j &lt; 3*w-items[i]; j++){            if(states[i-1][j]){                states[i][j+items[i]] = true;            }        }    }    int j;    for(j = w; j &lt; 3*w+1;j++){ //从w开始，输出结果大于w的最小值        if(states[n-1][j]){            break;        }    }    if(j == 3*w+1) return;//没有可行解    for(int i = n-1;i &gt;= 1;--i){        if(j-items[i] &gt;= 0 &amp;&amp; states[i-1][j-items[i]]){            System.out.println(items[i] + &quot; &quot;);            j = j-items[i];        }    }    if(j != 0){        System.out.println(items[0]);    }}</code></pre><p>状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states[i-1][j]或者 states[i-1][j-value[i]]是否是 true。</p><p>如果 states[i-1][j]可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>杨辉三角；<br>我们现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。</p><p>假设你站在第一层，往下移动，我们把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。</p><p><img src="/2020/06/16/初识动态规划/杨辉三角.jpg" alt="杨辉三角"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初识动态规划：如何解决双十一购物时的凑单问题&quot;&gt;&lt;a href=&quot;#初识动态规划：如何解决双十一购物时的凑单问题&quot; class=&quot;headerlink&quot; title=&quot;初识动态规划：如何解决双十一购物时的凑单问题&quot;&gt;&lt;/a&gt;初识动态规划：如何解决双十一购物时的凑单
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划中：理论</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/动态规划理论/</id>
    <published>2020-06-16T13:59:01.000Z</published>
    <updated>2020-06-16T14:04:45.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"><a href="#动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题" class="headerlink" title="动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题"></a>动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</h1><p>什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是怎样的？贪心、分治、回溯、动态规划这四种算法思想的区别和联系？</p><h2 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h2><p>什么样的问题适合用动态规划来解决呢？<br>什么是<strong>一个模型</strong>？它指的是动态规划适合解决的问题的模型，这个模型可以称之为“<strong>多阶段决策最优解模型</strong>”；</p><p>一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><p>什么是<strong>三个特征</strong>，分别是<strong>最优子结构、无后效性和重复子问题</strong></p><h3 id="1、最优子问题"><a href="#1、最优子问题" class="headerlink" title="1、最优子问题"></a>1、最优子问题</h3><p>最优子结构是指，问题的最优解包含子问题的最优解。反过来我们可以通过子问题的最优解，推导出来问题的最优解。通俗的理解就是后面阶段的状态可以通过前面阶段的状态推导出来；</p><h3 id="2、无后效性"><a href="#2、无后效性" class="headerlink" title="2、无后效性"></a>2、无后效性</h3><p>无后效性两层含义，第一层含义是，在推导后面阶段的问题时，我们只关心前面阶段的状态值，不关系这个状态是怎么一步一步推导出来的，第二层含义就是，某个阶段状态一旦确定，就不受之后阶段的决策影响；</p><h3 id="3、重复子问题"><a href="#3、重复子问题" class="headerlink" title="3、重复子问题"></a>3、重复子问题</h3><p>简单来说就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态；</p><h2 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h2><p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p><p><img src="/2020/06/16/动态规划理论/棋盘最短路径.jpg" alt="棋盘最短路径"></p><p>从(0,0)走到(n-1, n-1)，总共要走 2<em>(n-1) 步，也就对应着 2</em>(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p><p>我们把状态定义为min_dist(i,j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。（多阶段决策最优解，符合动态模型的问题）；</p><p><img src="/2020/06/16/动态规划理论/棋盘最短路径阶段分析.jpg" alt="棋盘最短路径阶段分析"></p><p>这时候再看问题是否符合三个特征：</p><p>使用回溯法，画出递归图之后，会发现有重复节点，这说明到达节点对应的位置，有多种路线，说明这个问题存在重复子问题；</p><p><img src="/2020/06/16/动态规划理论/棋盘最短路径重复子问题.jpg" alt="棋盘最短路径重复子问题"></p><p>走到(i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态；这就是所谓的前面阶段的状态确定下来之后，不会被后面阶段的决策所改变，这就是无后效性；</p><p>上述的我们只能由两个位置到达(i,j)，所以min_dist(i,j)必定是从min_dist(i-1,j)和min_dist(i,j-1)推导过来，这就说明这个问题符合最优子结构；</p><pre><code>min_dist(i,j) = w[i][j] + min(min_dist(i-1,j),min_dist(i,j-1));</code></pre><h2 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h2><p>状态转移表法 和 状态转移方程法；</p><h3 id="1、状态转移表法"><a href="#1、状态转移表法" class="headerlink" title="1、状态转移表法"></a>1、状态转移表法</h3><p>我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决；</p><p>找到重复子问题之后，两种思路，第一种是：<strong>回溯算法加备忘录的方法</strong>，避免重复子问题，从执行效率上这种方法和动态规划思路已经没有差别了，第二种是<strong>状态转移表法；</strong></p><p>状态转移表法，先画出一个状态表，状态表一般都是二维的，可以想象成二维数组，其中每个状态表示三个量，行列值以及数组值；决策的过程就是填充状态表的过程；</p><pre><code>private int minDist = Integer.MIN_VALUE;/** * 回溯算法求最短距离 * @param i 第i行 * @param j 第j列 * @param dist 到此的最短距离 * @param w 棋盘 * @param n 最后目的 */public void minDistBT(int i,int j,int dist,int[][] w,int n){    if(i == n &amp;&amp; j == n){        if(dist &lt; minDist){            minDist = dist;            return;        }    }    if(i &lt; n){//往下走        minDistBT(i + 1,j,dist+w[i][j],w,n);    }    if(j &lt; n){//往右走        minDistBT(i,j+1,dist+w[i][j],w,n);    }}</code></pre><p>上述代码画成递归树之后，一个状态包括三个量(i,j,dist),其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。</p><p>图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了。</p><p><img src="/2020/06/16/动态规划理论/棋盘最短路径递归树.jpg" alt="棋盘最短路径递归树"></p><p>使用动态规划，我们先画一个二维状态，图表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。</p><p><img src="/2020/06/16/动态规划理论/棋盘最短路径状态转移图1.jpg" alt="棋盘最短路径状态转移图1"></p><p><img src="/2020/06/16/动态规划理论/棋盘最短路径状态转移图2.jpg" alt="棋盘最短路径状态转移图2"></p><p>将上述过程中的填表过程翻译成代码就是：</p><pre><code>/** * 动态规划求距离 * @param matrix 棋盘 * @param n 要求位置 * @return */public int minDistDP(int[][] matrix,int n){    int[][] states = new int[n][n];    int sum = 0;    for(int j = 0; j &lt; n; j++){        sum += matrix[0][j];        states[0][j] = sum;    }    sum = 0;    for(int i = 0; i &lt; n; i++){        sum += matrix[i][0];        states[i][0] = sum;    }    for(int i = 1; i &lt; n; i++){        for(int j = 1; j &lt; n; j++){            states[i][j] = matrix[i][j] + Math.min(states[i][j - 1],states[i - 1][j]);        }    }    return states[n-1][n-1];}</code></pre><h3 id="2、状态转移方程法"><a href="#2、状态转移方程法" class="headerlink" title="2、状态转移方程法"></a>2、状态转移方程法</h3><p>上述转移方程法有点类似递归的方法，个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。</p><pre><code>min_dist(i,j) = w[i][j] + min(min_dist(i-1,j),min_dist(i,j-1));</code></pre><p>状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单</p><pre><code>private int[][] matrix = {{1,3,5,9},{2,1,3,4},{5,2,6,7},{6,8,4,3}};private int n = 4;private int[][] mem = new int[n][n];public int minDistDP1(int i,int j){    if(i == 0 &amp;&amp; j == 0){        return matrix[0][0];    }    if(mem[i][j] &gt; 0) return mem[i][j];    int minLeft = Integer.MAX_VALUE; //便于比较,使用最大值    if(j - 1 &gt;= 0){        minLeft = minDistDP1(i,j-1);    }    int minUp = Integer.MAX_VALUE;    if(i - 1 &gt;= 0){        minUp = minDistDP1(i-1,j);    }    int currMinDist = matrix[i][j] + Math.min(minLeft,minUp);    mem[i][j] = currMinDist;    return currMinDist;}</code></pre><p>不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。</p><h2 id="四种算法思想比较"><a href="#四种算法思想比较" class="headerlink" title="四种算法思想比较"></a>四种算法思想比较</h2><p>贪心，回溯，动态规划可以归为一类，而分治单独一类。<br>前三个算法解决问题的模型可以抽象成今天所讲的多阶段决策最优解模型，而分治算法解决的问题尽管大部分是最优解问题，大部分都不能抽象层多阶段决策模型；</p><p>回溯算法是个万金油，基本上贪心算法和动态规划能解决的问题我们都可以回溯算法解决，回溯算法相当于穷举算法，穷举所有的情况，对比得到最优解，大规模数据量的时候，回溯算法解决的执行效率太低；</p><p>尽管动态规划比回溯算法高效，但是不是所有问题都可以用动态规划解决。能用动态规划的需要满足三个特征，最优子结构，无后效性和重复子问题，再重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。<br>贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择；</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>一个模型”指的是，问题可以抽象成分阶段决策最优解模型。“三个特征”指的是最优子结构、无后效性和重复子问题。</p><p>状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。</strong></p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>硬币找零问题，我们在贪心算法那一节中讲过一次。我们今天来看一个新的硬币找零问题。假设我们有几种不同币值的硬币 v1，v2，……，vn（单位是元）。如果我们要支付 w 元，求最少需要多少个硬币。比如，我们有 3 种不同的硬币，1 元、3 元、5 元，我们要支付 9 元，最少需要 3 个硬币（3 个 3 元的硬币）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题&quot;&gt;&lt;a href=&quot;#动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题&quot; class=&quot;headerlink&quot; title=&quot;动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划下：实战</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/动态规划实战/</id>
    <published>2020-06-16T13:59:01.000Z</published>
    <updated>2020-06-16T14:06:32.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划实战：如何实现搜索引擎中的拼写纠错功能？"><a href="#动态规划实战：如何实现搜索引擎中的拼写纠错功能？" class="headerlink" title="动态规划实战：如何实现搜索引擎中的拼写纠错功能？"></a>动态规划实战：如何实现搜索引擎中的拼写纠错功能？</h1><p>Trie树那一节讲述的是实现搜索引擎的关键词提示，但是很多时候搜索的时候，会输错单词，搜索引擎会非常智能的检测出你的拼写错误，并且用对应的正确单词来进行搜索；</p><h2 id="如何量化两个字符的相似度"><a href="#如何量化两个字符的相似度" class="headerlink" title="如何量化两个字符的相似度"></a>如何量化两个字符的相似度</h2><p>编辑距离（Edit distance）；</p><p>编辑距离就是将一个字符串转化成另一个字符串需要的最小编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p><p>两种计算方式：<strong>莱文斯坦距离和最长公共子串长度</strong>，莱文斯坦距离允许增加，删除，替换字符三个操作，最长子串长度只允许增加，删除字符这两个编辑操作；</p><p>莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小</p><p>两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。</p><p><img src="/2020/06/16/动态规划实战/编辑距离.jpg" alt="编辑距离"></p><h2 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h2><p>这个问题是把一个字符串变成另一字符串，需要的最少编辑次数，整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每一个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话如何处理，所以这个问题是符合多阶段决策最优模型的；</p><p>先用最简单的回溯算法，如何解决呢？</p><p>回溯是一个递归处理的过程，如果a[i]与b[j]匹配，我们考察a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：</p><ol><li>可以删除a[i],然后递归考察a[i+1]和b[j];</li><li>可以删除b[j],然后递归考察a[i]和b[j+1];</li><li>可以在a[i]之前添加一个与b[j]相同的字符，继续考察a[i]和b[j+1];</li><li>可以在b[j]之前添加一个与a[i]相同的字符，继续考察a[i+1]和b[j];</li><li>可以将a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。</li></ol><p>所以实现的代码是：</p><pre><code>/** * 回溯算法求编辑距离 * @param i * @param j * @param edist */public void lwstBT(int i,int j,int edist){    if(i == n || j == m){        if(i &lt; n) {            edist += (n-i);        }        if(j &lt; m) {            edist += (m - j);        }        if(edist &lt; minDist) {            minDist = edist;            return;        }    }    if(a[i] == b[j]){        lwstBT(i+1,j+i,edist);    }else{        lwstBT(i+1,j,edist+1);// 删除a[i]或者b[j]前添加一个字符        lwstBT(i,j+1,edist+1);// 删除b[j]或者a[i]前添加一个字符        lwstBT(i+1,j+1,edist+1);// 将a[i]和b[j]替换为相同字符    }}</code></pre><p>然后画出相应的递归树为：</p><p><img src="/2020/06/16/动态规划实战/编辑距离递归树.jpg" alt="编辑距离递归树"></p><p>在节点中，每个节点代表一个状态，状态包含三个变量(i,j,edist)，其中edist表示处理到a[i]和b[j]时，已经执行的编辑操作的次数。</p><p>在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p><p><img src="/2020/06/16/动态规划实战/编辑距离状态转移方程.jpg" alt="编辑距离状态转移方程"></p><pre><code>如果a[i] != b[j],那么min_dist(i,j)等于：min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)如果：a[i] == b[j]，那么：min_edist(i, j)就等于：min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))</code></pre><p>按照上述转移方程画出相应的转移状态图：<br><img src="/2020/06/16/动态规划实战/编辑距离状态转移表.jpg" alt="编辑距离状态转移表"></p><pre><code>/** * 动态规划求编辑距离 * @param a * @param n * @param b * @param m * @return */public int lwstDP(char[] a,int n,char[] b,int m){    int[][] minDist = new int[n][m];    for(int j = 0; j &lt; m; j++){        if(a[0] == b[j]){            minDist[0][j] = j;        }else if(j != 0){            minDist[0][j] = minDist[0][j-1] + 1;        }else {            minDist[0][j] = 1;        }    }    for(int i = 0; i &lt; n; i++){        if(a[i] == b[0]){            minDist[i][0] = i;        }else if(i != 0) {            minDist[i][0] = minDist[i-1][0] + 1;        }else{            minDist[i][0] = 1;        }    }    for(int i = 1; i &lt; n; i++){        for(int j = 1;j &lt; m; j++){            if(a[i] == b[j]) {                minDist[i][j] = min(minDist[i-1][j] + 1,minDist[i][j-1]+1, minDist[i-1][j-1]);            }else {                minDist[i][j] = min( minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);            }        }    }    return minDist[n-1][m-1];}private int min(int x, int y, int z) {     int minv = Integer.MAX_VALUE;     if (x &lt; minv) minv = x;     if (y &lt; minv) minv = y;     if (z &lt; minv) minv = z;     return minv;}</code></pre><p>当我们拿到一个问题的时候，<strong>我们可以先不思考，计算机会如何实现这个问题，而是单纯考虑“人脑”会如何去解决这个问题</strong>；<br>我们可以实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决。</p><h2 id="如何编辑计算最长公共子串长度呢？"><a href="#如何编辑计算最长公共子串长度呢？" class="headerlink" title="如何编辑计算最长公共子串长度呢？"></a>如何编辑计算最长公共子串长度呢？</h2><p>只允许增加、删除字符两种编辑操作。从名字上，你可能觉得它看起来跟编辑距离没什么关系。实际上，从本质上来说，它表征的也是两个字符串之间的相似程度。</p><p>每个状态还是包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。那 (i, j) 这个状态都是由哪些状态转移过来的呢？</p><ol><li>如果 a[i]与 b[j]互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</li><li>如果 a[i]与 b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</li><li>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</li><li>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</li></ol><p>如果我们要求 a[0…i]和 b[0…j]的最长公共长度 max_lcs(i, j)，我们只有可能通过下面三个状态转移过来</p><ol><li>(i-1, j-1, max_lcs)，其中 max_lcs 表示 a[0…i-1]和 b[0…j-1]的最长公共子串长度；</li><li>(i-1, j, max_lcs)，其中 max_lcs 表示 a[0…i-1]和 b[0…j]的最长公共子串长度；</li><li>(i, j-1, max_lcs)，其中 max_lcs 表示 a[0…i]和 b[0…j-1]的最长公共子串长度。</li></ol><p>状态转移方程是：</p><pre><code>如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；</code></pre><p>代码实现是：</p><pre><code>public int lcs(char[] a, int n, char[] b, int m) {int[][] maxlcs = new int[n][m];for (int j = 0; j &lt; m; ++j) {//初始化第0行：a[0..0]与b[0..j]的maxlcs    if (a[0] == b[j]) maxlcs[0][j] = 1;    else if (j != 0) maxlcs[0][j] = maxlcs[0][j-1];    else maxlcs[0][j] = 0;}for (int i = 0; i &lt; n; ++i) {//初始化第0列：a[0..i]与b[0..0]的maxlcs    if (a[i] == b[0]) maxlcs[i][0] = 1;    else if (i != 0) maxlcs[i][0] = maxlcs[i-1][0];    else maxlcs[i][0] = 0;}for (int i = 1; i &lt; n; ++i) { // 填表    for (int j = 1; j &lt; m; ++j) {    if (a[i] == b[j]) maxlcs[i][j] = max(        maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);    else maxlcs[i][j] = max(        maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]);    }}return maxlcs[n-1][m-1];}private int max(int x, int y, int z) {    int maxv = Integer.MIN_VALUE;    if (x &gt; maxv) maxv = x;    if (y &gt; maxv) maxv = y;    if (z &gt; maxv) maxv = z;    return maxv;}</code></pre><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p><p>针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种。</p><ol><li>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</li><li>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。</li><li>我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</li><li>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</li></ol><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划实战：如何实现搜索引擎中的拼写纠错功能？&quot;&gt;&lt;a href=&quot;#动态规划实战：如何实现搜索引擎中的拼写纠错功能？&quot; class=&quot;headerlink&quot; title=&quot;动态规划实战：如何实现搜索引擎中的拼写纠错功能？&quot;&gt;&lt;/a&gt;动态规划实战：如何实现搜索引
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E6%8E%92%E5%BA%8F/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/排序/</id>
    <published>2020-06-16T13:57:52.000Z</published>
    <updated>2020-06-16T13:58:10.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？"><a href="#上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？" class="headerlink" title="上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？"></a>上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？</h2><p>最经典、最常用的排序：冒泡排序，插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。<br><img src="/2020/06/16/排序/常见排序算法复杂度.jpg" alt="常见排序算法复杂度"></p><h2 id="思考题：插入排序和冒泡排序的时间复杂度相同，都是-O-n2-，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？"><a href="#思考题：插入排序和冒泡排序的时间复杂度相同，都是-O-n2-，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？" class="headerlink" title="思考题：插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？"></a>思考题：插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</h2><h2 id="如何分析一个排序算法"><a href="#如何分析一个排序算法" class="headerlink" title="如何分析一个排序算法"></a>如何分析一个排序算法</h2><p><strong>算法的执行效率</strong><br><strong>1、最好情况、最坏情况。平均情况时间复杂度</strong><br>处理上述复杂度，还有说出具体什么情况的原始数据会导致这种情况<br>我们要知道排序算法在不同数据中的性能表现</p><p><strong>2、时间复杂度的系数、常阶、低阶</strong><br>对统一阶时间复杂度的排序算法性能对比的时候，我们吧系数、常数、低阶也要考虑进来</p><p><strong>3、比较次数和交换(或交换)次数</strong><br>基于比较的排序算法的执行过程，会设计两种操作，一种是元素比较大小，另一种是元素交换或移动，在分析算法的时候应该将比较和移动次数考虑进去</p><p><strong>排序算法的内存消耗</strong><br>算法的内存消耗可以使用空间复杂度来衡量。<br>原地排序，特指空间复杂度是O(1)的排序算法。</p><p><strong>排序算法的稳定性</strong><br>稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据。<br>每次对相邻两个元素进行比较，之后跟前判断进行交换。<br>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p>我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：<br><img src="/2020/06/16/排序/冒泡过程.jpg" alt="冒泡过程"><br>优化的冒泡排序，增加一个flag，判断是否存在数据交换，如果存在则没有排序完成，反之完成<br><img src="/2020/06/16/排序/是否有交换冒泡.jpg" alt="是否有交换冒泡"></p><p>具体的冒泡排序：</p><pre><code>/** * 冒泡排序，第一层控制冒泡次数，第二层控制相邻元素之间的交换。 * @param a */public static void bubbleSort(int[] a){    if(a.length &lt;= 1){        return;    }    for(int i = 0; i &lt; a.length;i++){ //控制冒泡次数        boolean flag = false; //增加判断条件，如果已经排序好了及时停止。        for(int j = 0; j &lt; a.length - i -1; j++){            if(a[j] &gt; a[j+1]){ //只有a[j] &gt; a[j+1]才会交换位置，等于是不加交换的，保证稳定性                int temp = a[j];                a[j] = a[j+1];                a[j+1] = temp;                flag = true;            }        }        if(!flag) break;    }}</code></pre><p>三个问题：<br><strong>冒泡排序是否是原地排序算法？</strong><br>只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p><p><strong>冒泡排序是稳定的排序算法吗？</strong><br>当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p><p><strong>冒泡排序的时间复杂度是多少？</strong><br>最好情况是O(n),此时数据已经有序，只需做一次冒泡操作；<br>最坏情况是O(n^2),此时数据刚好事倒序，需要做n次冒泡操作；</p><p>平均时间复杂度，通过“有序度”和“逆序度”两个概念来进行分析：<br><strong>有序度</strong>是数组中具有有序关系的元素对的个数。</p><pre><code>有序元素对：a[i] &lt;= a[j], 如果i &lt; j。</code></pre><p><img src="/2020/06/16/排序/有序度.jpg" alt="有序度"></p><p>对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。</p><p>逆序度的定义正好跟有序度相反（默认从小到大为有序）</p><pre><code>逆序元素对：a[i] &gt; a[j], 如果i &lt; j。</code></pre><p><strong>逆序度 = 满有序度 - 有序度</strong></p><p>如果那一开始那个冒泡例子来看<br><img src="/2020/06/16/排序/冒泡过程有序度.jpg" alt="冒泡过程有序度"></p><p>冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1<br>交换次数总是确定的，即为逆序度，也就是n<em>(n-1)/2–初始有序度。<br>最坏情况下，初始状态的有序度是 0，所以要进行 n</em>(n-1)/2 次交换。最好情况下，初始状态的有序度是 n<em>(n-1)/2，就不需要进行交换。我们可以取个中间值 n</em>(n-1)/4。</p><p>换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p><img src="/2020/06/16/排序/插入排序.jpg" alt="插入排序"></p><p>一种是元素的比较，一种是元素的移动；<br>移动操作的次数总是固定的等于逆序度；<br><img src="/2020/06/16/排序/移动元素个数.jpg" alt="移动元素个数"></p><p>具体代码：</p><pre><code>/** * 插入排序 * @param a */public static void insertionSort(int[] a){    for(int i = 1; i &lt; a.length; i++){        int value = a[i]; //记录数据，防止在数据移动过程中被覆盖        int j = i - 1; //记录空位，即插入位置，在最后可以直接插入        for(; j &gt;= 0; j--){            if(a[j] &gt; value){                a[j+1] = a[j];            }else {                break;            }        }        a[j+1] = value;    }}</code></pre><p>三个问题：<br><strong>冒泡排序是否是原地排序算法？</strong><br>不需要额外的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p><p><strong>冒泡排序是稳定的排序算法吗？</strong><br>我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><p><strong>冒泡排序的时间复杂度是多少？</strong><br>最好情况是O(n),此时数据已经有序<br>最坏情况是O(n^2),此时数据刚好是倒序，每次插入都相当于在数组的第一个位置插入新的数据；<br>平均复杂度：数组插入的复杂度是O(n),但是插入排序相等于执行了n次插入操作，平均复杂度是O(n^2)</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。<br><img src="/2020/06/16/排序/选择排序原理.jpg" alt="选择排序原理"></p><p>选择排序空间复杂度为 O(1)，是一种原地排序算法。<br>选择排序是一种不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p><p>代码：</p><pre><code>/** * 选择排序 * @param a */public static void selectionSort(int [] a){    for(int i = 0; i &lt; a.length; i++){//遍历数组中所有的位置        int min = i;//默认该位置上的现有的数就是未排序区最小的        for(int j = i + 1; j &lt; a.length;j++){//向后遍历            if(a[j] &lt; a[min]){ //找出更小的数                min = j; //记录下标            }        }        int temp = a[i];  //交换位置        a[i] = a[min];        a[min] = temp;    }}</code></pre><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。<br>插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p><p>从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：</p><pre><code>冒泡排序中数据的交换操作：if (a[j] &gt; a[j+1]) { // 交换    int tmp = a[j];    a[j] = a[j+1];    a[j+1] = tmp;    flag = true;}插入排序中数据的移动操作：    if (a[j] &gt; value) {    a[j+1] = a[j];  // 数据移动    } else {    break;}</code></pre><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><h2 id="冒泡，插入，选择排序小结"><a href="#冒泡，插入，选择排序小结" class="headerlink" title="冒泡，插入，选择排序小结"></a>冒泡，插入，选择排序小结</h2><p><img src="/2020/06/16/排序/冒泡_插入_选择小结.jpg" alt="冒泡_插入_选择小结"> </p><h1 id="排序下篇：如何使用快排思想在O-n-内查找第K大元素"><a href="#排序下篇：如何使用快排思想在O-n-内查找第K大元素" class="headerlink" title="排序下篇：如何使用快排思想在O(n)内查找第K大元素"></a>排序下篇：如何使用快排思想在O(n)内查找第K大元素</h1><p>今天讲述两种时间复杂度是O(nlogn)的排序算法，归并排序和快速排序。两者都用到了分治思想<br><strong>开篇题目：如何在O(n)的时间复杂度中查找一个无序数组中的第K大的元素？</strong></p><h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>具体的原理图如下：<br><img src="/2020/06/16/排序/归并排序原理图.jpg" alt="归并排序原理图"></p><p>分治思想，分而治之，将大问题化解为小问题来解决</p><p>分治算法一般都是用递归来实现的，分治是一种思想，递归时编程技巧。</p><p>如何使用递归代码来实现归并排序</p><pre><code>//归并排序算法，A是数组，n表示数组大小merge_sort(A,n){    merge_sort_c(A,0,n-1)}//递归调用函数merge_sort_c(A,p,r){    //递归终止条件    if p &gt;= r then return    //取p到r之间中间位置q    q = (p+r)/2    //分治递归    merge_sort_c(A,p,q)    merge_sort_c(A,q+1,r)    //将A[p...q]和A[q+1...r]合并为A[p...r]    merge(A[p...r],A[p...q],A[q+1...r])}  </code></pre><p>merge(A[p…r],A[p…q],A[q+1…r])函数的作用是，将已经有序的A[p…q]和A[q+1…r]合并成一个有序的数组，并且放入A[p…r]</p><p>我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。<br>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r] 中。</p><p><img src="/2020/06/16/排序/merge.jpg" alt="merge"></p><p>代码实现：</p><pre><code>/** * 归并排序 * @param a */public static void mergeSort(int[] a){    //调用    mergeSortC(a,0,a.length-1);}/** * 递归函数实现分而治之这个过程 * @param a * @param start * @param end */public static void mergeSortC(int[] a,int start,int end){    //判断是否此时只有一个元素，递归终止条件    if(start &gt;= end){        return;    }    //找到数组中间元素下标    int mid = (start + end)/2;    //递归左分    mergeSortC(a,start,mid);    //递归右分    mergeSortC(a,mid+1,end);    //两者合并    merge(a,start,mid,end);}/** * 将两个分开的数组合并成一个数组，放回原数组位置 * @param a * @param left * @param mid * @param right */public static void merge(int[] a,int left,int mid,int right){    int[] tmp = new int[a.length];    int p1 = left;    int p2 = mid + 1;    int k = left;    //数据比较，放入新的暂存空间    while(p1 &lt;= mid &amp;&amp; p2 &lt;= right){        if(a[p1] &lt;= a[p2]){            tmp[k++] = a[p1++];        }else{            tmp[k++] = a[p2++];        }    }    //将有剩余的数组全部放到暂存数组最后    while (p1 &lt;= mid){        tmp[k++] = a[p1++];    }    while (p2 &lt;= right){        tmp[k++] = a[p2++];    }    //数组拷贝回原来数组    for(int i = left;i &lt;= right; i++){        a[i] = tmp[i];    }}</code></pre><h2 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h2><p>第一、归并排序是稳定的排序算法，只要在merge函数中保证稳定就可以实现稳定<br>第二、归并排序的时间复杂度是多少？<br>    问题a可以分解为问题b，c求解a就变成了求解b,c,最后得出这样的递推关系<br>    T(a) = T(b) + T(c) + K<br>    K等于问题b，c的结果合并成问题a的结果所消耗的时间<br>    不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</p><pre><code>T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。T(n) = 2*T(n/2) + n； n&gt;1T(n) = 2*T(n/2) + n      = 2*(2*T(n/4) + n/2) + n      = 4*T(n/4) + 2*n      = 4*(2*T(n/8) + n/4) + 2*n      = 8*T(n/8) + 3*n      = 8*(2*T(n/16) + n/8) + 3*n      = 16*T(n/16) + 4*n      ......      = 2^k * T(n/2^k) + k * n</code></pre><p>我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。<br>我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。</p><p>第三、归并排序的空间复杂度是多少<br>    一个致命的“弱点”，那就是归并排序不是原地排序算法。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p><h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p>快排的思想是这样的：如果在排序数组中下标从p到r之间的一组数据，我们选择p到r之间任意一个数据作为pivot（分区点）</p><p>我们遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放在右边，将pivot放到中间。<br>经过这个步骤之后，数组p到r之间的数据就被分成三个部分。<br><img src="/2020/06/16/排序/快排分区.jpg" alt="快排分区"><br>根据分治、递归的处理思想，我们将递归小标从p到q-1之间的数据和下标从q+1到r之间的数据，直至区间缩小到1，就说明所有的数据都有序了</p><pre><code>递推公式：quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1...r)终止条件：p &gt;= r</code></pre><p>递归伪代码：</p><pre><code>//快速排序，A是数组，n是数组大小quick_sort(A,n){    quick_sort_c(A，0，n-1)}//快速排序递归函数，p，r为下标quick_sort_c(A,p,r) {    if p &gt;= r then return    q = partition(A,p,r)    quick_sort_c(A,p,q-1)    quick_sort_c(A,q+1,r)}</code></pre><p>partition() 分区函数。随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r] 分区，函数返回 pivot 的下标。</p><pre><code>partition(A, p, r) {    pivot := A[r]    i := p    for j := p to r-1 do {        if A[j] &lt; pivot {        swap A[i] with A[j]        i := i+1        }    }    swap A[i] with A[r]return i</code></pre><p>实现代码：</p><pre><code>/** * 快速排序 * @param a */public static void quickSort(int[] a){    //调用递归函数    quickSortC(a,0,a.length-1);}/** * 递归实现分区过程 * @param a * @param start * @param end */public static void quickSortC(int[] a,int start,int end){    if(start &gt;= end){        return;    }    int mid = partition(a,start,end);    quickSortC(a,start,mid-1);    quickSortC(a,mid+1,end);}/** * 将排序分区 * @param a * @param start * @param end * @return */public static int partition(int[] a,int start,int end){    //默认最后一个元素是分界区元素    int pivot = a[end];    //i为开始的元素    int i = start;    //j从开始一直到倒数第二个元素    for(int j = start; j &lt; end;j++){        //如果a[j]小于分界点元素，将a[j]放到已处理区间末尾，也就是a[i]处，i往后挪        if(a[j] &lt; pivot){            int tmp = a[i];            a[i] = a[j];            a[j] = tmp;            i = i+1;        }    }    //循环完毕后，将默认的最后一个元素也就是分界点与a[i]交换    int tmp = a[i];    a[i] = a[end];    a[end] = tmp;    return i;}</code></pre><p>快排是原地排序算法，具体就是通过游标i将A[p…r-1]分为两部分。A[p…i-1]的元素都是pivot的，我们暂且叫已处理区间，A[i…r-1]是未处理区间。我们每次都从未处理区间中取一个元素A[j]，与pivot对比，如果小于pivot将其加入到已处理区间的尾部，也就是A[i]的位置。只需要将 A[i] 与 A[j] 交换，就可以在 O(1) 时间复杂度内将 A[j] 放到下标为 i 的位置。</p><p><img src="/2020/06/16/排序/分区.jpg" alt="分区"></p><p>分区过程中涉及到交换操作，所以快速排序并不是一个稳定的排序算法。<br><img src="/2020/06/16/排序/归并和快排区别.jpg" alt="归并和快排区别"></p><p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p><p>归并排序虽然是稳定的，非原地排序算法。<br>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h2 id="快排的性能分析"><a href="#快排的性能分析" class="headerlink" title="快排的性能分析"></a>快排的性能分析</h2><p>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)</p><p>一个是分区极其均衡，一个是分区极其不均<br>T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。</p><h2 id="解答开篇-1"><a href="#解答开篇-1" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>求第K大元素<br>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p><p>如果 p+1=K，那 A[p] 就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K</p><p><img src="/2020/06/16/排序/K大.jpg" alt="K大"></p><p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</p><p>先构建十条io流，分别指向十个文件，每条io流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的io流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，io流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较n次，每次比较选出一条数据来写入，时间复杂度是O（n），空间复杂度是O（1）,几乎不占用内存，这是我想出的认为最好的操作了。</p><h1 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h1><p>三种时间复杂度是O(n)的排序算法：桶排序、计数排序、基数排序，这些排序算法复杂度是线性的，所以称之为线性排序。之所以可以做到线性排序，主要原因是非基于比较的排序算法。</p><p>重点是掌握这些排序算法的适用场景；<br>如何根据年龄给100万用户排序？</p><h2 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h2><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据单独排序，桶内排完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="/2020/06/16/排序/桶排序.jpg" alt="桶排序"></p><p>桶排序的时间复杂度是O(n)，如果排序的数据有n个，我们把它们均匀的划分到m个桶内，每个桶里就有k=n/m个元素。每个桶内使用快速排序，时间复杂度为O(k <em> logk) 。m个桶内时间表复杂度就是O(m </em> k <em> logk)，又因为k=n/m，所以整个桶排序的时间就变成了O(n</em>log(n/m)),当桶的个数m接近个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。</p><p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong><br>不可以，桶排序对要排序数据的要求是非常苛刻的<br>首先数据要很容易划分为m个桶，并且桶与桶之间有着天然的大小顺序，其次数据在各个桶之间分布式比较均匀的。<br>桶排序比较适合在外部排序中，所谓外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>/** * 桶排序 * @param a * @param bucketSize */public static void bucketSort(int[] a, int bucketSize){    if(a.length &lt;= 1){        return;    }    //寻找最大最小值    int min = a[0];    int max = a[0];    for (int i = 0; i &lt; a.length;i++){        if(min &gt; a[i]){            min = a[i];        }else if(max &lt; a[i]){            max = a[i];        }    }    //计算桶间隔    int bucketCount = (max - min) / bucketSize + 1;    //创建二维数组做桶    int[][] buckets = new int[bucketCount][bucketSize];    //存储每个桶中元素个数    int[] indexArr = new int[bucketCount];    //遍历所有数据将数据放入不同的桶中    for(int i = 0; i &lt; a.length;i++){        int bucketIndex = (a[i] - min) / bucketSize;        //扩容        if(indexArr[bucketIndex] == buckets[bucketIndex].length){            ensureCapacity(buckets,bucketIndex);        }        buckets[bucketIndex][indexArr[bucketIndex]++] = a[i];    }    int k = 0;    for(int i = 0; i &lt; buckets.length;i++) {        if (indexArr[i] == 0) {            continue;        }        //桶内元素快排        quickSortC(buckets[i], 0, indexArr[i] - 1);        //元素复制到原数组中        for (int j = 0; j &lt; indexArr[i]; j++) {            a[k++] = buckets[i][j];        }    }}/** * 数组扩容 * @param buckets * @param bucketIndex */public static void ensureCapacity(int[][] buckets,int bucketIndex){    int[] tempArr = buckets[bucketIndex];    int[] newArr = new int[tempArr.length * 2];    for (int j = 0; j &lt; tempArr.length; j++) {        newArr[j] = tempArr[j];    }    buckets[bucketIndex] = newArr;}</code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>其实计数排序应该是桶排序的一种特殊情况。<br>当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><h2 id="为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？"><a href="#为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？" class="headerlink" title="为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？"></a>为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</h2><p>假设8个考生，分数在0到5之间，这8个考生成绩放在一个数组A[8]中，分别是：2,5,3,0,2,3,0,3。<br>我们使用C[6]来表示桶，其中下标表示对应分数，C[6]内存储的并不是考生，而是对应的考生个数。<br>则C[6]的值为：<br><img src="/2020/06/16/排序/C6.jpg" alt="C6"><br>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8] 中，会保存下标 4，5，6 的位置。</p><p>如何快速计算出，每个分数考生对应的存储位置呢？<br>我们对C[6]顺序求和，C[6] 存储的数据就变成了下面这样子。C[k] 里存储小于等于分数 k 的考生个数。</p><p><img src="/2020/06/16/排序/C6求和.jpg" alt="C6求和"></p><p>我们从后往前（可以保证稳定性）扫描数组A，当扫描到3的时候，我们可以从数组C中去除下标是3 的值7，到目前为止，分数小于等于3的考生有7个，也就是说3是数组R中第7个元素，当3放入数组R中，小于等于3的元素就剩6个了，所以C[3]的值减一，变成6。以此类推。<br><img src="/2020/06/16/排序/计数排序过程.jpg" alt="计数排序过程"></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><pre><code>/** * 计数排序 * 可以对数据进行变换，数据只能是非负整数 * @param a */public static void countingSort(int[] a){    if(a.length &lt;= 1){        return;    }    //寻找数据范围    int max = a[0];    for(int i = 0; i &lt; a.length; i++){        if(max &lt; a[i]){            max = a[i];        }    }    //申请一个数组c，小标是0~max    int[] c = new int[max + 1];    //计算每个元素的个数放入到c中    for(int i = 0; i &lt; a.length;i++){        c[a[i]]++;    }    //依次累加    for(int i = 1; i &lt; c.length;i++){        c[i] = c[i-1] + c[i];    }    //申请临时数组    int[] r = new int[a.length];    //计数排序，从后往前可以保证稳定性    for(int i = a.length-1; i &gt;= 0;i--){        r[c[a[i]]-1] = a[i];        c[a[i]]--;    }    //结果拷贝给数组a    for(int i = 0; i &lt; a.length; i++){        a[i] = r[i];    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合计数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的要将不改变其相对大小的情况下，转化为非负整数。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p><p>假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了</p><p>借助稳定排序算法，先按照最后一位来排序手机号码，然后再按照倒数第二位重新排序，以此类推最后按照第一位重新排序，经过11次排序之后，手机号码就都有序了。</p><p><img src="/2020/06/16/排序/基数排序示意图.jpg" alt="基数排序示意图"></p><p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p><p>单词不等长，就将所有的单词补齐到相同长度，位数不够补0。</p><p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</strong></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>/** * 基数排序 * @param arr */public static void radixSort(int[] arr) {    int max = arr[0];    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] &gt; max) {            max = arr[i];        }    }    // 从个位开始，对数组arr按&quot;指数&quot;进行排序    for (int exp = 1; max / exp &gt; 0; exp *= 10) {        countingSort(arr, exp);    }}/** * 变化的计数排序 * @param arr * @param exp */public static void countingSort(int[] arr, int exp) {    if (arr.length &lt;= 1) {        return;    }    // 计算每个元素的个数    int[] c = new int[10];    for (int i = 0; i &lt; arr.length; i++) {        c[(arr[i] / exp) % 10]++;    }    // 计算排序后的位置    for (int i = 1; i &lt; c.length; i++) {        c[i] += c[i - 1];    }    // 临时数组r，存储排序之后的结果    int[] r = new int[arr.length];    for (int i = arr.length - 1; i &gt;= 0; i--) {        r[c[(arr[i] / exp) % 10] - 1] = arr[i];        c[(arr[i] / exp) % 10]--;    }    for (int i = 0; i &lt; arr.length; i++) {        arr[i] = r[i];    }}</code></pre><h2 id="解答开篇-2"><a href="#解答开篇-2" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>根据年龄给100万用户排序，类似50万考生排序，假设年龄范围是1到120岁。遍历120万用户，将年龄划分到这120个桶内，一次遍历120个桶内的元素，就得到了按照年龄排序的120万数据。</p><p>如果数据特征比较符合这些桶排序、计数排序、基数排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。</p><h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？</p><p>利用桶排序思想，弄小写，大写，数字三个桶，遍历一遍，都放进去，然后再从桶中取出来就行了。复杂度O(n)</p><h1 id="排序优化：如何实现一个通用的高性能的排序函数"><a href="#排序优化：如何实现一个通用的高性能的排序函数" class="headerlink" title="排序优化：如何实现一个通用的高性能的排序函数"></a>排序优化：如何实现一个通用的高性能的排序函数</h1><p>排序函数如何实现的，底层是什么排序算法？</p><p><strong>如何实现一个通用的、高性能的排序函数</strong></p><h2 id="如何选择合适的排序算法"><a href="#如何选择合适的排序算法" class="headerlink" title="如何选择合适的排序算法"></a>如何选择合适的排序算法</h2><p><img src="/2020/06/16/排序/排序算法总结.jpg" alt="排序算法总结"></p><p>线性排序算法时间复杂度低，但使用场景比较特殊，写一个通用的排序函数，不能选择线性排序算法。</p><p>小规模数据排序，可以选择时间复杂度是O(n^2)的算法，如果是大规模数据进行排序，时间复杂度是O(nlogn)的算法更有效。为了兼顾任意规模，一般都会首选时间复杂度是O(nlogn)的排序算法。</p><p>堆排序和快速排序都有比较多的应用，java语言采用堆排序实现排序函数，C语言使用快速排序实现排序函数。</p><h2 id="如何优化快速排序"><a href="#如何优化快速排序" class="headerlink" title="如何优化快速排序"></a>如何优化快速排序</h2><p>快速排序的糟糕主要是因为分区点的选择不合理造成的。</p><p>最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。</p><p><strong>1、三数取中法</strong><br>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这三个数的中间值作为分区点。如果排序数组比较大，那就五数取中或者十数取中。</p><p><strong>2、随机法</strong><br>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。不能保证每次分区都是好的，但概率是不大可能每次都是很差的。</p><h2 id="举例说明排序函数"><a href="#举例说明排序函数" class="headerlink" title="举例说明排序函数"></a>举例说明排序函数</h2><p>拿 Glibc 中的 qsort() 函数举例说明一下；<br>qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。</p><p>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。</p><p>qsort() 选择分区点的方法就是“三数取中法”</p><p>递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的</p><p>在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</p><p>时间复杂度代表的是一个增长趋势，在小规模数据时候，低阶，系数，常数之间对时间的影响还是很大的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？&quot;&gt;&lt;a href=&quot;#上篇：开篇题目，为啥们插入排序比冒泡排序更受喜欢？&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分治算法</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/分治算法/</id>
    <published>2020-06-16T13:56:08.000Z</published>
    <updated>2020-06-16T13:56:22.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治算法：谈一谈大规模计算框架MapReduce中的分治思想"><a href="#分治算法：谈一谈大规模计算框架MapReduce中的分治思想" class="headerlink" title="分治算法：谈一谈大规模计算框架MapReduce中的分治思想"></a>分治算法：谈一谈大规模计算框架MapReduce中的分治思想</h1><p>MapReduce是Google大数据处理的三驾马车，另外两个是GFS和Bigtable。</p><h2 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h2><p>分治算法的本质其实只有四个字，分而治之，也就是将原问题划分成n个规模更小，并且结构与原问题相似的子问题，递归的解决这些子问题，然后在合并其结果，就能得到原问题的解；</p><p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。</p><p>在每一层递归中都会涉及这样三个操作：</p><ol><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归的求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题；</li></ol><p>分治算法能解决的问题一把满足一下这几个条件：</p><ol><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划之间明显的区别，等到动态规划再具体对比两种算法；</li><li>具有分解终止条件，也就是在问题足够小的时候可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减少算法总体复杂度的效果了；</li></ol><h2 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h2><p>计算一组数据的逆序度；</p><p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2；</p><p><img src="/2020/06/16/分治算法/逆序度.jpg" alt="逆序度"></p><p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong>因为有序对个数和逆序对个数的求解方式是类似的，所以你可以只思考逆序对个数的求解方法。</p><p>最笨的方法就是进行遍历求出整个逆序度，这样的遍历需要两重循环，时间复杂度是O(n^2);</p><p>使用分治算法来试试，我们使用分治算法的思想来求数组A的逆序度个数。我们将数组A1和A2，分别计算A1和A2的逆序对个数K1和K2，然后在计算A1与A2之间的逆序对个数K3.那数组A的逆序对个数就等于K1+K2+K3。</p><p>使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？</p><p>这个问题我们要借用归并排序算法，每次合并过程操作的时候就要计算逆序对个数，把那些计算出来的逆序对个数求和，就是整个数组的逆序对个数了；</p><p><img src="/2020/06/16/分治算法/归并排序计算逆序度过程.jpg" alt="归并排序计算逆序度过程"></p><p>代码实现：</p><pre><code>private int num = 0;/** * 逆序度计数 * @param a * @param n * @return */public int count(int[] a,int n){    num = 0;    mergeSortCounting(a,0,n-1);    return num;}/** * 归并排序，分而治之 * @param a * @param p * @param r */private void mergeSortCounting(int[] a,int p,int r){    if(p &gt;= r){        return ;    }    int q = (p + r) / 2;    mergeSortCounting(a,p,q);    mergeSortCounting(a,q+1,r);    merge(a,p,q,r);}/** * 合并过程，加逆序度计数 * @param a * @param p * @param q * @param r */private void merge(int[] a,int p,int q,int r){    int i = p,j = q + 1,k = 0;    int[] tmp = new int[r-q+1];    while(i &lt;= q &amp;&amp; j &lt;= r){        if(a[i] &lt;= a[j]){            tmp[k++] = a[i++];        }else{            num += (q - i + 1);            tmp[k++] = a[j++];        }    }    while(i &lt;= q){        tmp[k++] = a[i++];    }    while(j &lt;= r){        tmp[k++] = a[j++];    }    for(i = 0; i &lt;= r - p;i++){        a[p+i] = tmp[i];    }}</code></pre><p>关于分治算法有两道比较经典的问题，可以自己练习一下。</p><ol><li>二维平面上有n个点，如何计算出两个距离最近的点；</li><li>有两个n <em> n的矩阵A,B，如何快速求解两个矩阵的成绩 C=A </em> B</li></ol><h2 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h2><p>比如给10GB订单文件进行排序的需求，一个简单的排序问题，但因为数据量大，有10GB，也就无法直接单纯的用快排，归并算法来解决了；</p><p>要解决这种数据量大到内存装不下的问题，我们就可以合理利用分治算法，将海量数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载解决；</p><p>比如在这个订单金额排序的问题中，我们先讲数据按照金额区间进行分类，在对每个区间内的数据进行排序；</p><p>还可以将每个小区间的数据加载到不同的机器上并行处理；</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>为什么说 MapReduce 的本质就是分治思想？</p><p>那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p><p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>分治算法用四个字概括就是“分而治之”，将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解</p><p>两种分治算法的典型的应用场景，一个是用来指导编码，降低问题求解的时间复杂度，另一个是解决海量数据处理问题。比如 MapReduce 本质上就是利用了分治思想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分治算法：谈一谈大规模计算框架MapReduce中的分治思想&quot;&gt;&lt;a href=&quot;#分治算法：谈一谈大规模计算框架MapReduce中的分治思想&quot; class=&quot;headerlink&quot; title=&quot;分治算法：谈一谈大规模计算框架MapReduce中的分治思想&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/回溯算法/</id>
    <published>2020-06-16T13:54:59.000Z</published>
    <updated>2020-06-16T13:55:14.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想"><a href="#回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想" class="headerlink" title="回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想"></a>回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想</h1><p>在前面的章节中，图的深度优先搜索算法利用的就是回溯算法想，这个算法思想非常简单，但是应用很广泛，但是很多软件开发场景中都使用到了，比如正则表达式算法、编译原理中的语法分析等；</p><p>除此之外还有数独，八皇后，0-1背包问题，图的着色旅行商问题，全排列问题等等；</p><h2 id="如何理解“回溯算法”"><a href="#如何理解“回溯算法”" class="headerlink" title="如何理解“回溯算法”"></a>如何理解“回溯算法”</h2><p>笼统的讲，回溯算法很多时候都应用在搜索这类问题上，不过这里说的搜索并不是狭义的图的搜索，而是在一组可能的解中搜索满足期望的解；</p><p>回溯的处理思想，优点类似于枚举搜索，我们枚举所有的解，找到满足期望的解，为了有规律的枚举可能的解，避免遗漏和重复，我们把问题的求解过程分为很多阶段。每个阶段我们都会面对一个岔路口，我们先任意选择一条路走，当发现这条路走不通的时候，就回退到上一个岔路口，另选一条走法继续走；</p><p>一个比较经典的问题：八皇后的问题；</p><p>我们有一个8*8的棋盘，希望往里面放8个棋子，每个棋子所在的行列对角线都不能有另一个棋子。你可以看到下面的画，第一幅画就是满足条件的一种方法，第二幅就不满足条件，八皇后问题就是期望找到所有满足这种要求的放棋子方法。</p><p><img src="/2020/06/16/回溯算法/八皇后.jpg" alt="八皇后"></p><p>我们把问题分成8个阶段，依次将8个棋子放到第一行，第二行到第八行，在放置的过程中，我们不断的检查当前放法，是否满足要求，如果满足就跳到下一行继续放棋子；不满足就再换一种放法；</p><p>翻译成代码如下：</p><pre><code>//全局变量，下标代表行，值表示queen存储在那一列int[] result = new int[8];/** *调用方式 cal8queens(0) * @param row */public void cal8queens(int row){    //8个棋子都放好了    if(row == 8){        printQueens(result);        return ;    }    //每一行都有8个方法    for(int col = 0; col &lt; 8;col++){        if(isOk(row,col)){ //有些放法不满足要求            result[row] = col; //第row行的棋子放在了col行            cal8queens(row+1); //考察下一行        }    }}/** * 判断row行棋子放在col列是否合适 * @param row * @param col * @return */public boolean isOk(int row,int col){    int leftup = col - 1;    int rightup = col + 1;    for(int i = row - 1; i &gt;= 0;i--){        //考察正上方是否合适        if(result[i] == col){            return false;        }        //考察左上方是否合适        if(leftup &gt;= 0){            if(result[i] == leftup){                return false;            }        }        //考察右上方是否合适        if(rightup &lt; 8){            if(result[i] == rightup){                return false;            }        }        leftup--;        rightup++;    }    return true;}/** * 打印 * @param result */private void printQueens(int[] result){    for(int row = 0; row &lt; 8; row++){        for(int col = 0; col &lt; 8; col++){            if(result[row] == col){                System.out.print(&quot;Q &quot;);            }else{                System.out.print(&quot;* &quot;);            }        }        System.out.println();    }    System.out.println();}</code></pre><h2 id="两个回溯算法中的经典应用"><a href="#两个回溯算法中的经典应用" class="headerlink" title="两个回溯算法中的经典应用"></a>两个回溯算法中的经典应用</h2><h3 id="1、0-1背包"><a href="#1、0-1背包" class="headerlink" title="1、0-1背包"></a>1、0-1背包</h3><p>0-1背包问题有很多变体，介绍一种比较基础的，我们有一个背包，背包的总承重是Wkg，现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><p>对于每个物品来说装进背包或者不装进背包，对于n个物品总的装法就有2^n种，去掉重量超过Wkg的，从剩下的装法中选择重量最接近Wkg的。不过我们如何才能不重复的穷举这2^n种方法呢？</p><p>回溯的方法，我们将物品一次放进排列，整个问题被分解成n阶段，每个阶段对应一个物品如何选择，先对第一个物品进行处理，选择装进去或者不装进去，然后在递归的处理下面的物品；</p><p>代码如下：</p><pre><code>/** * f(0,0,a,10,100) * @param i 表示考察到那个物品了 * @param cw 表示当前已经装进去的物品总重量 * @param items 表示每个物品的重量 * @param n 表示物品个数 * @param w 背包重量 */public void f(int i,int cw,int[] items,int n,int w){    //cw == w表示装满了，i== n表示考察完所以的物品了    if(cw == w || i == n){        if(cw &gt; maxW) maxW = cw;        return;    }    f(i+1,cw,items,n,w);    // 已经超过可以背包承受的重量的时候，就不要再装了    if(cw + items[i] &lt;= w){        f(i+1,cw+items[i],items,n,w);    }}</code></pre><h3 id="2、正则表达式"><a href="#2、正则表达式" class="headerlink" title="2、正则表达式"></a>2、正则表达式</h3><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。为了方便讲解，我假设正则表达式中只包含“<em>”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“</em>”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p><p>我们依次考察正则表达式中的每个字符，当是非通配符的时候，就直接跟文本字符进行匹配，如果相同就继续往下处理，如果不相同就回溯；</p><p>如果遇到特殊字符的时候，我们就有多种处理方式，这就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就随意选择一种匹配方案，然后继续考察剩下的字符，如果中途发现无法匹配下去，我们就回到这个岔路口，重新选择一种方案，然后在继续匹配下去；</p><p>代码如下：</p><pre><code>public class Pattern {    private boolean matched = false;    private char[] pattern; //正则表达式    private int plen; //正则表达式长度    public Pattern(char[] pattern,int plen){        this.pattern = pattern;        this.plen = plen;    }    public boolean match(char[] text,int tlen){        matched = false;        rmatch(0,0,text,tlen);        return matched;    }    private void rmatch(int ti,int pj,char[] text,int tlen){        if(matched)return;        if(pj == plen){ //正则表达式结尾了            if(ti == tlen){ // 文本串也结尾了                matched = true;            }            return;        }        if(pattern[pj] == &apos;*&apos;){ //匹配任意个字符            for(int k = 0; k &lt; tlen - ti; k++){                rmatch(ti + k,pj + 1,text,tlen);            }        }else if(pattern[pj] == &apos;?&apos;){ //匹配0个或者1个字符            rmatch(ti,pj+1,text,tlen);            rmatch(ti+1,pj+1,text,tlen);        }else if(ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]){ //字符匹配才行            rmatch(ti+1,pj+1,text,tlen);        }    }}</code></pre><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>现在我们对今天讲到的 0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想&quot;&gt;&lt;a href=&quot;#回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想&quot; class=&quot;headerlink&quot; title=&quot;回溯算法：从电影蝴蝶效应中学习回溯算法的核心思想&quot;&gt;&lt;/a&gt;回溯算法：从电影蝴蝶效应中学
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/贪心算法/</id>
    <published>2020-06-16T13:53:59.000Z</published>
    <updated>2020-06-16T13:54:31.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法：如何用贪心算法实现Huffman压缩编码"><a href="#贪心算法：如何用贪心算法实现Huffman压缩编码" class="headerlink" title="贪心算法：如何用贪心算法实现Huffman压缩编码"></a>贪心算法：如何用贪心算法实现Huffman压缩编码</h1><p>几种更加基本的算法，分别是贪心算法，分治算法，回溯算法，动态规划；</p><p>贪心算法比较经典的应用，比如霍夫曼编码，Prim和Kruskal最小生成树算法，还有Dijkstra单源最短路径算法。<br><strong>霍夫曼编码是如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的</strong></p><h2 id="如何理解贪心算法呢？"><a href="#如何理解贪心算法呢？" class="headerlink" title="如何理解贪心算法呢？"></a>如何理解贪心算法呢？</h2><p>先看一个例子，假设有一个可以容纳100kg的背包，有以下5种豆子，每种豆子的总量和总价值都各不相同，如何才能让背包中的物品价值最大呢？</p><p><img src="/2020/06/16/贪心算法/物品价值表.jpg" alt="物品价值表"></p><p>实际上这个问题很简单，我们只需要算一下每个物品的单价，按照从高到低来装就好了，所以最后的结果是包中装20kg黑豆，30kg绿豆，50kg红豆；</p><p>结合上面的例子，我们来总结一下贪心算法解决问题的步骤；<br><strong>第一步，当我们看到这类问题的时候，首先要联想到贪心算法</strong>：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p><p>上述例子中，背包重量不可以超过100kg就是限制值，物品的总价值就是期望值。</p><p><strong>第二步，我们尝试看下这个问题是否可以用贪心算法解决</strong>，每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据；</p><p><strong>第三步，我们举几个例子看下贪心算法产生的结果是否最优的</strong>，大部分情况下，举几个例子就可以了，严格证明贪心算法的正确性，是比较复杂度；</p><p>实际上，用贪心算法解决问题的思路，并不总能给出最优解。<br>我来举一个例子，比如在一个有权的无向图中寻找从顶点S到顶点T的最短路径；<br><img src="/2020/06/16/贪心算法/有权无向图.jpg" alt="有权无向图"><br>按照贪心算法解出的最短路径S，A，E，T，但是实际的最短路径是S，B，D，T；</p><p>在这个问题上，贪心算法不能工作的主要原因是因为前面的选择对后面的选择是产生影响的，所以即使是我们第一步的路径最小，但是导致了后面的每一步选择都很糟糕，最终没办法解出全局最优解；</p><h2 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h2><p>掌握贪心算法的关键在于多练习，具体问题具体分析；</p><h3 id="1、分糖果"><a href="#1、分糖果" class="headerlink" title="1、分糖果"></a>1、分糖果</h3><p>有m个糖果，n个孩子，我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多，（m &lt; n)，所以糖果只能分配给一部分孩子；</p><p>糖果大小不等，这m个糖果大小分别是s1，s2，s3，……，sm，除此之外每个孩子对糖果大小的需求也是不一样的，糖果大小必须大于孩子对糖果大小的需求。假设这n个孩子对糖果大小的需求分别是g1，g2，g3，……，gn。</p><p>问题是：如何分配糖果，能尽可能的满足最多数量的孩子？</p><p>从n个孩子中，抽取一部分孩子分配糖果，让满足的孩子数量最多，这个问题的限制值是糖果个数m。</p><p>对于一个孩子来说，如果小的糖果可以满足，我们没有必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子，另一方面，对糖果大小需求小的孩子更容易满足，所以我们可以从需求更大的孩子。开始分配糖果，因为满足一个大的孩子和满足一个需求小的孩子，对我的期望值贡献是一样的；</p><p>所以最后的做法就是，我们每次从剩下的孩子中，找出堆糖果需求最小的孩子，然后发给他剩下糖果中能满足她的最小的糖果，这样的分配方案也就是满足孩子个数最多的方案；</p><h3 id="2、钱币找零"><a href="#2、钱币找零" class="headerlink" title="2、钱币找零"></a>2、钱币找零</h3><p>假设我们有1元，2元，5元，10元，20元，50元，100元面额的纸币，他们的张数分别是c1，c2，c5，c10，c20，c50，c100；我们现在要用这些钱来支付K元，最少要用多少张纸币呢？</p><p>生活中我们肯定优先使用面值最大的来支付，如果不够继续使用面值更下一点的，以此类推，最后剩下的用1元补齐；</p><p>在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币树更少，这就是一种贪心算法的解决思路；</p><h3 id="3、区间覆盖"><a href="#3、区间覆盖" class="headerlink" title="3、区间覆盖"></a>3、区间覆盖</h3><p>假设我们有n个区间，区间起始端点和结束端点分别是[l1,r1],[l2,r2],……,[ln,rn];我们从这n个区间中选出一部分区间，这部分区间满足两两不相交（端点相交不算），最多能找出多少个区间呢？</p><p><img src="/2020/06/16/贪心算法/区间覆盖.jpg" alt="区间覆盖"></p><p>这道题思路涉及比如任务调度，教师排课等；</p><p>解决思路：我们假设这n个区间中最左边的端点是lmin，最右边的端点是rmax，这个问题就相当于选择几个不相交的区间，从左到右将[lmin,rmax]覆盖上，我们按照起始端点从小到大的顺序对这n个区间排序；</p><p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更大的区间；</p><p><img src="/2020/06/16/贪心算法/区间覆盖1.jpg" alt="区间覆盖1"></p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>假设我有一个包含1000个字符的文件，每个字符占1个byte，存储这个1000字符文件就需要8000bit，那么有没有更加节省空间的存储方式呢？</p><p>假设统计发现，这1000个字符中只包含6种不同的字符，分别是a,b,c,d,e,f。而3个二进制位就可以表示8个不同的字符，所以可以用3个二进制位表示，此时只需要3000bit就可以了，还有没有更加省空间的存储方式呢？</p><p>霍夫曼编码是一种十分有效的编码方式，广泛用于数据压缩中，其中压缩率通常在20%~90%，霍夫曼编码不仅会考察文本中有多少个不同的字符，霍夫曼编码不等长，出现概率越高的字符编码越短；</p><p>为了避免歧义，霍夫曼编码要求各个字符编码之间，不可以出现摸个编码是另一个编码前缀的情况；</p><p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p><p><img src="/2020/06/16/贪心算法/霍夫曼编码.jpg" alt="霍夫曼编码"></p><p>我们把每个字符看做一个节点，并且附带着把频率放到优先级队列中，我们从队列中取出频率最小的两个节点A，B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把这个新节点C作为节点A，B的父节点，最后再把C放入优先级队列中，重复上述过程，知道队列中没有数据；</p><p><img src="/2020/06/16/贪心算法/霍夫曼编码过程.jpg" alt="霍夫曼编码过程"></p><p>现在我们给每一条表加上一个权值，指向左节点的边我们统统记做1，那从根节点到叶子节点的路径就是叶子节点对应的字符的霍夫曼编码；</p><p><img src="/2020/06/16/贪心算法/霍夫曼编码结果.jpg" alt="霍夫曼编码结果"></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。<br>不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol><li><p>在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？<br>1、从高位往下走，删掉高位比低位大的数，假如4596743只能删除一位，我们会删除第三位的9，删除一个数字剩下的数字位数一样，这个时候在越高位上删除数字最大的数字会使得剩下数字更小；<br>如果数字是递增的，直接删除最后k位就好了；</p></li><li><p>假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？<br>想让所有人的等待时间最短，那么我们得先处理服务时间短的，尽快把他们处理完了才能够处理后面的人；<br>先处理时间长的下面的人就要等待一个长的处理时间，先处理短的下面人员就需要等以短的时间；</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;贪心算法：如何用贪心算法实现Huffman压缩编码&quot;&gt;&lt;a href=&quot;#贪心算法：如何用贪心算法实现Huffman压缩编码&quot; class=&quot;headerlink&quot; title=&quot;贪心算法：如何用贪心算法实现Huffman压缩编码&quot;&gt;&lt;/a&gt;贪心算法：如何用贪心算
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8B/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/二分查找下/</id>
    <published>2020-06-16T13:47:59.000Z</published>
    <updated>2020-06-16T13:49:12.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找（下）-如何快速定位IP对应的省份地址？"><a href="#二分查找（下）-如何快速定位IP对应的省份地址？" class="headerlink" title="二分查找（下）:如何快速定位IP对应的省份地址？"></a>二分查找（下）:如何快速定位IP对应的省份地址？</h1><p><strong>假设我们有12万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</strong></p><p>二分查找的变形问题</p><h2 id="四种常见的二分查找变形问题"><a href="#四种常见的二分查找变形问题" class="headerlink" title="四种常见的二分查找变形问题"></a>四种常见的二分查找变形问题</h2><ol><li>查找第一个值等于给定值的元素</li><li>查找最后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值的元素</li></ol><p>（以数据是从小到大排列为前提）</p><h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p>上一节中的二分查找是最简单的一种，即有序数据集合中不存在重复的数据；<br>当有序数据集合中存在重复的数据，我们希望找到第一个值等于给定的数据。<br>找到第一个为8的元素。<br><img src="/2020/06/16/二分查找下/第一个.jpg" alt="第一个"></p><p>代码实现：</p><pre><code>/** * 寻找第一个等于给定值的元素 * @param a * @param value * @return */public int fristItem(int[] a,int value){    int low = 0;    int high = a.length - 1;    while(low &lt;= high){        int mid = low + ((high - low) &gt;&gt; 1);        if(a[mid] &gt; value){            high = mid - 1;        }else if(a[mid] &lt; value){            low = mid + 1;        }else {            if(mid == 0 || a[mid - 1] != value) return mid;            else high = mid - 1;        }    }    return -1;}</code></pre><p>a[mid] 跟要查找的 value 的大小关系有三种情况：大于、小于、等于。对于 a[mid]&gt;value 的情况，我们需要更新 high= mid-1；对于 a[mid] &lt; value的情况，我们需要更新 low=mid+1;当a[mid]=value的时候，如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是我们要找的第一个值等于给定值的元素。</p><h2 id="变形二：查找最后一个值等于给定值的元素"><a href="#变形二：查找最后一个值等于给定值的元素" class="headerlink" title="变形二：查找最后一个值等于给定值的元素"></a>变形二：查找最后一个值等于给定值的元素</h2><pre><code>/** * 查找最后一个等于给定值的函数 * @param a * @param value * @return */public int lastItem(int[] a, int value){    int low = 0;    int high = a.length - 1;    while (low &lt;= high){        int mid = low + ((high - low) &gt;&gt; 1);        if(a[mid] &gt; value){            high = mid - 1;        }else if(a[mid] &lt; value){            low = mid + 1;        }else {            if(mid == a.length - 1 || a[mid + 1] != value) {                return mid;            }else {                low = mid + 1;            }        }    }    return  -1;}</code></pre><p>最后给定值的元素。</p><h2 id="变形三：查找第一个大于等于给定值的元素"><a href="#变形三：查找第一个大于等于给定值的元素" class="headerlink" title="变形三：查找第一个大于等于给定值的元素"></a>变形三：查找第一个大于等于给定值的元素</h2><p>实现代码：</p><pre><code>/** * 第一个大于等于给定值的元素 * @param a * @param value * @return */public int fristGEItem(int[] a,int value){    int low = 0;    int high = a.length - 1;    while(low &lt;= high){        int mid = low + ((high - low) &gt;&gt; 1);        if(a[mid] &lt; value){            low = mid + 1;        }else {            if(mid == 0 || a[mid - 1] &lt; value){                return mid;            }else {                high = mid - 1;            }        }    }    return -1;}</code></pre><h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><pre><code>/** * 最后一个小于等于给定值的元素 * @param a * @param value * @return */public int lastLEItem(int[] a,int value){    int low = 0;    int high = a.length - 1;    while(low &lt;= high){        int mid = low + ((high - low) &gt;&gt; 1);        if(a[mid] &gt; value){            high = mid - 1;        }else {            if(mid == a.length - 1 || a[mid + 1] &gt; value){                return mid;            }else {                low = mid + 1;            }        }    }    return -1;}</code></pre><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>IP地址可以转化为32位的整形数，所以我们可以将起始地址，按照对应的整形值的大小关系从小到大进行排序。</p><p>这样IP地址查找的问题就变成第四种变形问题，查找最后一个小于等于某个给定值的元素。</p><p>当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p><pre><code>public int search1(int[] nums, int target){    return search1(nums,0,nums.length - 1, target);}public int search1(int[] nums,int low,int high,int target){    if(low &gt; high){        return -1;    }    int mid = low + ((high - low) &gt;&gt; 2);    if(nums[mid] == target){        return mid;    }    if(nums[mid] &lt; nums[high]){        if(target &lt;= nums[high] &amp;&amp; target &gt; nums[mid]){            return search1(nums,mid + 1,high,target);        }else {            return search1(nums,low,mid - 1,target);        }    }else {        if(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid]){            return search1(nums,low,mid - 1,target);        }else {            return search1(nums,mid + 1,high,target);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分查找（下）-如何快速定位IP对应的省份地址？&quot;&gt;&lt;a href=&quot;#二分查找（下）-如何快速定位IP对应的省份地址？&quot; class=&quot;headerlink&quot; title=&quot;二分查找（下）:如何快速定位IP对应的省份地址？&quot;&gt;&lt;/a&gt;二分查找（下）:如何快速定位
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/二分查找/</id>
    <published>2020-06-16T13:47:59.000Z</published>
    <updated>2020-06-16T13:48:39.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找（上）：如何用最省内存的方式实现快速查找功能？"><a href="#二分查找（上）：如何用最省内存的方式实现快速查找功能？" class="headerlink" title="二分查找（上）：如何用最省内存的方式实现快速查找功能？"></a>二分查找（上）：如何用最省内存的方式实现快速查找功能？</h1><p>二分查找算法（Binary Search）算法，也叫折半查找算法。</p><p>假设我们有1000万个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个数是否出现在这1000万数据中？功能不要占用太多空间，最多不超过100MB。</p><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>假设只有10个订单，订单金额分别是：8,11,19,23,27,33，45,55,67,98；<br>利用二分思想每次与中间数对比大小，如图：其中low 和 high 表示待查找区间的下标，mid 表示待查找区间的中间元素下标。<br><img src="/2020/06/16/二分查找/二分查找过程.jpg" alt="二分查找过程"></p><p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似于分治思想。每次都通过跟区间的中间元素对比，将待查找缩小为之前的一半，知道找到要查找的元素，或者区间被说下为0。</strong></p><h2 id="O-logn-惊人的查找速度"><a href="#O-logn-惊人的查找速度" class="headerlink" title="O(logn)惊人的查找速度"></a>O(logn)惊人的查找速度</h2><p>假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏到空才停止。<br><img src="/2020/06/16/二分查找/被查找区间大小的变化.jpg" alt="被查找区间大小的变化"></p><p>其中n/2^k=1时，k为总共缩小的次数，k次区间缩小操作，时间复杂度就是O(k),通过n/2^k=1,我们可以求得k=logn<br>所以时间复杂度就是O(logn)。</p><p>堆、二叉树的操作等等，它们的时间复杂度也是 O(logn)。<br>O(logn) 这种对数时间复杂度。这是一种极其高效的时间复杂度。</p><h2 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h2><p>二分查找的变体问题，那才是真正烧脑的。今天，我们来看如何来写最简单的二分查找。</p><p>最简单的情况就是有序数组中不存在重复元素，我们在其中用二分查找值等于给定值的数据。我用 Java 代码实现了一个最简单的二分查找算法。</p><pre><code>public int bsearch(int[] a,int value){    int low = 0;    int high = a.length - 1;    while(low &lt;= high){        int mid = low + (high - low) / 2;        if(a[mid] == value){            return mid;        }else if(a[mid] &lt; value){            low = mid + 1;        }else {            high = mid - 1;        }    }    return -1;}</code></pre><p><strong>3个易错的地方</strong></p><h3 id="1、循环退出条件"><a href="#1、循环退出条件" class="headerlink" title="1、循环退出条件"></a>1、循环退出条件</h3><p>注意是low &lt;= high 而不是low &lt; high;</p><h3 id="2、mid的取值"><a href="#2、mid的取值" class="headerlink" title="2、mid的取值"></a>2、mid的取值</h3><p>mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。<br>可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。</p><h3 id="3、low和high的更新"><a href="#3、low和high的更新" class="headerlink" title="3、low和high的更新"></a>3、low和high的更新</h3><p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。</p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre><code>public int bsearch1(int[] a,int value){    return bsearchInternally(a,0,a.length-1,value);}private int bsearchInternally(int[] a,int low,int high,int value){    if(low &gt; high) return -1;    int mid = low + ((high - low) &gt;&gt; 1);    if(a[mid] == value) {        return mid;    }else if(a[mid] &lt; value){        return bsearchInternally(a,mid+1,high,value);    }else {        return bsearchInternally(a,low,mid-1,value);    }}</code></pre><h2 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h2><p><strong>首先二分查找依赖的是顺序表结构，简单说就是数组</strong><br>不支持链表，主要原因是二分查找算法需要按照下标随机访问元素。</p><p><strong>其次，二分查找针对的是有序数据</strong><br>二分查找中数据必须是有序的，如果数据没有序，我们需要先排一下序，排序的时间复杂度最低是O(nlogn)。<br>所以如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。<br>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。</p><p><strong>再次，数据量太小不适合二分查找</strong><br>数据量很小完全没必要二分查找，顺序遍历足够了。</p><p><strong>最后，数据量太大也不适合二分查找</strong><br>二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>我们的内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。借助今天讲的内容，我们可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>二分查找，它的时间复杂度是 O(logn)。</p><p>三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p><p>底层必须依赖数组，并且还要求数据是有序的。</p><p>二分查找更适合处理静态数据。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位</p><pre><code>/** * 求平方根 * @param a * @return */public float sqrt(float a){    if(a == 1.0f){        return a;    }    float low = 0;    float high = a;    float mid = (low + high) / 2;    while(mid * mid - a &gt; 1e-6 || a - mid * mid &gt; 1e-6){        if(mid * mid &gt; a){            high = mid;            mid = (low + high) / 2;        }else{            low = mid;            mid = (low + high) / 2;        }    }    return mid;}</code></pre><p>如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？如果你自己推导一下，你就会深刻地认识到，为何我们会选择用数组而不是链表来实现二分查找了。</p><p>假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):<br>第一次查找中间点，需要移动指针n/2次；<br>第二次，需要移动指针n/4次；<br>第三次需要移动指针n/8次；<br>……<br>以此类推，一直到1次为值</p><p>总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + …+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.</p><p>最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同</p><p>但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分查找（上）：如何用最省内存的方式实现快速查找功能？&quot;&gt;&lt;a href=&quot;#二分查找（上）：如何用最省内存的方式实现快速查找功能？&quot; class=&quot;headerlink&quot; title=&quot;二分查找（上）：如何用最省内存的方式实现快速查找功能？&quot;&gt;&lt;/a&gt;二分查找（
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/二叉树/</id>
    <published>2020-06-16T13:41:49.000Z</published>
    <updated>2020-06-16T13:46:09.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树基础上：什么样的二叉树适合用数组来存储？"><a href="#二叉树基础上：什么样的二叉树适合用数组来存储？" class="headerlink" title="二叉树基础上：什么样的二叉树适合用数组来存储？"></a>二叉树基础上：什么样的二叉树适合用数组来存储？</h1><p>非线性数据结构，树。树这种数据结构比线性表的数据结构复杂的多，内容也比较多，所以我分四节来讲解。</p><p><strong>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储</strong></p><h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>什么是树？直接上图：<br><img src="/2020/06/16/二叉树/什么是树.jpg" alt="什么是树"></p><p>树中每个元素叫做“节点”；用来连接相邻节点之间的关系，叫做“父子关系”;</p><p><img src="/2020/06/16/二叉树/节点关系.jpg" alt="节点关系"></p><p>其中A节点是B节点的<strong>父节点</strong>，B节点是A节点的<strong>子节点</strong>。B,C,D这三个节点的父节点是同一个节点，所以他们之间互称<strong>兄弟节点</strong>。没有父节点的节点是<strong>根结点</strong>，E节点就是根节点。没有子节点的节点叫做<strong>叶子节点</strong>或者叶节点，比如图中的G,H,I,J,K,L都是叶子结点。</p><p><strong>树的高度，树的深度，树的层</strong></p><pre><code>节点的高度 = 节点到叶子节点的最长路径（边数）节点的深度 = 根节点到这个节点所经历的边的个数节点的层数 = 节点深度 + 1树的高度   = 根节点的高度</code></pre><p>具体如下图：<br><img src="/2020/06/16/二叉树/高度_深度_层.jpg" alt="高度_深度_层"></p><p>高度这个概念要从下往上看，从最底层开始计数，并且计数的起点是0 。</p><p>深度这个概念从上往下看，从根节点开始往下度量，并且计数起点也是0 。</p><p>层数跟深度计数类似，不过计数起点是1，也就是根节点位于第一层。</p><h2 id="二叉树（Binary-Tree"><a href="#二叉树（Binary-Tree" class="headerlink" title="二叉树（Binary Tree)"></a>二叉树（Binary Tree)</h2><p>二叉树，顾名思义，每个节点最多两个叉，也就是两个子节点，分别是左子节点和右子节点。不过二叉树并不要求每个节点都有两个子节点，有的节点自由左子节点，有的只有右子节点。<br><img src="/2020/06/16/二叉树/二叉树.jpg" alt="二叉树"></p><p>图中，编号2的二叉树，叶子节点全都在最底层，除了叶子结点，每个节点都有左右两个子节点，这种二叉树就叫做<strong>满二叉树</strong>。</p><p>编号3的二叉树，所有的叶子结点都在最下面两层，最后一层的叶子节点，都靠左排列，并且除了最后一层，其它层的节点个数都要达到最大，这种二叉树叫做<strong>完全二叉树</strong>。<br><img src="/2020/06/16/二叉树/完全二叉树.jpg" alt="完全二叉树"></p><h2 id="如何表示或者存储一颗二叉树？"><a href="#如何表示或者存储一颗二叉树？" class="headerlink" title="如何表示或者存储一颗二叉树？"></a>如何表示或者存储一颗二叉树？</h2><p>想要存储一颗二叉树，我们有两种方法，一种基于指针引用的二叉链式存储法，一种是基于数组的顺序存储法。</p><h3 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h3><p><img src="/2020/06/16/二叉树/链式存储法.jpg" alt="链式存储法"></p><h3 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h3><p>我们把根节点存储在下标为1的位置，左子节点存储在下标为 2 <em> i = 2 的位置，右子节点存储在 2 </em> i + 1 = 3的位置。<br><img src="/2020/06/16/二叉树/顺序存储法.jpg" alt="顺序存储法"></p><p>总结：如果节点X存储在数组中下标为i的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 位置存储的就是右子节点。反过来，下标为i/2的位置存储的就是他的父节点。</p><p>一颗完全二叉树，所以仅仅浪费了一个下标为0的存储位置。如果是非完全二叉树，会浪费比较多的数组存储空间。<br><img src="/2020/06/16/二叉树/非完全二叉树顺序存储.jpg" alt="非完全二叉树顺序存储"></p><p>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>三种经典方法，<strong>前序遍历、中序遍历和后序遍历</strong></p><p>前序遍历：树中任意结点来说，先打印这个节点，然后打印它的左子树，最后打印他的右子树。</p><p>中序遍历：树中任意结点来说，先打印左子树，然后打印它本身，最后打印它的右子树。</p><p>后序遍历：树中任意结点来说，先打印左子树，然后打印它的右子树，最后打印它本身。</p><p><img src="/2020/06/16/二叉树/前序_中序_后序.jpg" alt="前序_中序_后序"></p><p><strong>二叉树的前中后序遍历就是一个递归的过程</strong><br>递推公式如下：</p><pre><code>前序遍历的递推公式：preOrder(r) = print(r) -&gt; preOrder(r -&gt; left) -&gt; preOrder(r -&gt; right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left) -&gt; print r -&gt; inOrder(r -&gt; right)后序遍历的递推公式：postOrder(r) = postOrder(r -&gt; left) -&gt; postOrder(r -&gt; right) -&gt; print r</code></pre><p>相应的伪代码如下：</p><pre><code>void preOrder(Node* root) {    if(root == null){        return;    }    preOrder(root -&gt; left);    preOrder(root -&gt; right);}void inOrder(Node* root){    if(root == null){        return;    }    inOrder(root -&gt; left);    print root;    inOrder(root -&gt; right);}void postOrder(Node* root){    if(root == null) {        return;    }    postOrder(root -&gt; left);    postOrder(root -&gt; right);    print root;}</code></pre><p>代码实现：中序遍历</p><pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {    List list = new ArrayList&lt;&gt;();    if(root == null){        return list;    }    if(root.left != null){        list.addAll(inorderTraversal(root.left));    }    list.add(root.val);    if(root.right != null){        list.addAll(inorderTraversal(root.right));    }    return list;}</code></pre><p><strong>二叉树遍历的时间复杂度是多少呢？</strong><br>遍历操作的时间复杂度，跟结点的个数n成正比，也就是说，二叉树的时间复杂度是O(n).</p><h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇&amp;内容小结"></a>解答开篇&amp;内容小结</h2><p>根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p><p>二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)，你需要理解并能用递归代码来实现。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><ol><li>给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？</li></ol><p>n！个组合。</p><ol start="2"><li><p>我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？</p><pre><code>public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {    Deque&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();    ArrayList list = new ArrayList();    if(root == null){        return list;    }    //将根节点加入到队列中    queue.add(root);    //队列为空就结束循环    while(!queue.isEmpty()){        //取头节点        TreeNode node = queue.peek();        //将头节点弹出        queue.poll();        //将头节点的元素值加入到列表中        list.add(node.val);        //如果头节点有左右子节点就将子节点加入到队列中        if(node.left != null){            queue.add(node.left);        }        if(node.right != null){            queue.add(node.right);        }    }    return list;}</code></pre></li></ol><h1 id="二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？"><a href="#二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？" class="headerlink" title="二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？"></a>二叉树基础下：有了如此高效的散列表，为什么还需要二叉树？</h1><p>二叉查找树，支持动态数据集合的快速插入、删除、查找操作。</p><p>之前说散列表也支持这样的操作，并且时间复杂度是O(1)。<strong>既然有了这么高效的散列表，使用二叉树的这些地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</strong></p><h2 id="二叉查找树-（Binary-Search-Tree）"><a href="#二叉查找树-（Binary-Search-Tree）" class="headerlink" title="二叉查找树 （Binary Search Tree）"></a>二叉查找树 （Binary Search Tree）</h2><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每一个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p><p><img src="/2020/06/16/二叉树/二叉查找树.jpg" alt="二叉查找树"></p><h3 id="1、二叉查找树的查找操作"><a href="#1、二叉查找树的查找操作" class="headerlink" title="1、二叉查找树的查找操作"></a>1、二叉查找树的查找操作</h3><p>如何在二叉查找树中查找一个节点。我们先取根节点，如果他等于我们要查找的数据就返回。如果查找数据比根节点小，那就在其左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><p><img src="/2020/06/16/二叉树/二叉查找树查找操作.jpg" alt="二叉查找树查找操作"></p><p>代码实现：</p><pre><code>public class BinarySearchTree {    public static class Node{        private int data;        private Node left;        private Node right;        public Node(int data){            this.data = data;        }    }    private Node tree;    public Node find(int data){        Node p = tree;        while (p != null){            if(data &lt; p.data){                p = p.left;            }else if(data &gt; p.data){                p = p.right;            }else return p;        }        return null;    }}</code></pre><h3 id="2、二叉查找树的插入操作"><a href="#2、二叉查找树的插入操作" class="headerlink" title="2、二叉查找树的插入操作"></a>2、二叉查找树的插入操作</h3><p>插入过程有点类似于插座操作。<br>如果插入数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><p><img src="/2020/06/16/二叉树/二叉查找树的插入操作.jpg" alt="二叉查找树的插入操作"></p><p>代码实现：</p><pre><code>public void insert(int data){    if(tree == null){        tree = new Node(data);        return;    }    Node p = tree;    while(p != null){        if(data &gt; p.data){            if(p.right == null){                p.right = new Node(data);                return;            }            p = p.right;        } else { //data &lt; p.data            if(p.left == null){                p.left = new Node(data);                return;            }            p = p.left;        }    }}</code></pre><h3 id="3、二叉查找树的删除操作"><a href="#3、二叉查找树的删除操作" class="headerlink" title="3、二叉查找树的删除操作"></a>3、二叉查找树的删除操作</h3><p>第一种情况是，如果删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置null，如图删除结点55；<br>第二种情况是，如果删除节点只有一个子节点（只有左子节点或者右子节点），我们需要更新父节点中，指向要删除节点的指针，让他指向删除节点的子节点就可以了。如图节点13；<br>第三种情况是，如果要删除节点中有两个子节点，这就比较麻烦了。我们需要找到这个节点的在右子树的最小节点，把它替换到要删除的节点上。然后再删除这个最小节点，因为最小节点肯定没有左子节点，所以我们可以用上面两条规则来删除这个最小节点。如图删除节点18；</p><p><img src="/2020/06/16/二叉树/二叉查找树的删除操作.jpg" alt="二叉查找树的删除操作"></p><p>代码实现：</p><pre><code>public void delete(int data){    Node p = tree;    Node pp = null;    while(p != null &amp;&amp; p.data != data){        pp = p;        if(data &gt; p.data){            p = p.right;        }else{            p = p.left;        }        if(p == null){            return;        }        //要删除的节点有两个子节点        if(p.left != null &amp;&amp; p.right != null){            Node minP = p.right;            Node minPP = p;            while(minP.left != null){                minPP = minP;                minP = minP.left;            }            p.data = minP.data;            p = minP;            pp = minPP;        }        Node child ;        if(p.left != null) child = p.left;        else if(p.right != null) child = p.right;        else child = null;        if(pp == null) tree = child;        else if(pp.left == p) pp.left = child;        else pp.right = child;    }}</code></pre><h3 id="4、二叉查找树的其他操作"><a href="#4、二叉查找树的其他操作" class="headerlink" title="4、二叉查找树的其他操作"></a>4、二叉查找树的其他操作</h3><p>快速的查找最大节点和最小节点、前驱节点和后继节点。</p><p>按照中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)非常高效。</p><h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>实际开发中，我们在二叉树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值来构建二叉查找树，对象的其他字段叫做卫星数据。</p><p>如果存储的两个对象的键值相同，这种情况如何处理呢？<br>第一种方法：二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p><p>第二种方法：在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到右子树，也就是把新插入的数据当做大于这个节点的值处理。</p><p><img src="/2020/06/16/二叉树/插入相同数据.jpg" alt="插入相同数据"></p><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，知道遇到叶子节点，才停止。</p><p><img src="/2020/06/16/二叉树/查找所有相同数据.jpg" alt="查找所有相同数据"></p><p>对于删除操作，我们也需要先查找每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除；</p><p><img src="/2020/06/16/二叉树/删除所有相同数据.jpg" alt="删除所有相同数据"></p><h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><p>图中第一种二叉查找树已经退化成链表，查找的时间复杂度变成了O(n);</p><p><img src="/2020/06/16/二叉树/时间复杂度.jpg" alt="时间复杂度"></p><p>理想情况下，二叉查找树是一颗完全二叉树或满二叉树，这时插入、删除、查找的时间复杂度是多少呢？</p><p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？</p><p>第 K 层包含的节点个数就是 2^(K-1)。</p><p>对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L</p><p>如果节点个数是n，那么n满足这样一个关系：</p><pre><code>n &gt;= 1+2+4+8+...+2^(L-2)+1n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)</code></pre><p>借助等比数列的求和公式，我们可以计算出，L 的范围是 [log2(n+1), log2n +1]。完全二叉树的层数小于等于 log2n +1，也就是说，完全二叉树的高度小于等于 log2n。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>散列表的插入，删除，查找复杂度可以做到常量级O(1),二叉查找树的，插入，删除，查找操作时间复杂度才是O(logn)，因此为啥还要使用二叉查找树？</p><p>第一：散列表的数据是无序存储的，如果要输出有序数据，要先排序，而对于二叉查找树只需要中序遍历，就可以在O(n)的时间复杂度中，输出有序数据序列。</p><p>第二：散列表扩容耗时很多，而且遇到散列冲突，性能不稳定，尽管二叉查找树的性能不稳定，但在工程中我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p><p>第三：笼统的来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际查找速度可能不一定比O(logn)快，加上哈希函数的耗时，也不一定就比平航查找树的效率高。</p><p>第四：散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><h2 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h2><p>今天我讲了二叉树高度的理论分析方法，给出了粗略的数量级。如何通过编程，求出一棵给定二叉树的确切高度呢？</p><pre><code>//递归求二叉树的深度public int TreeDepth(TreeNode root) {    int depth = 0;    //如果root为null，返回depth = 0；    if(root == null){        return depth;    }    //否则进行递归，如果左子树深度比右子树深度大，最大深度就在左子树上加1;否则反之    if(TreeDepth(root.left) &gt; TreeDepth(root.right)){        depth = TreeDepth(root.left) + 1;    }else{        depth = TreeDepth(root.right) + 1;    }    return depth;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉树基础上：什么样的二叉树适合用数组来存储？&quot;&gt;&lt;a href=&quot;#二叉树基础上：什么样的二叉树适合用数组来存储？&quot; class=&quot;headerlink&quot; title=&quot;二叉树基础上：什么样的二叉树适合用数组来存储？&quot;&gt;&lt;/a&gt;二叉树基础上：什么样的二叉树适合用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://xiaodupi-zyq.github.io/2020/06/16/%E9%93%BE%E8%A1%A8/"/>
    <id>https://xiaodupi-zyq.github.io/2020/06/16/链表/</id>
    <published>2020-06-16T13:28:53.000Z</published>
    <updated>2020-06-16T13:29:32.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>缓存大小一定，当缓存满了之后，如何清理呢，三种策略：先进先出策略FIFO，最少使用策略LFU，最近最少使用策略LRU</p><p>如何使用链表实现LRU缓存淘汰策略呢？</p><p>首先数组是一块连续的内存空间来存储，对内存要求很高。而链表不需要一块连续的内存空间，通过指针将一堆零散的内存块连起来使用。<br>链表分为单链表，双链表和循环链表<br><img src="/2020/06/16/链表/单链表.jpg" alt="单链表"><br>插入和删除<br><img src="/2020/06/16/链表/插入和删除.jpg" alt="插入和删除"><br>链表的随机访问没有数组好，需要O(n)的时间复杂度</p><p>循环链表和双向链表，循环链表是一种特殊的单链表，即尾指针指向了链表的头节点。<br><img src="/2020/06/16/链表/循环链表.jpg" alt="循环链表"><br>双向链表不光只有后向指针还有前向指针<br><img src="/2020/06/16/链表/双向链表.jpg" alt="双向链表"><br>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点</p><p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><p>如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度</p><p>对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）</p><p>LRU算法的实现：<br>维护一个有序单链表，越靠近尾部的节点是越早之前访问的，当有一个新的数据比访问时，我们从链表头开始遍历链表</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<br>如果此时缓存未满，则将此结点直接插入到链表的头部；<br>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ol><h3 id="几个写链表代码的技巧"><a href="#几个写链表代码的技巧" class="headerlink" title="几个写链表代码的技巧"></a>几个写链表代码的技巧</h3><h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。<br>经常会有这样的代码：p-&gt;next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p><h3 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h3><p><img src="/2020/06/16/链表/指针丢失.jpg" alt="指针丢失"><br>使用以下代码就将指针丢失了</p><pre><code>p-&gt;next = x;x-&gt;next = p-&gt;next;</code></pre><p>这样的结果最后是x的指针指向x<br>插入结点时，一定要注意操作的顺序，如果上述代码，交换位置就是正确的了，x-&gt;next指向b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。</p><h3 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h3><p>如果在结点P后插入新结点，正确的代码为：</p><pre><code>new_node-&gt;next = p-&gt;next;p-&gt;next = new_node;</code></pre><p>但如果要向空链表中插入第一个结点，刚刚逻辑不能用，而应该是这样的</p><pre><code>if(head == null){    head = new_node;}</code></pre><p>删除结点</p><pre><code>p-&gt;next = p-&gt;next-&gt;next;</code></pre><p>最后一个结点删除</p><pre><code>if(head-&gt;next == null){    head = null;}</code></pre><p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</p><p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。</p><h3 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h3><p>代码在一些边界或者异常情况下，最容易产生Bug。</p><p><strong>检查边界条件：（也是其他编程时考虑的方法）</strong></p><ol><li>如果链表为空时，代码是否正常工作；</li><li>如果链表只含一个结点时，代码是否正常工作；</li><li>如果链表只含两个结点时，代码是否正常工作；</li><li>代码逻辑在处理头节点和尾节点的时候，代码是否正常工作；</li></ol><h3 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h3><p>举例法和画图法<br><img src="/2020/06/16/链表/举例画图.jpg" alt="举例画图"><br>将要做的操作进行基本的画图操作。</p><h3 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h3><p>几个常用链表操作，多写多练</p><ol><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第n个结点</li><li><p>求链表中间结点</p><pre><code>public class MyLinked {private Node1 head;private Node1 last;MyLinked() throws Exception{    this(5);}MyLinked(int capacity) throws Exception{    this(&apos;a&apos;,capacity,false);}MyLinked(char c,int capacity,boolean random) throws Exception{    if(capacity &lt;= 0){        throw new Exception(&quot;链表容量不能为空或负&quot;);    }    char ch = c;    for(int i = 0; i &lt; capacity; i++){        Node1 node = new Node1();        node.c = ch;        if(!random){            ch++;        }else{            Random rand = new Random();            ch+=rand.nextInt(5);        }        if(i == 0){            head = node;            last = node;        }else{            last.node = node;            last = node;        }    }    last.node = null;}public void out(){    Node1 p = new Node1();    p = head;    while (p != null){        System.out.print(p.c + &quot; &quot;);        p = p.node;    }    System.out.println();}public void reverse(){    Node1 newLast = head;    Node1 newHead = head;    Node1 t = head.node;    while (t != null){        Node1 node = new Node1();        node = t;        t = t.node;        node.node = newHead;        newHead = node;    }    newLast.node = null; //记得最后链表节点为null    last = newLast;    head = newHead;}//环的检测，快慢指针public boolean isCircle(){    if(head == last){        return false;    }    Node1 p = head;    Node1 q = head;    while(q.node != null &amp;&amp; q.node.node != null &amp;&amp; q != null){        q = q.node.node;        p = p.node;        if(q == p){            return true;        }    }    return false;}//有序链表合并public MyLinked merge(MyLinked myLinked1,MyLinked myLinked2) throws Exception {    MyLinked mergeLinked = new MyLinked(1);    Node1 head1 = myLinked1.head;    Node1 head2 = myLinked2.head;    Node1 mergehead = mergeLinked.head;    while(head1 != null &amp;&amp; head2 != null){        if(head1.c &lt;= head2.c){            mergehead.node = head1;            head1 = head1.node;        }else{            mergehead.node = head2;            head2 = head2.node;        }        mergehead = mergehead.node;    }    if(head1 != null){        mergehead.node = head1;        mergeLinked.head = mergeLinked.head.node;        mergeLinked.last = myLinked1.last;    }else{        mergehead.node = head2;        mergeLinked.head = mergeLinked.head.node;        mergeLinked.last = myLinked1.last;    }    return mergeLinked;}public void deleteLastNNode(int n){    Node1 p = new Node1();    Node1 q = new Node1();    p.node = q.node = head;    for(int i = 0; i &lt; n;i++){        if(p == null){            System.out.println(&quot;链表总长不足： &quot; + n);            return;        }        p = p.node;    }    while (p != last){        p = p.node;        q = q.node;    }    if(q.node == head){        head = head.node;        return;    }    q.node = q.node.node;}public Node1 middle(){    Node1 p = head;    Node1 q = head;    while(p.node != null &amp;&amp; p.node.node != null){        p = p.node.node;        q = q.node;    }    return q;}</code></pre></li></ol><pre><code>public static void main(String[] args) throws Exception{    MyLinked myLinked = new MyLinked(10);    myLinked.out();    System.out.println(&quot;是否有环：&quot;);    System.out.println(myLinked.isCircle());    myLinked.last.node = myLinked.head;    System.out.println(myLinked.isCircle());    myLinked.last.node = null;    System.out.println(&quot;求链表中间结点：&quot;);    Node1 middle = myLinked.middle();    System.out.println(middle.c);    System.out.println(&quot;反转链表：&quot;);    myLinked.reverse();    myLinked.out();    System.out.println(&quot;链表合并：&quot;);    MyLinked myLinked1 = new MyLinked(&apos;a&apos;,4,true);    myLinked1.out();    MyLinked myLinked2 = new MyLinked(&apos;c&apos;,2,true);    myLinked2.out();    MyLinked mergeLinked = new MyLinked(1);    mergeLinked = myLinked.merge(myLinked1,myLinked2);    mergeLinked.out();    System.out.println(&quot;删除倒数第n个结点：&quot;);    myLinked.deleteLastNNode(5);    myLinked.out();}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;p&gt;缓存大小一定，当缓存满了之后，如何清理呢，三种策略：先进先出策略FIFO，最少使用策略LFU，最近最少使用策略LRU&lt;/p&gt;
&lt;p&gt;如何使用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap自我详细理解</title>
    <link href="https://xiaodupi-zyq.github.io/2019/11/12/HashMap/"/>
    <id>https://xiaodupi-zyq.github.io/2019/11/12/HashMap/</id>
    <published>2019-11-12T09:19:33.000Z</published>
    <updated>2019-11-12T09:19:25.094Z</updated>
    
    <content type="html"><![CDATA[<p>简介：<br>Java为了数据结构中的映射定义了一个接口，java.util.Map，此接口主要用四个实现，主要是HashMap，Hashtable，LinkedHashMap，TreeMap。具体的继承关系如下：<br><img src="/2019/11/12/HashMap/继承关系.png" alt="继承关系"><br>具体四种实现类的特点如下：<br>（1)HashMap:根据键的hashcode值存储数据，大多数情况下可以直接定位到它的值，访问速度很快，但是遍历顺序是不确定的。在键值对中只允许一条记录的键为null。且HashMap非线程安全，可以用ConcurrentHashMap具有线程安全的能力。</p><hr><h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。<br> JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.<br> JDK1.8 之后解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组长度小于64，那么会选择进行数组扩容，而不是转换成红黑树），以减少搜索时间。</p><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8之前HashMap底层是数组和链表结合在一起使用的链表散列。HashMap通过key的hashCode经过扰动函数处理之后得到hash值，然后通过（n-1） &amp; hash判断当前元素存放的位置（这里的n指的是数组的长度），如果当前位置村子元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同的话就通过拉链法解决冲突。<br>扰动函数就是hash方法，使用hash方法主要是防止性能较差的hashcode方法，从而减少碰撞。<br>1.8的hash方法</p><pre><code>static final int hash(Object key) {    int h;    //key.hashCode() : 返回散列值也就是hashcod    //^ ： 按位异或    //&gt;&gt;&gt;：无符号右移，忽略符号位，空位都以0补齐    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>1.7的hash方法</p><pre><code>static int hash(int h){    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}</code></pre><p>1.8的hash函数性能更高，因为1.7的hash函数扰动了四次</p><p>拉链法： 数组与链表结合，如图<br><img src="/2019/11/12/HashMap/拉链法.png" alt="拉链法"><br>JDK1.8之后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。<br><img src="/2019/11/12/HashMap/拉链法红黑树.png" alt="1.8的拉链法"></p><h3 id="类的属性："><a href="#类的属性：" class="headerlink" title="类的属性："></a>类的属性：</h3><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMAp&lt;K,V&gt; implements Map&lt;K,V&gt;,Cloneable,Serializable{    // 序列号    private static final long serialVersionUID = 362498820763181265L;        // 默认的初始容量是16    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;       // 最大容量    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;     // 默认的填充因子    static final float DEFAULT_LOAD_FACTOR = 0.75f;    // 当桶(bucket)上的结点数大于这个值时会转成红黑树    static final int TREEIFY_THRESHOLD = 8;     // 当桶(bucket)上的结点数小于这个值时树转链表    static final int UNTREEIFY_THRESHOLD = 6;    // 桶中结构转化为红黑树对应的table的最小大小    static final int MIN_TREEIFY_CAPACITY = 64;    // 存储元素的数组，总是2的幂次倍    transient Node&lt;k,v&gt;[] table;     // 存放具体元素的集    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;    // 存放元素的个数，注意这个不等于数组的长度。    transient int size;    // 每次扩容和更改map结构的计数器    transient int modCount;       // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容    int threshold;    // 加载因子    final float loadFactor;}</code></pre><p>loadFactory加载因子：加载因子控制数据的疏密程度，默认0.75比较好的临界值。<br>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能</p><p>threshold<br>threshold = capacity*loadFactor,当Size&gt;=threshold的时候，考虑扩增</p><h3 id="节点类源码"><a href="#节点类源码" class="headerlink" title="节点类源码"></a>节点类源码</h3><pre><code>//继承自Map.Entry&lt;K,V&gt; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较    final K key;//键    V value; //值    //指向下一个节点    Node&lt;K,V&gt; next;    Node(int hash, K key,V value,Node&lt;K,V&gt; next) {        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    }    public final K getKey() {return key;}    public final V getValue() {return value;}    public final String toString() {return key + &quot;=&quot; + value;}    //重写hashCode方法    public final int hashCode(){        return Objects.hashCode(Key) ^ Objects.hashCode(value);    }    public final V setValue(V newValue) {        V oldValue = value;        value = newValue;        return oldValue;    }    //重写equals方法    public final boolean equals(Object o) {        if(o == this){            return true;        }        if(o instanceof Map.Entry){            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;            //任何属于Map.Entry的对象都可以进行比较，比较过程中，key要相等，value也要相等            if(Objects.equals(key,e.getKey()) &amp;&amp; Objects.equals(value,e.getValue())){                return true;            }        }    }}</code></pre><h3 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h3><pre><code>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {    TreeNode&lt;K,V&gt; parent; //父    TreeNode&lt;K,V&gt; left; //左    TreeNode&lt;K,V&gt; right; //右    TreeNode&lt;K,V&gt; prev; //needed to unlink next upon deletion    boolean red; //判断颜色    TreeNode(int hash,K key,V val,Node&lt;K,V&gt; next) {        super(hash,key,val,next);    }    //返回根节点    final TreeNode&lt;K,V&gt; root() {        final (TreeNode&lt;K,V&gt; r = this,p;;) {            if((p = r.parent) == null) {                return r;            }            r = p;        }    }}</code></pre><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>//默认构造函数public HashMap() {    this.loadFactor = DEFAULT_LOAD_FACTOR; //all other fields defaulted}//包含另一个“Map”的构造函数public HashMap(Map&lt;? extends K,? extends V&gt; m) {    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m,false);//下面分析}//指定“容量大小”的构造函数public HashMap(int initialCapacity) {    this(initialCapacity,DEFAULT_LOAD_FACTOR);}//指定容量大小和加载因子的构造函数public HashMap(int initialCapacity, final loadFactor) {    //初始容量小于零和大于最大的情况    if(initialCapacity &lt; 0){        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);    }    if(initialCapacity &gt; MAXIMUM_CAPACITY){        initialCapacity = MAXIMUM_CAPACITY;    }    //加载因子的限制条件    if(loadFactor &lt;= 0 || Float.isNaN(loadFactor)){        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);    }    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(inintialCapacity); }</code></pre><p>putMapEntries方法：</p><pre><code>//就是将已有构造函数的m放进新的hashMapfinal void putMapEntries(Map&lt;? extends K,? extends V&gt; m , boolean evict) {    int s = m.size();    if(s &gt; 0) {        //判断table是否初始化        if(table == null) {            //未初始化，s为m的实际个数            float ft = ((float)s / loadFactor) + 1.0F;            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int) ft : MAXIMUM_CAPACITY);            //计算得到的t大于阈值，则初始化阈值            if(t &gt; threshold){                threshold = tableSizeFor(t);            }            //已初始化，并且m元素个数大于阈值，进行扩容处理            else if (s &gt; threshold){                resize();            }            //将m中所有的元素添加到HashMap中            for(Map.Entry&lt;? extends K,? extends V&gt; e : m.EntrySet()) {                K key = e.getKey();                V value = e.getValue();                putVal(hash(key),key,value,false,evict)            }        }    }}</code></pre><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><h4 id="对putVal方法添加元素的分析如下："><a href="#对putVal方法添加元素的分析如下：" class="headerlink" title="对putVal方法添加元素的分析如下："></a>对putVal方法添加元素的分析如下：</h4><p>1、如果定位到的数组位置没有元素就直接插入<br>2、如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this,tab,hash,key,value)将元素添加进入，如果不是就遍历链表插入（插入的是链表尾部）</p><p><img src="/2019/11/12/HashMap/put流程图.png" alt="put流程图"></p><pre><code>//put源码public V put(K key , V value){    return putVal(hash(key),key,value,false,true);}final V putVal(int hash,K key, V value,boolean onlyIfAbsent,boolean evict) {    Node&lt;K,V&gt;[] tab;    Node&lt;K,V&gt; p;     int n,i;    //table未初始化或者长度为0，进行扩容    if((tab = table) == null || (n = tab.length) == 0){        n = (tab = resize()).length;     }    //(n - 1) &amp; hash确定元素存放在哪个桶内，桶为空，新生成的节点放入桶内，此时的节点是放在数组内的    if((p = tab[i = (n - 1) &amp; hash]) == null){        tab[i] = newNode(hash, key, value, null);    }    //桶内已有存在的元素    else{        Node&lt;K,V&gt; e; K k;        //比较桶中第一个元素（数组中的节点）的hash值是否相等，key相等        if(p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))){            //将第一个元素赋给e，用e来记录            e = p;        }        //hash值不相等，即key不相等，为红黑树节点        else if(p instanceof TreeNode) {            //放入树中            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        }        //为链表节点        else {            //在链表最末插入结点            for((e = p.next()) == null) {                //在尾部插入新节点                p.next = newNode(hash,key,value,null);                // 结点数量达到阈值，转化为红黑树                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                    treeifyBin(tab, hash);                // 跳出循环                break;            }            // 判断链表中结点的key值与插入的元素的key值是否相等            if (e.hash == hash &amp;&amp;                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                // 相等，跳出循环                break;            // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表            p = e;        }    }    // 表示在桶中找到key值、hash值与插入元素相等的结点    if (e != null) {         // 记录e的value        V oldValue = e.value;        // onlyIfAbsent为false或者旧值为null        if (!onlyIfAbsent || oldValue == null)            //用新值替换旧值            e.value = value;        // 访问后回调        afterNodeAccess(e);        // 返回旧值        return oldValue;    }}// 结构性修改++modCount;// 实际大小大于阈值则扩容if (++size &gt; threshold)    resize();// 插入后回调afterNodeInsertion(evict);return null;}</code></pre><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {        // 数组元素相等        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        // 桶中不止一个节点        if ((e = first.next) != null) {            // 在树中get            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            // 在链表中get            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><pre><code>final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table; //旧数组    int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧数组的大小    int oldThr = threshold; //旧数组的阈值    int newCap, newThr = 0; //初始化新数组的容量和阈值为0    if (oldCap &gt; 0) {        // 超过最大值就不再扩充了，就只好随你碰撞去吧        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE; //将阈值也调整到最大，任由碰撞吧            return oldTab;        }        // 没超过最大值，就扩充为原来的2倍        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // 阈值也调整为两倍    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {         // signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    // 计算新的resize上限    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        // 把每个bucket都移动到新的buckets中        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else {                     Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do {                        next = e.next;                        // 原索引                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        // 原索引+oldCap                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    // 原索引放到bucket里                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    // 原索引+oldCap放到bucket里                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><p><strong><strong><strong><strong>***</strong></strong></strong></strong>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简介：&lt;br&gt;Java为了数据结构中的映射定义了一个接口，java.util.Map，此接口主要用四个实现，主要是HashMap，Hashtable，LinkedHashMap，TreeMap。具体的继承关系如下：&lt;br&gt;&lt;img src=&quot;/2019/11/12/Hash
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="https://xiaodupi-zyq.github.io/2019/11/12/LinkedList/"/>
    <id>https://xiaodupi-zyq.github.io/2019/11/12/LinkedList/</id>
    <published>2019-11-12T05:56:33.000Z</published>
    <updated>2019-11-12T05:58:34.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList实现了List接口和Deque接口的双端链表。<br>链表结构支持高效的插入和删除操作，<br>Deque接口使得LinkedList类具有队列的特性。</p><p><img src="/2019/11/12/LinkedList/内部结构.png" alt="内部结构"><br><img src="/2019/11/12/LinkedList/节点.png" alt="节点"></p><h2 id="LinkedList类中的内部私有类Node"><a href="#LinkedList类中的内部私有类Node" class="headerlink" title="LinkedList类中的内部私有类Node"></a>LinkedList类中的内部私有类Node</h2><pre><code>private static class Node&lt;E&gt; {    E item; //结点值    Node&lt;E&gt; next; //后继节点    Node&lt;E&gt; prev; //前驱节点    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next){        this.item = element;        this.next = next;        this.prev = prev;    }}</code></pre><h2 id="LinkedList源码分析："><a href="#LinkedList源码分析：" class="headerlink" title="LinkedList源码分析："></a>LinkedList源码分析：</h2><h3 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h3><pre><code>public LinkedList(){}public LinkedList(Collection&lt;? extends E&gt; c) {    this();    addAll(c);}</code></pre><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p>add(E e)方法：将元素添加到链表的尾部</p><pre><code>public boolean add(E e){    linkLast(e);//调用方法    return true;}/**  *链接使e作为最后一个元素  */void linkLast(E e){    final Node&lt;E&gt; l = last; //l指向链表尾部    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l,e,null); //新建结点将结点放在链表尾部    last = newNode;//新建结点    if(l == null){ //说明原链表为空，新建结点既是第一个也是最后一个        first = newNode;    }else{        l.next = newNode;//指向下一个元素    }    size++;    modCount++;}</code></pre><p>add(int index,E e) 在指定位置添加元素</p><pre><code>public void add(int index, E element) {    checkPositionIndex(index);//检查索引是否处于【0~size】之间    if(index == size) {        linkLast(element);    }else{        linkBefore(element,node(index));    }}</code></pre><p>linkBefore方法需要给定两个参数，一个插入结点的值，一个指定的node，所以我们调用了node(index)查找index对应的node<br>addAll(Collection c) : 将集合插入到链表尾部</p><pre><code>public boolean addAll(Collection&lt;? extends E&gt; c) {    return addAll(size,c)}</code></pre><p>addAll(int index, Collection c)： 将集合从指定位置开始插入</p><pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    //1:检查index范围是否在size之内    checkPositionIndex(index);    //2:toArray()方法把集合的数据存到对象数组中    Object[] a = c.toArray();    int numNew = a.length;    if (numNew == 0)        return false;    //3：得到插入位置的前驱节点和后继节点    Node&lt;E&gt; pred, succ;    //如果插入位置为尾部，前驱节点为last，后继节点为null    if (index == size) {        succ = null;        pred = last;    }    //否则，调用node()方法得到后继节点，再得到前驱节点    else {        succ = node(index);        pred = succ.prev;    }    // 4：遍历数据将数据插入    for (Object o : a) {        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;        //创建新节点        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);        //如果插入位置在链表头部        if (pred == null)            first = newNode;        else            pred.next = newNode;        pred = newNode;    }    //如果插入位置在尾部，重置last节点    if (succ == null) {        last = pred;    }    //否则，将插入的链表与先前链表连接起来    else {        pred.next = succ;        succ.prev = pred;    }    size += numNew;    modCount++;    return true;}</code></pre><h3 id="addAll方法通常包括四个步骤："><a href="#addAll方法通常包括四个步骤：" class="headerlink" title="addAll方法通常包括四个步骤："></a>addAll方法通常包括四个步骤：</h3><pre><code>1、检查index范围是否在size之内2、toArray()方法把集合中的数据存到对象数组中3、得到插入位置的前驱和后继节点4、遍历数据将数据插入到指定位置</code></pre><p>addFirst(E e):将元素添加到链表头部</p><pre><code>public void addFirst(E e) {    linkFirst(e);}private void linkFirst(E e) {    final Node&lt;E&gt; f = first;    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//新建节点，以头节点为后继节点    first = newNode;    //如果链表为空，last节点也指向该节点    if (f == null)        last = newNode;    //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素    else        f.prev = newNode;    size++;    modCount++;}</code></pre><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a>根据位置取数据的方法</h3><p>get(int index) : 根据指定索引返回数据</p><pre><code>public E get(int index) {    //检查index范围是否在size之内    checkElementIndex(index);    //调用Node(index)去找到index对应的node然后返回它的值    return node(index).item;}</code></pre><h3 id="获取头节点的数据方法："><a href="#获取头节点的数据方法：" class="headerlink" title="获取头节点的数据方法："></a>获取头节点的数据方法：</h3><pre><code>public E getFirst() {    final Node&lt;E&gt; f = first;    if (f == null)        throw new NoSuchElementException();    return f.item;}public E element() {    return getFirst();}public E peek() {    final Node&lt;E&gt; f = first;    return (f == null) ? null : f.item; //跟getFirst唯一的区别在于头为空不报错}public E peekFirst() {    final Node&lt;E&gt; f = first;    return (f == null) ? null : f.item;}</code></pre><h3 id="区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常"><a href="#区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常" class="headerlink" title="区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常"></a>区别在于四种方法对于头结点为空的时候的处理，是报错还是抛出异常</h3><p>获取尾节点（index = -1）数据方法：</p><pre><code>public E getLast() {    final Node&lt;E&gt; l = last;    if (l == null)        throw new NoSuchElementException();    return l.item;}public E peekLast() {    final Node&lt;E&gt; l = last;    return (l == null) ? null : l.item;}</code></pre><p>根据对象得到索引的方法<br>int indexOf(Object o) : 从头遍历找</p><pre><code>public int indexOf(Object o) {    int index = 0;    if(o == null) {        for(Node&lt;E&gt; x = first; x != null; x = x.next) {            if(x.item == null) {                return index;            }            index++;        }    } else {        for(Node&lt;E&gt; x = first; x != null; x = x.next) {            if(o.equals(x.item)){                return index;            }            index++;        }    }    return -1;}</code></pre><h3 id="检查链表是否包含对象的方法："><a href="#检查链表是否包含对象的方法：" class="headerlink" title="检查链表是否包含对象的方法："></a>检查链表是否包含对象的方法：</h3><p>contains(Object o) : 检查对象o是否存在于链表中</p><pre><code>public boolean contains(Object o) {    return indexOf(o) != -1;}</code></pre><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><p>remove(),removeFirst,pop() : 删除头节点<br>    public E pop() {<br>        return removeFirst();<br>    }<br>    public E remove() {<br>        return removeFirst();<br>    }<br>    public E removeFirst() {<br>        final Node<e> f = first;<br>        if (f == null)<br>            throw new NoSuchElementException();<br>        return unlinkFirst(f);<br>    }</e></p><p>removeLast(), pollLast(): 删除尾节点</p><pre><code>public E removeLast() {    final Node&lt;E&gt; l = last;    if (l == null)        throw new NoSuchElementException();    return unlinkLast(l);}public E pollLast() {    final Node&lt;E&gt; l = last;    return (l == null) ? null : unlinkLast(l);}</code></pre><p>remove(Object o) : 删除指定元素</p><pre><code>public boolean remove(Object o) {    //如果删除对象为null    if (o == null) {        //从头开始遍历        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            //找到元素            if (x.item == null) {               //从链表中移除找到的元素                unlink(x);                return true;            }        }    } else {        //从头开始遍历        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            //找到元素            if (o.equals(x.item)) {                //从链表中移除找到的元素                unlink(x);                return true;            }        }    }    return false;}</code></pre><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p><p>unlink(Node x)方法：</p><pre><code>E unlink(Node&lt;E&gt; x) {    // assert x != null;    final E element = x.item;    final Node&lt;E&gt; next = x.next;//得到后继节点    final Node&lt;E&gt; prev = x.prev;//得到前驱节点    //删除前驱指针    if (prev == null) {        first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点    } else {        prev.next = next;//将前驱节点的后继节点指向后继节点        x.prev = null;    }    //删除后继指针    if (next == null) {        last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点    } else {        next.prev = prev;        x.next = null;    }    x.item = null;    size--;    modCount++;    return element;}</code></pre><p>remove(int index)：删除指定位置的元素</p><pre><code>public E remove(int index) {    //检查index范围    checkElementIndex(index);    //将节点删除    return unlink(node(index));}</code></pre><h3 id="LinkList类常用方法测试"><a href="#LinkList类常用方法测试" class="headerlink" title="LinkList类常用方法测试"></a>LinkList类常用方法测试</h3><pre><code>package list;import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo {    public static void main(String[] srgs) {        //创建存放int类型的linkedList        LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();        /************************** linkedList的基本操作 ************************/        linkedList.addFirst(0); // 添加元素到列表开头        linkedList.add(1); // 在列表结尾添加元素        linkedList.add(2, 2); // 在指定位置添加元素        linkedList.addLast(3); // 添加元素到列表结尾        System.out.println(&quot;LinkedList（直接输出的）: &quot; + linkedList);        System.out.println(&quot;getFirst()获得第一个元素: &quot; + linkedList.getFirst()); // 返回此列表的第一个元素        System.out.println(&quot;getLast()获得第最后一个元素: &quot; + linkedList.getLast()); // 返回此列表的最后一个元素        System.out.println(&quot;removeFirst()删除第一个元素并返回: &quot; + linkedList.removeFirst()); // 移除并返回此列表的第一个元素        System.out.println(&quot;removeLast()删除最后一个元素并返回: &quot; + linkedList.removeLast()); // 移除并返回此列表的最后一个元素        System.out.println(&quot;After remove:&quot; + linkedList);        System.out.println(&quot;contains()方法判断列表是否包含1这个元素:&quot; + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true        System.out.println(&quot;该linkedList的大小 : &quot; + linkedList.size()); // 返回此列表的元素个数        /************************** 位置访问操作 ************************/        System.out.println(&quot;-----------------------------------------&quot;);        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素        System.out.println(&quot;After set(1, 3):&quot; + linkedList);        System.out.println(&quot;get(1)获得指定位置（这里为1）的元素: &quot; + linkedList.get(1)); // 返回此列表中指定位置处的元素        /************************** Search操作 ************************/        System.out.println(&quot;-----------------------------------------&quot;);        linkedList.add(3);        System.out.println(&quot;indexOf(3): &quot; + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引        System.out.println(&quot;lastIndexOf(3): &quot; + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引        /************************** Queue操作 ************************/        System.out.println(&quot;-----------------------------------------&quot;);        System.out.println(&quot;peek(): &quot; + linkedList.peek()); // 获取但不移除此列表的头        System.out.println(&quot;element(): &quot; + linkedList.element()); // 获取但不移除此列表的头        linkedList.poll(); // 获取并移除此列表的头        System.out.println(&quot;After poll():&quot; + linkedList);        linkedList.remove();        System.out.println(&quot;After remove():&quot; + linkedList); // 获取并移除此列表的头        linkedList.offer(4);        System.out.println(&quot;After offer(4):&quot; + linkedList); // 将指定元素添加到此列表的末尾        /************************** Deque操作 ************************/        System.out.println(&quot;-----------------------------------------&quot;);        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素        System.out.println(&quot;After offerFirst(2):&quot; + linkedList);        linkedList.offerLast(5); // 在此列表末尾插入指定的元素        System.out.println(&quot;After offerLast(5):&quot; + linkedList);        System.out.println(&quot;peekFirst(): &quot; + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素        System.out.println(&quot;peekLast(): &quot; + linkedList.peekLast()); // 获取但不移除此列表的第一个元素        linkedList.pollFirst(); // 获取并移除此列表的第一个元素        System.out.println(&quot;After pollFirst():&quot; + linkedList);        linkedList.pollLast(); // 获取并移除此列表的最后一个元素        System.out.println(&quot;After pollLast():&quot; + linkedList);        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）        System.out.println(&quot;After push(2):&quot; + linkedList);        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）        System.out.println(&quot;After pop():&quot; + linkedList);        linkedList.add(3);        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);        /************************** 遍历操作 ************************/        System.out.println(&quot;-----------------------------------------&quot;);        linkedList.clear();        for (int i = 0; i &lt; 100000; i++) {            linkedList.add(i);        }        // 迭代器遍历        long start = System.currentTimeMillis();        Iterator&lt;Integer&gt; iterator = linkedList.iterator();        while (iterator.hasNext()) {            iterator.next();        }        long end = System.currentTimeMillis();        System.out.println(&quot;Iterator：&quot; + (end - start) + &quot; ms&quot;);        // 顺序遍历(随机遍历)        start = System.currentTimeMillis();        for (int i = 0; i &lt; linkedList.size(); i++) {            linkedList.get(i);        }        end = System.currentTimeMillis();        System.out.println(&quot;for：&quot; + (end - start) + &quot; ms&quot;);        // 另一种for循环遍历        start = System.currentTimeMillis();        for (Integer i : linkedList)            ;        end = System.currentTimeMillis();        System.out.println(&quot;for2：&quot; + (end - start) + &quot; ms&quot;);        // 通过pollFirst()或pollLast()来遍历LinkedList        LinkedList&lt;Integer&gt; temp1 = new LinkedList&lt;&gt;();        temp1.addAll(linkedList);        start = System.currentTimeMillis();        while (temp1.size() != 0) {            temp1.pollFirst();        }        end = System.currentTimeMillis();        System.out.println(&quot;pollFirst()或pollLast()：&quot; + (end - start) + &quot; ms&quot;);        // 通过removeFirst()或removeLast()来遍历LinkedList        LinkedList&lt;Integer&gt; temp2 = new LinkedList&lt;&gt;();        temp2.addAll(linkedList);        start = System.currentTimeMillis();        while (temp2.size() != 0) {            temp2.removeFirst();        }        end = System.currentTimeMillis();        System.out.println(&quot;removeFirst()或removeLast()：&quot; + (end - start) + &quot; ms&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LinkedList&quot;&gt;&lt;a href=&quot;#LinkedList&quot; class=&quot;headerlink&quot; title=&quot;LinkedList&quot;&gt;&lt;/a&gt;LinkedList&lt;/h1&gt;&lt;p&gt;LinkedList实现了List接口和Deque接口的双端链表。&lt;br&gt;链
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>django数据库空值（admin字段空值保存）</title>
    <link href="https://xiaodupi-zyq.github.io/2019/04/19/django%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A9%BA%E5%80%BC%EF%BC%88admin%E5%AD%97%E6%AE%B5%E7%A9%BA%E5%80%BC%E4%BF%9D%E5%AD%98%EF%BC%89/"/>
    <id>https://xiaodupi-zyq.github.io/2019/04/19/django数据库空值（admin字段空值保存）/</id>
    <published>2019-04-19T08:18:58.000Z</published>
    <updated>2019-04-19T08:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>admin后台设置字段为空，很多时候我们的数据库数据在建立之初不会有值，但又不能没有这个字段，比如学生管理系统中的选课表，在这个表中至少有以下几个字段，即：学生学号，课程号，成绩。直接上代码：</p><pre><code>例如：    class Stu_cou(models.Model):        student_number = models.ForeignKey(Student,on_delete=models.CASCADE,verbose_name=&apos;选课学生&apos;)        course_number = models.ForeignKey(Course,on_delete=models.CASCADE,verbose_name=&apos;课程号&apos;)        score = models.FloatField(&apos;成绩&apos;)在表中定义了一个学生选课表。但是在后台admin添加或者前端创建一条实例的时候，成绩不可能有值的，这个时候数据库是不会存储成绩的数据的，这个时候我们应该设置字段可空。则最后一个成绩字段应该设置为：        score = models.FloatField(&apos;成绩&apos;,blank=True,null=True)    其中：        null = True        数据库字段可为空值        blank = True        django的Admin中添加数据允许空值。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;admin后台设置字段为空，很多时候我们的数据库数据在建立之初不会有值，但又不能没有这个字段，比如学生管理系统中的选课表，在这个表中至少有以下几个字段，即：学生学号，课程号，成绩。直接上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：
    class Stu_cou(mod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>django数据库OnetoOnefield的一些错误</title>
    <link href="https://xiaodupi-zyq.github.io/2019/04/18/django%E6%95%B0%E6%8D%AE%E5%BA%93OnetoOnefield%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/"/>
    <id>https://xiaodupi-zyq.github.io/2019/04/18/django数据库OnetoOnefield的一些错误/</id>
    <published>2019-04-18T12:52:13.000Z</published>
    <updated>2019-04-19T08:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>django数据库操作过程中出现django.db.utils.IntegrityError: NOT NULL constraint failed: …… 检查级联新建的数据，是否保存，如果有OneToOneField出现，检查上一级的数据表是否已经保存。</p><pre><code>例如：            new_user = User.objects.create_user(username = work_number, password = password2,email=email)            new_allusers = models.Allusers()            new_student = models.Student()            new_allusers.user = new_user            new_allusers.realname = realname            new_allusers.sex = sex            new_allusers.is_teacher = is_teacher            ####################################################################            student_class = models.Class.objects.get(classname=class_name)            new_student.student_user = new_allusers            new_student.student_class = student_class            ####################################################################            new_user.save()            new_allusers.save()            new_student.save()在这个例子中new_allusers并未保存的情况下，直接将其赋值给new_student.student_user，将会出现文中开头的错误。正确的代码应该是：            new_user = User.objects.create_user(username = work_number, password = password2,email=email)            new_allusers = models.Allusers()            new_allusers.user = new_user            new_allusers.realname = realname            new_allusers.sex = sex            new_allusers.is_teacher = is_teacher            new_user.save()            new_allusers.save()            #####将上级的表格进行保存之后，也就是在数据库中存在了new_allusers，之后再讲new_allusers赋值给new_student.student_user➷➷➷            new_student = models.Student()            student_class = models.Class.objects.get(classname=class_name)            new_student.student_user = new_allusers            new_student.student_class = student_class            new_student.save()有人会说了，在代码的前面new_allusers.user = new_user并没有提前保存，就直接赋值了，但是new_user是使用create_user创建的，在数据库中已经有这么一个数据对象了，所以下面就可以直接赋值了。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;django数据库操作过程中出现django.db.utils.IntegrityError: NOT NULL constraint failed: …… 检查级联新建的数据，是否保存，如果有OneToOneField出现，检查上一级的数据表是否已经保存。&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小六子的鱼的个人博客</title>
    <link href="https://xiaodupi-zyq.github.io/2019/04/13/%E5%B0%8F%E5%85%AD%E5%AD%90%E7%9A%84%E9%B1%BC%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://xiaodupi-zyq.github.io/2019/04/13/小六子的鱼的个人博客/</id>
    <published>2019-04-13T11:10:09.000Z</published>
    <updated>2019-10-30T00:36:50.202Z</updated>
    
    <content type="html"><![CDATA[<p>最近搭建了这个博客，我想着可以把自己学习生活过程中的点点滴滴，记录下来，分享出去如果可以的话可以给大家一些帮助最好了。主要是记录自己的学习生活和新路历程。还有的是，在这里我要特别提到我的一个益友良师Neo，一个在我开始编程的领路人，一个编程牛人。以后自己就要在这里记录自己的学习了！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近搭建了这个博客，我想着可以把自己学习生活过程中的点点滴滴，记录下来，分享出去如果可以的话可以给大家一些帮助最好了。主要是记录自己的学习生活和新路历程。还有的是，在这里我要特别提到我的一个益友良师Neo，一个在我开始编程的领路人，一个编程牛人。以后自己就要在这里记录自己的
      
    
    </summary>
    
    
  </entry>
  
</feed>
